INTSourceChangelist:3810557
Availability:Public
Title:虚幻引擎4行为树有何不同
Crumbs:%ROOT%, Engine, Gameplay, Engine/AI/BehaviorTrees
Description:虚幻引擎4的行为树与传统的行为树有何不同

[TOC(start:2 end:3)]

本节适用于总体上熟悉 **行为树（Behavior Trees）** 并想要尽快深入了解虚幻引擎4实施的人。对于那些以前没有使用过行为树的人，您可能会发现这里的一些解释令人困惑。

行为树的UE4实施与“标准”行为树相比存在三大不同之处：

(#ue4behaviortreesareevent-driven)

## UE4行为树属于事件驱动型

 **事件驱动型（Event-driven）** 的行为树避免在每个帧都执行大量工作。行为树不会不断检查是否发生了任何相关的更改，而是被动地侦听可能触发树中的更改的“事件”。

拥有事件驱动型架构可以同时改善性能和调试。然而，若要充分利用这些改进，您需要了解我们的行为树的其他差异，并适当地构造您的行为树。

由于代码不必每次变动都迭代整个行为树，因此性能明显更佳！从概念上讲，我们可以休息直到有人招呼我们，告诉我们“我们做完了！”，而不是总是询问“我们做完了吗？”

当向前和向后遍历行为树的执行历史记录以可视化地调试行为时，最好让历史记录显示相关的更改，而不是显示无关的更改。在事件驱动型实施中，没有必要过滤掉在行为树上迭代并选择了与以前相同之行为的不相关步骤，因为额外的迭代一开始就不必发生！相反，只有对行为树中的执行位置或黑板数值的变更才是重要之事，而且只显示这些差异也很方便。

(#conditionalsarenotleafnodes)

## 条件语句不是叶节点

在行为树的标准模型中，条件语句是任务叶节点，除了成功和失败，它不会执行任何其他操作。虽然没有什么可以阻止您执行传统的条件语句任务，但是强烈建议使用我们的装饰器（Decorator）系统处理条件语句。

使条件语句成为装饰器而非任务有几个显著的优点。

首先，条件语句装饰器使行为树UI更直观、更易于阅读。由于条件语句位于它们所控制的分支树的树根，如果不满足条件语句，您可以立即看到行为树的哪个部分是“关闭的”。而且，由于所有的树叶都是操作任务，因此更容易看到行为树对实际操作的排序。在传统模型中，条件语句位于树叶之间，因此您需要花费更多的时间来确定哪些树叶是条件语句，哪些树叶是操作。

![](decorator.png)

在行为树的这一部分中，装饰器 **足够接近（Close Enough）** 和 **黑板（Blackboard）** 可以阻止序列节点的子项的执行。

条件语句装饰器的另一个优点是，很容易让这些装饰器充当行为树中关键节点的观察者（等待事件）。这个功能对于充分利用行为树的事件驱动性质至关重要。 

(#specialhandlingforconcurrentbehaviors)
## 并发行为的特殊处理

 标准行为树通常使用一个 **并行（Parallel）** 组合节点来处理并发行为。并行节点同时开始在其所有子项上执行。特殊的规则决定了在一个或多个子树完成操作（取决于所需的行为）时应如何处理。

[REGION:note]
并行节点不一定是多线程的（真正地同时执行任务）。它们只是一种概念上同时执行多个任务的方法。通常它们仍然在同一个线程上运行，并按某种顺序启动。该顺序应该是无关紧要的，因为它们都将在同一帧中发生，但是有时候它仍然很重要。
[/REGION]

UE4行为树不使用复杂的并行节点，而是使用 **简单并行（Simple Parallel）** 节点和我们自己的特殊节点类型（我们称其为服务）来完成相同类型的行为。

(#whynotuseparallelnodes?)
### 为何不使用并行节点？

1.	即使对于相对简单的行为，并行节点也可能非常容易让人困惑。 

	有效地并行节点同时运行一组单独的分支树，但是如果其中一个分支树失败，这些分支树中的任意一个子树或所有子树都可能需要中止，否则当其他分支树完成（不管成功还是失败）时它们可能会成功。即使在简单的案例中，并行行为也可能令人困惑，而且由于或许可用的选项数量众多，它可能变得让人无从着手。

1.	并行节点使优化性能变得更加困难，尤其是在生成事件驱动型行为树方面。


(#whatdoesue4useinsteadofparallelnodes?)

### UE4用什么替代并行节点？

有三种类型的节点可提供通常是并行节点所具有的功能：

(#simpleparallelnodes)

#### 简单并行节点

简单并行（Simple Parallel）节点只允许两个子项：一个必须是单任务节点（带有可选的装饰器），另一个则可以是完整的分支树。

您可以将简单并行节点看做是“在执行A的同时也在执行B）。例如，“在攻击敌人时，朝敌人方向移动。”基本上，A是主要任务，B是等待A完成时的次要任务或补充任务。

虽然有一些用于设置如何处理次要同时任务（任务B）的选项，但与传统并行节点相比，节点在概念上相对简单。尽管如此，它支持并行节点的大多数最常见用法。

简单并行节点可以方便地使用我们的一些事件驱动型优化。全并行（Full Parallel）节点的优化则要复杂得多。


(#services)

#### 服务

 **服务（Services）** 是与任何组合节点（选择器（Selector）、序列（Sequence）或简单并行（Simple Parallel））相关联的特殊节点，这些节点可以每X秒注册一次回调，并执行需要定期进行的各种更新。

例如，一项服务可以用来确定当Pawn继续在其行为树中对其当前的敌人正常行动时，哪个敌人是AI Pawn的最佳追击选择。

只有执行保持在位于服务关联的组合节点的根目录下的分支树中时，服务才处于活动状态。

(#decorator”observeraborts”property)

#### 装饰器“观察者中止”属性

对于标准并行节点，一个常见的用例是不断检查条件，以便在任务所需的条件变为“假”时可以中止任务。例如，如果您有一只猫执行某个序列，例如“摇尾”和“猛扑”，当老鼠逃进了它的老鼠洞时，您可能需要立即放弃。对于并行节点，您将拥有一个用于检查是否可以捕捉到这只老鼠的子项，然后还有另一个子项，即要执行的序列。因为我们的行为树是事件驱动的，所以我们的处理方式是让条件语句装饰器观察它们的值并在必要时中止。（在本例中，您只需要在序列本身上使用“老鼠可以被捕获？（Mouse Can Be Pounced On?）”装饰器，并将“观察者中止（Observer Aborts）”设置为“自身（Self）”。)


(#advantagesofue4’sapproachtoconcurrentbehaviors)

## UE4处理并发行为之方法的优点

(#clarity)

### 清晰

使用服务（Services）和简单并行（Simple Parallel）节点可以创建更容易理解的简单树。

(#easeofdebugging)

### 易于调试

图表越清晰，调试越容易。此外，拥有更少的同时执行路径对于观察图表中实际发生的情况会有巨大的帮助。

(#easieroptimizations)

### 更易于优化

如果事件驱动型图表没有同时执行许多分支树，那么它们更容易优化。


(#faq)

## 常见问题解答

“我真的能用并行节点做到我能做到的一切吗？”

* 我们相信您可以使用我们提供的节点和更好的接口完成所有需要的工作。当然，上述节点可处理最常见的情况。如果我们发现任何不能处理或不理想的极端案例，我们将考虑用额外的补丁来处理这些情况。


“这些是UE4行为树和“标准”行为树之间仅有的区别吗？”

* “标准”用引号括起来是有原因的。实际上并没有所谓的“标准”，因此UE4的实施与您最熟悉的任何实施之间都可能存在许多差异。如果您熟悉一个不同寻常的实施，那么它可能有其他关键的区别，而且可能还有更细微的区别。希望这些注释能让您了解与您在构建行为树时所需采取之方式相关的最重要区别。有关特殊类型节点的更多信息，请参阅有关这些节点的章节。
