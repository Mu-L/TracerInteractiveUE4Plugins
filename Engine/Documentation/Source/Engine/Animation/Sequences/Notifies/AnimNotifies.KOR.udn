INTSourceChangelist:4828051
Availability: Public
Crumbs: 
Title: 애니메이션 노티파이
Description: Notify, 노티파이는 애니메이션 시퀀스에서 이벤트를 구성하고 받아 외부 동작을 수행하는 알림 시스템입니다.
Type: 
Version: 4.21
Parent: Engine/Animation/Sequences
Order: 2

[EXCERPT:Intro]
애니메이션 프로그래머는 **Animation Notification** (애니메이션 노티파이), 또는 **AnimNotify** (애님 노티파이), 줄여서 그냥 **Notify** (노티파이)를 통해 애니메이션 시퀀스 도중의 특정 지점에 이벤트가 발생하도록 구성할 수 있습니다. 노티파이는 걷기나 달리기 도중의 발소리같은 이펙트 추가 및 애니메이션 도중 파티클 시스템을 스폰시키는 데 주로 사용됩니다. 하지만 커스텀 노티파이 유형으로 시스템을 확장시켜 어떤 유형의 게임 요구에도 맞출 수 있기에 다른 식으로도 얼마든지 사용할 수 있습니다.
[/EXCERPT]

[OBJECT:EmbeddedVideo]
	[PARAMLITERAL:width]
	640
	[/PARAMLITERAL]
	[PARAMLITERAL:height]
	360
	[/PARAMLITERAL]
	[PARAMLITERAL:videoid]
	0S7RadIPNeA
	[/PARAMLITERAL]
[/OBJECT]

## 노티파이 추가...

![](AddNotify_01.png)

다양한 유형의 노티파이가 다양한 이벤트를 발동시킵니다. 노티파이를 통해 카메라 이펙트, 파티클 이펙트, 사운드 등을 모두 애니메이션 도중의 일정 시점에 발동시킬 수 있습니다. 노티파이 추가는 **Notify Track** (노티파이 트랙)에서 애니메이션의 노티파이 발생 지점에 우클릭한 뒤 추가하고자 하는 노티파이 유형을 선택하면 됩니다.

[REGION:note]
노티파이 추가/편집 관련 상세 정보는, [애니메이션 시퀀스 에디터](Engine/Animation/Sequences/Editor) 문서를 참고하세요.
[/REGION]

### 스켈레톤 노티파이

**Skeleton Notify** (스켈레톤 노티파이)는 **애니메이션 블루프린트** 안에서 애니메이션 특정 지점에 아티스트가 하려는 모든 작업을 포괄하는 역할을 합니다. Notify (노티파이) 트랙에 우클릭하고 컨텍스트 메뉴에서 **Add Notify...** (노티파이 추가...) 후 **New Notify...** (새 노티파이...)를 선택하여 만듭니다.

![](Skeleton_01.png)

새로 만든 노티파이에 이름을 입력하라는 창이 뜹니다. 

![](Skeleton_02.png)

생성된 모든 스켈레톤 노티파이는 **Skeleton Notifies** (스켈레톤 노티파이) 메뉴 아래 표시됩니다.

![](Skeleton_03.png)

스켈레톤 노티파이를 선택하면 노티파이 트랙에 추가됩니다.

![](Skeleton_04.png)

스켈레톤 노티파이는 스켈레탈 메시의 [애니메이션 블루프린트](Engine/Animation/AnimBlueprints) 에 대한 [스테이트 머신](Engine/Animation/StateMachines) 내 트랜지션 그래프 또는 이벤트 그래프에 이름이 같은 **Notify Event** (노티파이 이벤트)를 만들 수 있습니다. 스켈레톤 노티파이를 추가하려면, **Event** (이벤트) 또는 **Transition Graph** (트랜지션 그래프) 아무데나 우클릭한 뒤 **Add Anim Notify Event** (애님 노티파이 이벤트 추가) 메뉴에서 노티파이를 선택합니다.

![](AddNotify_NewNotify_AnimBP.png)

이벤트 노드가 그래프에 추가되고, 상주하는 애니메이션에서 노티파이가 호출되면 실행됩니다.

![](AddNotify_NewNotify_AnimBPEvents.png)

### 클로딩 시뮬레이션 노티파이

애니메이션 특정 지점에 추가하면 **Clothing Simulation** (클로딩 시뮬레이션)을 제어할 수 있는 네이티브 노티파이가 다수 있습니다.

![](Clothing_01.png)

*   **Pause Clothing Simulation** (클로딩 시뮬레이션 일시중지)는 클로딩 시뮬레이션을 잠깐 멈춥니다.
*   **Resume Clothing Simulation** (클로딩 시뮬레이션 재개)는 일시중지된 클로딩 시뮬레이션을 계속합니다.
*   **Reset Clothing Simulation** (클로딩 시뮬레이션 리셋)은 클로딩 시뮬레이션을 기본 상태로 초기화합니다.

아래는 클로딩 시뮬레이션 노티파이 사용법을 나타내는 예제 비디오입니다.   

[OBJECT:EmbeddedVideo]
	[PARAMLITERAL:width]
	640
	[/PARAMLITERAL]
	[PARAMLITERAL:height]
	360
	[/PARAMLITERAL]
	[PARAMLITERAL:videoid]
	HYKZnLgAOhM
	[/PARAMLITERAL]
[/OBJECT]

### 파티클 이펙트 재생

**Play Particle Effect** (파티클 이펙트 재생) 노티파이는 주어진 소켓 위치와 애니메이션 타임라인 상의 특정 지점에서 파티클 시스템을 스폰하고 재생합니다. 플레이어가 움직일 때 발 주변에 먼지가 표시되게 한다던가, 플레이어가 니트로 부스트를 사용하면 배기관에서 화염이 분출되는 등의 효과를 내는 데 좋습니다.

![](PlayParticleEffect_01.png)

Play Particle Effect 노티파이는 애니메이션 블루프린트를 사용해서 작동방식을 제어하지 않습니다. 그 대신 디테일 패널에 정의된 간단한 프로퍼티 몇 가지를 사용하여 어떤 파티클 시스템을 사용할 것인지, 파티클의 원점은 어느 소켓으로 할 것인지를 결정합니다.

![](PlayParticleEffectDetails.png)

| **프로퍼티** | **설명** |
| --- | --- |
| **PSTemplate** | 파티클 시스템 템플릿 - 노티파이의 시간상 설정된 지점에 스폰할 파티클 시스템입니다. |
| **Socket Name** | 소켓 이름 - 파티클 시스템의 스폰 지점으로 사용될 스켈레탈 메시 소켓입니다. |
| **Attached** | 붙음 - 이펙트를 본/소켓에 붙일지 결정합니다. |
| **Location Offset** | 위치 오프셋 - 소켓에서의 위치 오프셋입니다. |
| **Rotation Offset** | 회전 오프셋 - 소켓에서의 회전 오프셋입니다. |
| **Notify Color** | 노티파이 색 - 노티파이 바에 표시되는 노티파이 색을 변경합니다. |

구성이 완료되면, 소켓 위치를 스폰 지점으로 사용하여 연관된 파티클 시스템을 재생합니다.

![](DustyFeet.png)

### 사운드 재생

애니메이션에 사운드 이펙트 싱크를 맞추는 데는 **Play Sound** (사운드 재생) 노티파이가 단순한 것이 딱입니다.  Play Particle Effect 와 매우 흡사하게, 이 노티파이 역시 디테일 패널에서 설정할 수 있는 몇 가지 단순한 프로퍼티를 통해 빠르고 쉽게 사운드 이펙트 구성이 가능합니다. 이를 통해 로봇이 움직일 때의 기계음, 캐릭터 모션 도중 발생하는 천의 펄럭임, 기타 비슷한 효과를 낼 수 있습니다.

![](PlaySound_01.png)


**Play Sound** 노티파이는 **디테일** 패널에 정의된 몇 가지 단순한 프로퍼티를 통해 어떤 사운드 이펙트를 사용할지, 원점이 될 **소켓** 또는 **본** 은 무엇인지를 결정합니다.

![](PlaySound_02.png)

| **프로퍼티** | **설명** |
| --- | --- |
| **Sound** | 사운드 - 재생할 사운드 애셋입니다. |
| **Volume Multiplier** | 볼륨 배수 - 사운드 이펙트의 볼륨에 적용할 스케일 배수입니다. |
| **Pitch Multiplier** | 피치 배수 - 사운드 이펙트의 피치에 적용할 스케일 배수입니다. |
| **Follow** | 따라가기 - 체크하면 사운드 이펙트 소스가 스태틱 메시의 이동을 따라갑니다. 체크하지 않으면 사운드는 스폰된 자리에 머물러 있습니다. |
| **Attach Name** | 붙일 이름 - 사운드 이펙트의 스폰 지점으로 사용할 스켈레탈 메시 소켓이나 본 이름입니다. |
| **Notify Color** | 노티파이 색 - 노티파이 바의 노티파이 색을 변경합니다. |

### 다이내믹스 리셋

**Reset Dynamics** (다이내믹스 리셋) 노티파이를 사용하면 스켈레탈 메시에 적용되는 [애님 다이내믹스](Engine/Animation/NodeReference/SkeletalControls/AnimDynamics) 를 애니메이션에서 호출한 시점의 원래 상태로 되돌립니다.

![](ResetDynamics_01.png)

**디테일** 패널을 통해 노티파이 트랙 창에서 이 노티파이 색을 변경할 수도 있습니다. 

![](ResetDynamics_02.png)

## 노티파이 스테이트 추가...

**![](NotifyStates_01.png)**

**Anim Notify State** (애님 노티파이 스테이트), 또는 **Notify State** (노티파이 스테이트)는 위의 표준 노티파이와 비슷합니다. 다른 점은 begin(시작), tick(틱), end(끝) 세 개의 이벤트가 있습니다. 단순히 시작해서 노티파이 시작과 끝 지점에 발동되고, 애니메이션에서 시간이 다가왔을 때 그 안의 **이벤트 그래프** 가 발동됩니다. 틱은 끝 이벤트에 도달할 때까지 모든 애니메이션 업데이트를 발동합니다. 보통 노티파이와 노티파이 스테이트와 큰 차이점은, 자체 독립적인 [블루프린트](Engine/Blueprints) 라는 점입니다.

노티파이 스테이트에 추가 고려할 사항입니다. 

*   Notify Begin Event 로 시작하는 것이 보장됩니다.
*   Notify End Event 로 끝나는 것이 보장됩니다.
*   Notify Begin 및 Notify End 이벤트 사이를 Notify Tick 으로 감싸는 것이 보장됩니다.
*   (보통이든 스테이트든) 다양한 애님 노티파이 사이 순서는 보장되지 않습니다. 애님 노티파이 스테이트 두 개를 서로 붙여 놓으면, 먼저 것이 끝난 후에 다음 것이 시작한다는 보장이 없습니다. 다른 노티파이에 의존하지 않는 개별 동작에만 사용하세요.
*   음수 재생 속도가 지원됩니다. Notify Begin 은 무조건 처음에, Notify End 는 마지막에 호출됩니다.

[REGION:note]
매 프레임마다 무언가를 수정한다면, Tick 블루프린트로 가야 합니다. 틱 이전에 변수, 플래그, 프로퍼티를 어떤 값으로 설정해야 한다면, Begin 블루프린트로 가야 합니다. 마지막으로 End 블루프린트를 사용하여 최종 틱 이후 변수, 플래그, 프로퍼티를 변경할 수 있습니다.
[/REGION]

### 시한 파티클 이펙트

**Timed Particle Effect** (시한 파티클 이펙트)는 애니메이션 일정 시점에서 파티클 이펙트를 재생할 수 있다는 점에서 **Play Particle Effect** 노티파이와 비슷하지만, 차이점은 Timed Particle Effect 의 경우 노티파이 자체 내에서 이펙트 길이를 정의할 수 있다는 점입니다.

![](NotifyState_Timed_01.png)

아래 이미지에서 Timed Particle Effect 를 애니메이션에 할당합니다. 끝( 또는 시작) 부분의 핸들 바를 좌클릭하고 끌면 이펙트 길이를 늘이거나 줄일 수 있습니다.

![](NotifyState_Timed_02.png)

Timed Particle Effect 의 프로퍼티는 Play Particle Effect Notify 와 같으며 **디테일** 패널에서 조정할 수 있습니다.

### 애니메이션 트레일

Animation Trail (애니메이션 트레일), 또는 줄여서 **AnimTrail** (애님 트레일)은 씬에서 움직이는 오브젝트 뒤에 흔적을 남기는 이미터입니다. 스켈레탈 메시의 두 소켓 위치를 매 틱마다 샘플링한 뒤 그 소켓 사이 트라이앵글을 흔적 길이만큼 이어 붙입니다.

![](NotifyState_Trail_01.png)

아래는 애니메이션 캐릭터에 Animation Trail 을 사용한 예제입니다.

[OBJECT:EmbeddedVideo]
	[PARAMLITERAL:width]
	640
	[/PARAMLITERAL]
	[PARAMLITERAL:height]
	360
	[/PARAMLITERAL]
	[PARAMLITERAL:videoid]
	bjkEo7gxbHE
	[/PARAMLITERAL]
[/OBJECT]

AnimTrail 이미터를 사용하려면 반드시:

1.  AnimTrail 유형 데이터 포함 이미터가 들어있는 [파티클 시스템](Engine/Rendering/ParticleSystems) 을 만들어야 합니다.
2.  애니메이션에 **Trail** 유형 노티파이 스테이트를 생성하고 추가합니다.

AnimTrail 을 추가했으면, **디테일** 패널에서 프로퍼티를 조정할 수 있습니다.

![](NotifyState_Trail_02.png)

| **프로퍼티** | **설명** |
| --- | --- |
| **PSTemplate** | 파티클 시스템 템플릿 - 위에 설명한 애님 트레일이 들어있는 파티클 시스템입니다. |
| **First Socket Name** | 첫 번째 소켓 이름 - 흔적을 정의하는 첫 번째 본/소켓 이름입니다. |
| **Second Socket Name** | 두 번째 소켓 이름 - 흔적을 정의하는 두 번재 본/소켓 이름입니다. |

위 프로퍼티는 필수이지만 아래는 옵션입니다. 애니메이션 도중 흔적의 너비를 변경할 수 있습니다. 필에요 따라 움직이는 소켓에 흔적을 붙일 수도 있지만, 이상적이지는 않습니다. 이 방법은 너비 스케일 값을 제공하는 것을 기반으로 합니다. 너비 스케일이 1.0 이면 흔적의 너비를 똑같이 유지하고, 0.0 이면 흔적의 너비는 0 이 됩니다.

| **프로퍼티** | **설명** |
| --- | --- |
| **Width Scale Mode** | 너비 스케일 모드 - 너비 적용 방식을 변경합니다. 아래 그림으로 확인할 수 있습니다. 예제에서 사인같은 곡선이 중간에 0 에서 1 로 갔다가 다시 0 으로 돌아옵니다. |
| **Width Scale Curve** | 너비 스케일 커브 - 매 틱 샘플링하는 커브에서 오는 너비 값입니다. 이 프로퍼티는 그 커브의 이름입니다. 그 커브 생성 방법 관련 자세한 내용은 아래를 참고하세요. |

![](WidthScaleMode.png)

*왼쪽 이미지 From Centre 는 중앙에서 바깥쪽으로 비례하는 모습을, 가운데 이미지 From First Socket 은 첫 소켓에서의 거리와 비례하는 모습을, 오른쪽 이미지 From Second Socket 은 두 번째 소켓에서의 거리와 비례하는 모습을 나타냅니다.*

사용할 수 있는 렌더링 디버그 옵션도 몇 가지 있습니다.  

| **프로퍼티** | **설명** |
| --- | --- |
| **Render Geometry** | 지오메트리 렌더 - 메인 트레일 지오메트리 렌더링 토글입니다. |
| **Render Spawn Points** | 스폰 지점 렌더 - 트레일 1차 스폰 지점, 즉 매 틱 소켓에서 샘플링한 위치의 디버그 렌더링 토글입니다. |
| **Render Tangents** | 탄젠트 렌더 - 커브 탄젠트의 디버그 렌더링 토글입니다. |
| **Render Tessellation** | 테셀레이션 렌더 - 커브의 모든 버텍스 디버그 렌더링 토글입니다. 스폰 지점 사이 커브 테셀레이션 방식을 보여줍니다. |

Notify Color 를 변경하여 노티파이 트랙 창에 사용되는 색을 바꿀 수도 있습니다. 

### 커스텀 노티파이 스테이트

Custom Notify State (커스텀 노티파이 스테이트)는 다른 부분은 기본 노티파이 스테이트와 같고 애니메이션 도중 필요한 로직을 제공할 수 있는 커스텀 블루프린트입니다. 생성 방법은 일반 노티파이 추가와 같습니다.커스텀 노티파이 스테이트를 사용하기에 앞서, 먼저 [블루프린트 클래스를 생성](Engine/Blueprints/UserGuide/Types/ClassBlueprint/Creation) 하고 Anim Notify State 클래스로 지정해야 합니다. 생성했으면, 애니메이션의 **Notify Track** (노티파이 트랙)에 우클릭하고 **Add Notify State...** (노티파이 스테이트 추가...)를 선택한 뒤 커스텀 노티파이를 선택합니다.

![](NotifyState_Custom_01.png)

위에서 **MyCustomNotifyState** 라는 AnimNotifyState 블루프린트 클래스를 만들었으므로 애니메이션에서 사용할 노티파이 스테이트로 선택할 수 있습니다. 애님 노티파이 스테이트 블루프린트를 만들었으면, 아래와 같이 노티파이 사용 방법을 결정하는 함수 구현을 시작하면 됩니다.

![](NotifyState_Custom_02.png)

모든 함수를 구현할 필요는 없지만, 최소한 **Received Notify Tick** (노티파이 틱 수신), 아니면 **Received Notify Begin** 및 **Received Notify End** (노티파이 시작/끝 수신) 둘 다 구현해야 합니다. **Received Notify Begin** 이나 **Received Notify End** 중 하나만 구현한다면, 그냥 표준 애니메이션 노티파이를 사용해도 됩니다.
  
아래는 **Notify Begin** 오버라이드입니다.

![](Recieved_NotifyStart.png)

아래는 **Notify End** 오버라이드입니다.

![](Recieved_NotifyEnd.png)

아래는 **Notify Tick** 오버라이드입니다. 

![](NotifyState_Custom_03.png)

오버라이드 함수에서 각 핀 유형을 사용하는 방법에 대한 설명은 다음과 같습니다.

| **핀** | **설명** |
| --- | --- |
| **Mesh Comp** | 메시 컴포넌트 - 이 애님 노티파이 스테이트를 트리거하는 애니메이션 시퀀스 또는 몽타주의 스켈레탈 메시 컴포넌트입니다. |
| **Anim Seq** | 애님 시퀀스 - 이 애님 노티파이 스테이트를 트리거하는 애니메이션 시퀀스입니다. |
| **Frame Delta Time** | 프레임 델타 시간 - Received Notify Tick 함수에서만, 지난 애니메이션 업데이트 이후 지난 시간을 알려줍니다. |

[REGION:note]
현재 블루프린트 안에서 애님 노티파이 스테이트 길이를 구할 수 있는 방법은 없습니다.
[/REGION]

## 싱크 마커 추가...

관련된 애니메이션들의 동기화 상태를 유지하는 방법을 찾는다면, [Sync Group](Engine/Animation/SyncGroups) (싱크 그룹)을 사용하면 됩니다. 관련 애니메이션 안에서 **Sync Marker** (싱크 마커)로 동기화할 수도 있습니다. 싱크 마커를 추가하려면, 노티파이 트랙 창에 우클릭하고 **Add Sync Marker...** (싱크 마커 추가...)를 선택합니다.  
![](SyncMarker_00.png)

싱크 마커에 이름을 입력하라는 창이 뜹니다.

![](SyncMarker_01.png)

싱크 마커 이름을 입력하면, **Existing Sync Markers** (기존 싱크 마커) 서브메뉴 아래에 나타납니다.

![](SyncMarker_02.png)

이제 다른 애니메이션에 그 싱크 마커를 추가하면 됩니다.

**싱크 마커로 작업할 때 고려할 몇 가지 요소입니다.**

*   같은 싱크 그룹에 있는 애니메이션만 동기화되며, 리더가 같은 싱크 그룹 내 팔로워 위치를 구동합니다.
*   재생 속도는 항상 마스터 애니메이션 속도입니다 (재생 속도 조정은 현재 지원하지 않습니다).
*   그룹 내 모든 애니메이션에 공통인 마커만 동기화됩니다.
    *   예를 들어 한 애니메이션에 "Right Foot Down" 마커가 없는 경우, 모든 애니메이션에서 그 프레임의 위치를 결정할 때 그 마커를 무시합니다.
*   공통 마커에 대해서 리더의 상대 위치에 따라 위치를 동기화합니다.
    *   예를 들어 리더가 왼/오른발 마커 사이 25% 에 있다면, 팔로워 각각은 왼/오른쪽 마커 사이 25% 에 동기화됩니다.
*   마커 기반 동기화는 애니메이션이 싱크 그룹에 있고 일치하는 마커가 충분할 때 자동으로 사용됩니다. 그렇지 않으면 원래 스케일 적용 길이 동기화 방식을 사용합니다.
*   [애님 몽타주](Engine/Animation/AnimMontage) 역시 블렌드 아웃 도중 마커 기반 동기화를 지원하여, 다른 애니메이션으로 부드럽게 전환할 수 있습니다.
    *   싱크 그룹 세팅은 애님 몽타주의 [애셋 디테일](Engine/Animation/Persona/AnimAssetDetails) 패널에서 찾을 수 있습니다.

[REGION:note]
싱크 마커는 애니메이션에 [애니메이션 모디파이어](Engine/Animation/AnimModifiers) 를 구성하고 적용하여 자동 추가할 수도 있습니다.
[/REGION]

## 노티파이 관리...

스켈레톤 노티파이를 새로 추가하거나, 기존의 것을 이름변경 또는 제거하려면, **노티파이** 트랙에 우클릭하고 **노티파이 관리** 옵션을 사용합니다.

![](ManageNotifies_01.png)

**애니메이션 노티파이** 창에 생성한 노티파이가 표시됩니다.

![](ManageNotifies_02.png)

우클릭하여 새 노티파이를 생성하거나, 노티파이에 우클릭하고 이름변경 또는 삭제합니다.

**노티파이 관리** 창에서 **디테일** 패널의 **Scan** (스캔) 버튼을 클릭하여 현재 선택된 노티파이를 사용 중인 애니메이션을 확인할 수도 있습니다.

![](ManageNotifies_04.png)

선택된 노티파이를 사용하는 애니메이션이 **디테일** 패널에 표시됩니다.
  
![](ManageNotifies_05.png)

## 부가 노티파이 프로퍼티

각 노티파이 유형의 **디테일** 패널 **Anim Notify** 섹션에서 변경할 수 있는 프로퍼티에 추가로 (적용 가능한 경우) 노티파이 사용 방식을 정의할 수 있는 추가 프로퍼티는 아래와 같습니다.

![](AdditionalProperites_01.png)

| 트리거 세팅 ||
| --- | --- |
| **Notify Trigger Chance** | 노티파이 트리거 확률 - 노티파이 발동 확률을 정의합니다 (0=발동 안됨, 1=항상 발동). |
| **Trigger on Dedicated Server** | 데디케이티드 서버에서 트리거 - 끄면 이 노티파이는 데디케이티드 서버에서는 생략됩니다. |
| **Trigger on Follower** | 팔로워에 트리거 - 활성화하면 이 노티파이는 애니메이션이 싱크 그룹의 팔로워일 때 발동됩니다 (기본적으로 싱크 그룹의 리더만 트리거를 알립니다). |
|**Notify Filter Type**| 노티파이 필터 유형 - 노티파이 필터링 (발동 중지) 방법을 정의합니다. 필터를 메시의 현재 LOD 로 설정할 수 있습니다. |

| 이벤트 ||
| --- | --- |
| **Trigger Weight Threshold** | 트리거 가중 한계치 - 노티파이 발동에 필요한 애니메이션 시퀀스의 가중치를 결정합니다. |
| **Montage Tick Type** | 몽타주 틱 유형 - 노티파이 처리 방식을 결정하는 메서드로, Queued (대기열 방식)인지 Branching Point (분기점 방식)인지 결정합니다 (아래 몽타주 틱 유형 부분을 참고하세요). |

### 몽타주 틱 유형

Montage Tipe Type (몽타주 틱 유형) 중 Queued (대기열 방식)과 Branching Point (분기점 방식)의 주요 차이점은, 대기열 방식은 비동기식인 반면, 분기점 방식은 동기식입니다. 최종 사용자 입장에서 이게 무슨 뜻이냐면, 분기점 방식은 애니메이션 타임라인 상의 위치를 지정하는 데 있어 정밀도가 훨씬 높다는 뜻입니다.

특정 애니메이션의 매우 정확한 지점으로 점프를 해야 할 필요가 있을 경우라면 정밀도가 높아야 합니다. 대기열 방식으로도 같은 작업을 할 수는 있지만, 그 비동기 속성으로 인해 이벤트 발동이 다른 애니메이션 프레임에서 일어날 수 있으므로, 동작에 버벅임이나 끊김이 발생할 수 있습니다.

[REGION:warning]
분기점 방식은 그 동기적 속성과 그로 인한 정밀도로 인해 대기열 방식보다 퍼포먼스 비용이 높습니다. 이벤트가 애니메이션 타임라인 상의 정확한 지점에 발동해야 하는 경우, 이를테면 다른 애니메이션으로 직접 점프할 때 프레임 단위로 일치해야 하는 경우에만 사용해야 합니다. 한 (또는 소수점) 프레임 정도 어긋나도 괜찮은 경우, 대기열 방식을 사용하는 것이 좋습니다.
[/REGION]