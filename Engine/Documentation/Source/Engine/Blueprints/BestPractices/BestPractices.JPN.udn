INTSourceChangelist:3782314
Availability:Public
Title:ブループリントのベスト プラクティス
Crumbs:%ROOT%, Engine/Blueprints
Description:ブループリントの使用および設定時にベストな判断をするためのヒントとトリック
version:4.9
parent:Engine/Blueprints
tags:Blueprints
topic-image:BestPractices_Topic.png

[TOC(start:2)]


**ブループリント** を使って様々な事ができます。簡単なゲームやプロシージャル コンテンツ ツールの作成、新機能のプロトタイピング、プログラマーが作成したゲームの微調整や仕上げなどを、
ブループリントのビジュアル スクリプティング システムで行うことができます。

しかし、それらの作業をブループリントで行うと、パフォーマンスを妨げてしまう要素もあります。 
ティックごとに多数の操作と複雑な演算を実行するブループリントを作成した場合は、
C++ コードの使用を検討されることをお勧めします。ダメージの処理、コントロール、その他、フレームごとに呼び出されない処理などイベント駆動型機能を作成する場合は、ブループリントが最適です。

ブループリントのコーディングやブループリントのコンパイルに関する技術的な詳細は、 [](Engine\Blueprints\TechnicalGuide) を参照してください。

機能がブループリントに最適になっていても、さらに処理を円滑にするために自分でブループリントを設定することができます。このページは
一般的な判断基準に加えて、ブループリント ユーザーがヒントとトリックを学ぶためのガイドです。

## Level ブループリント vs. Blueprint クラス

Level ブループリントは、オブジェクトをレベルで直接選択したり、オブジェクト上で操作が可能であるため、UE3 のキズメットユーザーにとっては大変なじみ深い機能と言えます。一度限りのプロトタイプ作成や、ブループリントシステムに慣れるための使用には適していますが、 
使用しているレベルに固有の機能となります。これはレベル固有、またはレベルのアクタ固有の機能設定に Level ブループリントが 
最適であることを意味します。あるトリガーに触れた時にシネマティックを開始、またはすべてのエネミーを倒した後に特定ドアを開くなどが例として挙げられます。

一般的に Blueprint クラスは、プロジェクトで再利用可能なビヘイビアの取得に最も適した方法です。Blueprint クラスを作成した場合は、このクラスを好きなレベルへ追加したり、
スクリプトをコピーせずに、クラスのコピーを必要なだけレベルへ追加することもできます。 

Level ブループリントで開始してから、ビヘイビアを Blueprint クラスへ移行させると決定しても、移行プロセスはとてもシンプルです。アクタで操作する Level ブループリントから関数をコピーした時 (例えばライトに Set Brightness を呼び出す）や、 
Light アクタに基づく Blueprint クラスへこれらの関数を貼り付ける時に、関数は適切なスコープに更新されます。  

**詳細はこちら:**
* [](Engine\Blueprints\UserGuide\Types\LevelBlueprint)
* [](Engine\Blueprints\UserGuide\Types\ClassBlueprint)

## クラス変数 vs. ローカル変数

ブループリントの作業時は、[](Engine\Blueprints\Editor\UIComponents\MyBlueprint) タブを使って [変数](Engine\Blueprints\UserGuide\Variables) を
追加することができます。関数内からは、**[My Blueprint]** タブに **Local Variables** 用の追加セクションが表示されます。

![](VariablesLocal.png)

ローカル変数にはスコープが適用されています。つまり、ローカル変数を定義した場所にだけ存在します。関数のローカル変数は、対象となる関数だけに表示されて、 
その他の関数やイベントグラフには表示されません。関数のコンテキスト内部のみで関連性がある場合など、非表示にすることで乱雑な状態になることを防いでくれます。ローカル変数は関数で作業するための「スクラッチパッド」と考えてください。関数の実行に使用できますが、 
関数が終了すると破棄されます。  

Class 変数は、ブループリントの複数の場所からアクセスが必要な状況に使用します。例えば、別のブループリントからアクセスが出来るように公開しなくてはいけないメッシュや別のコンポーネント、
または変数へのリファレンスなどです。これらはクラス変数にしなくてはいけません。使用後もこれらの変数のことは忘れないでください

## 関数 vs. マクロ

**関数** と **マクロ** はともに外部で同じ目的を果たします。ノードへ入力を送信し、それが処理されて、出力がでます。この 2 つは異なる方法で目的を達成しますが、 
これらの方法には類似点があります。

-	関数とマクロにはノードが実行する機能を編集することができる中心的な場所 (マクロはマクログラフ、関数は関数グラフ) が備わっていて、 
関数やマクロを呼び出すすべてのノードは、この位置が変更すると常に更新されます。
-	両方とも再利用可能
-	両方ともローカル変数に有効マクロは「無名」のローカル変数なため固有名が無く、単に値を保持するだけです。
-	利用性と明確さを増すために、両方とも機能をカプセル化するのに最適な方法です。

より高度なユースケースに関わるといくつかの決定的な違いが明白になります。

-	関数を呼び出すためのノードを配置すると、実際に関数を呼び出します。つまりこれらをターゲットにすることができて (例えば別のオブジェクトに関数の呼び出し)、 
ブループリント間の通信が有効になります。
-	マクロはマクログラフからノードを受け取って、マクロノードをこれらのノードすべてのコピーと置換します。基本的にブループリントのコンパイル時は、マクロはすべてのグラフノードをコピーして、
 マクロノードの位置にこれらを貼り付けます。

エンジン内部での動作方法のため、出来ることにちょっとした違いがいくつかあります。

-	マクロはスコープを設定したクラスのノードに対して使用することができます (新規 Macro ブループリントを作成時に選択したクラスや、ローカルマクロの場合はマクロが定義されているクラス)。  
つまり、マクロを配置することができるノードにバリエーションを持たせることができます。  
- 関数とマクロの一番大きな違いの 1 つに、Latent ノードはマクロに配置できますが、関数には配置出来ない点があります。
-	子ブループリントで関数の機能をオーバーライドすることが出来ます。例えば、"PlayerInteractedWithMe" 関数がある Car ブループリントがあると仮定します。この関数で、 
車のクラクションを鳴らすとします。パトカーと消防車用に Car ブループリントの 2 つの子供があるとします。パトカーのサイレンを鳴らしてライトを点灯するために 
関数のオーバーライドが可能です。放水ができる消防車にすることも出来ます。このような関数のオーバーライドはマクロでは行うことはできません。
-	マクロはコンパイル時にグラフへコピー＆ペーストされるだけなので、マクロを通過する複数の実行ワイヤーを設定することができます。関数に実行ワイヤーは設定出来ません。

場所に関係なく機能の迅速なビットを再利用したい場合は、経験則から言えば一般的にマクロを使用します。その時にブループリントの子供でビヘイビアを微調整したり、 
別のブループリントから直接アクセスする場合もあります。

**詳細はこちら:**
* [](Engine\Blueprints\UserGuide\Functions)
* [](Engine\Blueprints\UserGuide\Macros)

## ブループリント通信の種類

ブループリント間の通信にはいくつかの方法があります。最も一般的なユースケースはブループリント同士の直接通信ですが、
ユーザーが使用する機能によってイベント ディスパッチャーとブループリント インターフェースを代わりに使用します。各種通信の概要、ユースケース例、プロジェクトの開始に役立つチュートリアルは、
[](Engine\Blueprints\UserGuide\BlueprintCommsUsage) を参照してください。3 種類全てを使用してプロジェクトを作成するには、[](Engine/Blueprints/HowTo) ガイドを参照してください。



## 一般的なヒント

### ブループリント エディタの作業

ブループリント エディタで作業する場合、使用するノードや既存のノードやコメントを検索するためのトリックがいくつかあります。

* 既存ブループリントで何かを検索する時は、検索対象が変数、関数、コメントどれであっても、ブループリントエディタで **[Search (検索)]** ボタンを使用します。**[Find in Current Blueprint (現行ブループリントで検索)]** ボックスのチェックを外せば、ロードしていないブループリントを含めてすべてのブループリントを検索します。
実装したての何かをちょっと確認したりする場合に便利です。  

	![](SearchResults.png)

* コンテンツメニューにはドラッグしたピンと接続可能なノードだけが表示されます (例えばライトからドラッグした時はライトに関係がある関数のみを表示)。  
変数やコンポーネントに作用する実行可能な機能を探したい場合は、単にコンテキストメニューをブラウズして利用可能な変数およびコンポーネントを閲覧します。

	![](ContextMenu.png)

* コンテキストメニューもしくはパレットを使用する時は、検索バーがとても便利です。名前が分からない時も簡単に検索できるように、関数はさまざまなキーワードとタグ付けされています。

	![](search_rotate.png)

### グラフの設定

グラフ設定は好みにあわせて自由にできますが、きちんと整理された見やすいグラフ管理のためのヒントを紹介します。

* 常に整理整頓をしましょう！大量のコードを作成してしまってから整理するよりも、作業中に整理を進める方がはるかに楽です。
* グラフで同じノードを 2 回以上使用している場合は、再利用のための関数かマクロの作成を検討してください。
* 空間をコンパクトにまとめるため、コンテクストでノードをスタックすることができます。例えばライトへのリファレンスがある場合は、ライトの Point Light コンポーネントにアクセスして、 
2 つのノードのうち 1 つのノードを、もうひとつのノードにスタックすることができます。単一ブロックとして考えてください。

	![](stackednodes.png)
* [コメント](Engine\Blueprints\UserGuide\Comments) をこまめに利用しましょう！グラフのセクションを特定する追加のヘルプとして、コメント枠の色は変更可能であることを覚えておいてください。

