INTSourceChangelist:6652343
Availability:Public
Title:블루프린트 실전 사례
Crumbs:%ROOT%, Engine/Blueprints
Description:블루프린트를 언제 사용할 것인지와 그 최적의 구성 방법에 대한 의사 결정을 돕는 팁과 정보입니다.
version: 4.9
parent:Engine/Blueprints
tags:Blueprints
topic-image:BestPractices_Topic.png

[TOC(start:2)]


블루프린트로 할 수 있는 일은 많습니다. 작은 게임이나 콘텐츠 절차적 생성 툴에서부터 새로운 함수성에 대한 프로토타입 제작, 프로그래머가 만든 부분에 대한 트윅 및 폴리싱에 이르기까지,
모두 블루프린트 비주얼 스크립팅 시스템으로 가능합니다.

하지만 블루프린트로 했을 때 퍼포먼스에 영향이 있는 작업도 있습니다.
매 틱마다 복잡한 계산이나 연산을 많이 하는 블루프린트가 있다면, 네이티브 C++ 사용을 고려해 봐야 합니다.
블루프린트는 이벤트 주도형 함수성, 이를테면 대미지, 컨트롤 등 매 프레임 호출되지 않는 것들의 처리에 최적화되어 있습니다.

블루프린트 코딩 관련 상세 정보 또는 블루프린트 컴파일 관련 기술적 세부사항은 [](Engine\Blueprints\TechnicalGuide) 문서를 참고하세요.

함수성이 블루프린트에 잘 맞는다 쳐도, 블루프린트 구성에 있어 보다 매끄러운 실행을 위해 결정해야 하는 부분이 있습니다. 여기서는 흔히 내려야 하는 결정사항은 물론, 
블루프린트 사용자를 위한 팁과 정보를 살펴보도록 하겠습니다.

<!-- removing link for now.
[REGION:tip]
블루프린트 또는 비주얼 스크립팅이 처음인 분들은, **Blueprint Essential Concepts** (블루프린트 핵심 개념) 강의를 확인해 보세요. 언리얼 엔진 4 의 블루프린트 사용법, 블루프린트와 전통적 프로그래밍 언어와의 관계, 블루프린트 에디터 UI, 컴포넌트, 그래프, 블루프린트를 사용하는 데 있어서 주의점을 확인할 수 있습니다.
[OBJECT:TopicCompact]
	[PARAM:image]
		![](BlueprintEssentialsUA.png)
	[/PARAM]
	[PARAM:icon]
		![](%ROOT%/blueprint_icon.png)(convert:false)
	[/PARAM]
	[PARAM:title]
		블루프린트 핵심 개념 강의
	[/PARAM]
	[PARAMLITERAL:path]
		https://academy.unrealengine.com/Class/blueprint-essential-concepts
	[/PARAMLITERAL]
[/OBJECT]
[/REGION]
-->


## 레벨 블루프린트 대 블루프린트 클래스

레벨 블루프린트는 UE4 의 키즈멧 사용자들에게 매우 익숙할 수도 있는데, 레벨에서 오브젝트를 직접 선택하여 작업을 할 수 있기 때문입니다. 일회성 프로토타입에 뛰어나며,
블루프린트 시스템에 익숙해지기 좋지만, 사용되는 레벨에만 한정되어 있습니다. 즉 레벨 블루프린트는 레벨 또는 그 안의 액터에 한정된 함수성을 구성하기에 좋은 곳이라는 뜻입니다.
예를 들자면, 특정 트리거를 건드렸을 때 시네마틱을 시작시킨다거나, 모든 적을 해치운 후 특정 문을 연다거나 하는 것입니다.

일반적으로, 블루프린트 클래스는 프로젝트에서 무언가를 재사용하기에 최고의 방법입니다. 블루프린트 클래스를 만들어 두면, 어느 레벨에도 추가할 수 있으며, 스크립트를 복사하지 않고도 
레벨에 원하는 수만큼의 사본을 추가시킬 수도 있습니다.

레벨 블루프린트로 시작을 했는데, 특정 기능을 블루프린트 클래스로 옮기기로 결정했다면, 이는 매우 간단한 일입니다. 레벨 블루프린트에서 액터에 어떤 작업을 하는 
(이를테면 라이트에 Set Brightness 호출을 하는) 함수를 복사한 다음, 라이트 액터를 기반으로 하는 블루프린트 클래스에 붙여넣으면, 함수가 해당 범위(scope)에 맞게 제대로 업데이트될 것입니다.

**추가 자료:**
* [](Engine\Blueprints\UserGuide\Types\LevelBlueprint)
* [](Engine\Blueprints\UserGuide\Types\ClassBlueprint)

## 클래스 변수 대 로컬 변수

블루프린트에서 작업을 할 때는, [](Engine\Blueprints\Editor\UIComponents\MyBlueprint) 탭을 사용해서 [변수](Engine\Blueprints\UserGuide\Variables) 를 추가시킬 수 있습니다. 
하지만 함수나 매크로 안에 있을 때, **내 블루프린트** 탭에 **로컬 변수** 추가 섹션이 보일 것입니다.

![](VariablesLocal.png)

로컬 변수는 범위(scope)가 있는, 정의하는 곳에만 존재하는 것입니다. 즉 함수나 매크로의 로컬 변수는 그 함수 안에서만 보이며, 다른 함수나 이벤트 그래프에는 보이지 않습니다.
그 함수 안에서만 연관성이 있는 것들이 남아돌지 않도록 하는 데 좋습니다. 로컬 변수란 함수 안에서 작업하는 "스크래치 패드" 같은 개념으로 생각해 보면 됩니다.
함수의 작업에 필요한 것을 잠깐 썼다가, 함수가 완료되면 지워버리는 것입니다.

클래스 변수는 블루프린트 여러 곳에서 접근할 가능성이 있는 것에 쓰입니다. 즉 메시나 다른 컴포넌트에 대한 레퍼런스, 또는 
다른 블루프린트에서 접근할 수 있도록 public 이어야 하는 변수는 클래스 변수여야 합니다. 즉 한 번 쓰고 버리지 않는 용도입니다.

## 함수 대 매크로

함수와 매크로 둘 다 외부적으로 목적이 같습니다: 노드에 입력을 보내서, 무언가 처리를 한 다음, 출력이 나옵니다. 내부적으로 처리되는 방식은 다르나, 
다음과 같은 유사성이 있습니다:

-	둘 다 노드가 무슨 일을 하는지 그 함수성을 편집할 수 있는 집합소(매크로는 별도의 매크로 그래프, 함수는 별도의 함수 그래프)가 있으며, 
함수나 매크로를 호출하는 모든 노드는 그 집합소가 바뀔 때마다 업데이트됩니다.
-	둘 다 재사용 가능합니다.
-	둘 다 로컬 변수가 가능합니다. 매크로는 이름을 지정할 필요 없이 값만 갖는 "anonymous" (무명) 로컬 변수를 사용합니다.
-	둘 다 함수성을 캡슐화시켜 재사용성이나 명료성에 좋습니다.

조금 더 깊이 들어가면 명확해 지는 핵심적 차이점은 이렇습니다.

-	함수는 그 함수를 호출하는 노드를 배치해야 실제로 호출됩니다. 즉 타깃을 설정해야 (즉 "다른 오브젝트에 함수를 호출"해야) 
블루프린트간의 통신이 가능해집니다.
-	매크로는 매크로 그래프에서 노드를 취한 뒤, 매크로 노드를 실제 그 노드 사본들로 대체합니다. 기본적으로 블루프린트 컴파일시 매크로는 모든 그래프 노드를 복사한 다음 
매크로 노드 위치에 붙여넣는 것입니다.

내부적인 작동방식 차이로 인해, 할 수 있는 작업에 약간의 차이점이 있습니다:

-	매크로는 범위 내 클래스에 대한 어떤 노드든 사용할 수 있습니다 (새 매크로 블루프린트 생성시 선택한 클래스를, 로컬 매크로인 경우 매크로가 정의되어 있는 클래스를 말합니다).
즉 매크로에 넣을 수 있는 노드에 대한 제약이 약간 덜하다는 뜻입니다.
- 함수와 매크로의 가장 큰 차이점은, 매크로에는 잠복성(latent) 노드를 놓을 수 있는 반면, 함수에는 안됩니다.
-	함수는 자손 블루프린트에서 그 함수성을 덮어쓸 수 있습니다. 예를 들어 차량 블루프린트에 "PlayerInteractedWithMe" 함수가 있습니다. 그 함수에서,
경적을 울릴 수 있습니다. 이제 그 차량 블루프린트의 자손이 둘 있는데, 하나는 경찰차고 하나는 소방차입니다. 경찰차에서는 그 함수를 덮어써서 사이렌을 울리고 경광등을 켤 수 있습니다.
소방차에서는 물뿌리기를 시작할 수 있습니다. 그러한 종류의 함수성 덮어쓰기가 매크로에서는 불가능합니다.
-	매크로는 컴파일 시간에 그래프에 복사해서 붙여넣는 것일 뿐이기에, 입출력 실행선이 여럿인 매크로가 가능합니다. 함수에서는 불가능합니다.

일반적으로 좋은 경험법칙이라면, 모든 곳에 재사용하려는 간단한 함수성이 있다면, 매크로를 사용합니다. 하지만 블루프린트 자손에서 작동방식을 약간 수정할 수도 있겠거나,
다른 블루프린트에서 직접 접근할수도 있겠다 싶으면 함수를 쓰는 편이 좋습니다!

**추가 자료:**
* [](Engine\Blueprints\UserGuide\Functions)
* [](Engine\Blueprints\UserGuide\Macros)

## 블루프린트 통신 유형

두 블루프린트 사이의 통신 방법은 여러가지 있습니다. 가장 흔히 쓰이는 방식은 직접 블루프린트 통신이나, 가끔은 이벤트 디스패처 또는 블루프린트 인터페이스를 
사용해야 할 수도 있습니다. 각 통신 유형에 대한 개요와 약간의 예제 및 시작을 돕는 튜토리얼은 [](Engine\Blueprints\UserGuide\BlueprintCommsUsage) 문서를 참고하세요. 
세 가지 유형을 모두 사용하는 프로젝트를 만들려면, [](Engine/Blueprints/HowTo) 문서를 참고하세요.



## 일반 팁

### 블루프린트 에디터에서 작업하기

블루프린트 에디터에서 작업할 때, 이미 만들어 둔 노드나 코멘트를 포함해서 사용하고자 하는 노드를 찾을 때 쓸 수 있는 팁이 몇 가지 있습니다.

* 기존 블루프린트에서 변수, 함수, 코멘트같은 것을 찾을 때는 블루프린트의 **검색** 버튼을 사용하세요. 
**Find in Current Blueprint Only** (현재 블루프린트에서만 검색) 박스를 체크하지 않은 이상, 로드되지 않은 것까지 포함해서 모든 블루프린트를 대상으로 검색하므로, 뭘 어디에 구현했는지 쉽게 추적할 수 있습니다.
	
	![](SearchResults.png)

* 컨텍스트 메뉴에는 끌어놓은 핀에 연결할 수 있는 노드만 표시됩니다 (예를 들어 라이트에서 끌어놓으면, 그 라이트에 연관된 함수만 표시됩니다).
변수나 컴포넌트에 대해 가능한 모든 함수성을 전부 알아보고자 하는 경우, 그냥 컨텍스트 메뉴를 한 번 쭉 훑어보면 됩니다.

	![](ContextMenu.png)

* 컨텍스트 메뉴 또는 팔레트가 아닌 경우, 검색창이 매우 유용합니다. 함수에 여러가지 키워드 태그를 붙여놔서, 실제 이름을 몰라도 쉽게 찾을 수 있습니다.

	![](search_rotate.png)

### 그래프 구성하기

모두가 각자의 구성 방식이 있게 마련이지만, 알아보기 쉽고 체계 정리에 도움이 되는 팁 몇가지는 이렇습니다:

* 처음부터 깔끔한 정리상태를 유지하세요! 지저분해진 다음에 정리하는 것이 훨씬 어렵습니다.
* 그래프에서 같은 노드 세트를 두 번 이상 사용한 경우, 재사용할 수 있도록 함수나 매크로로 만들어 보세요.
* 컨텍스트상 비슷한 노드끼리 뭉쳐놓는 것이 공간적으로 깔끔해보이고 좋습니다. 예를 들어 라이트로의 레퍼런스가 있는데, 그 포인트 라이트 컴포넌트를 접근하는 경우,
그 두 노드를 서로 겹쳐두고 하나의 블록으로 생각하는 것도 좋습니다.

	![](stackednodes.png)
* [코멘트](Engine\Blueprints\UserGuide\Comments) 를 자주 사용하세요! 또한, 코멘트 박스 색을 바꿀 수 있다는 것 잊지 마세요! 그래프 구역을 파악하는 데 큰 도움이 됩니다.

