INTSourceChangelist:3244370
Availability:Public
Title: ブループリント コンパイラの概要
Crumbs: %ROOT%, Programming, Engine/Blueprints/TechnicalGuide
Description:ブループリントのコンパイル手順
version:4.9
tags:Blueprints

[TOC(start:2 end:2)]

一般的な C++ クラスと同様に、ブループリントはゲーム内で使用する前にコンパイルする必要があります。**ブループリント エディタ** で、 
**[Compile (コンパイル)]** ボタンを押すと、**Blueprint** アセットのプロパティとグラフをクラスに変換するプロセスが 
行われます。

## 専門用語

$ FKismetCompilerContext :コンパイルを処理するクラスです。新しいインスタンスは、コンパイルするとスポーンされます。コンパイル中のクラスやブループリントなどに関する参照を格納します。

$ FKismetFunctionContext :関連するグラフ、プロパティ、生成した UFunction など、単一関数をコンパイルするための情報を保持します。

$ FNodeHandlingFunctor :コンパイラでノードのクラスを 1 つだけ処理するヘルパークラスです (シングルトンパターン)。ピン接続を登録しコンパイル ステートメントを生成する関数を格納します。

$ FKismetCompiledStatement :コンパイラの作業単位です。コンパイラは、ノードを一連のコンパイル済みのステートメントへ変換します。つまり、バックエンドをバイトコード操作へ変換します。

	**例：**  変数の割り当て、移動、呼び出し

$ FKismetTerm :グラフのターミナルです (リテラル、定数、または参照変数)。データピン接続はそれぞれ、これらのいずれかに関連付いています！Scratch の変数、中間結果など、NodeHandlingFunctor に独自のターミナルを作成することも出来ます。


## コンパイル プロセス

ブループリントをコンパイルする基本プロセスについて以下で説明します。

[REGION:caption]
(アイテムをクリックして表示)
[/REGION]
[REGION:flowlist]
* [REGION:listitem][クラスの整理](#クラスの整理)[/REGION]
* [REGION:listitem][クラスプロパティの作成](#クラスプロパティの作成)[/REGION]
* [REGION:listitem][関数グラフの処理](#関数グラフの処理)[/REGION]
* [REGION:listitem][クラスのバインドおよびリンク](#クラスのバインドおよびリンク)[/REGION]
* [REGION:listitem special][関数のコンパイル](#関数のコンパイル)[/REGION]
* [REGION:listitem][クラスのコンパイルの完了](#クラスのコンパイルの完了)[/REGION]
* [REGION:listitem special][バックエンドによる生成コードの吐き出し](#バックエンドによる生成コードの吐き出し)[/REGION]
* [REGION:listitem][クラスのデフォルト オブジェクト プロパティのコピー](#クラスのデフォルトオブジェクトプロパティのコピー)[/REGION]
* [REGION:listitem][再インスタンス化](#再インスタンス化)[/REGION]
[/REGION]
[REGION:caption clear]
*完全コンパイルのみ
[/REGION]

### クラスの整理

クラスはインプレース (in-place) でコンパイルされます。つまり同じ `UBlueprintGeneratedClass` は整理されて何度も繰り返し使用されます。 
従ってクラスへのポインタを修正する必要がありません。**CleanAndSanitizeClass()** は、 
`CleanAndSanitizeClass()` は、クラスからプロパティと関数を一時パッケージ内のトラッシュクラスへ移動させて、クラスにあるデータをクリアします。

### クラス プロパティの作成

コンパイラは、クラスに必要な UProperty 全てを検索するために、ブループリントの **NewVariables** 配列およびその他の場所 (コンストラクション・スクリプトなど) をイタレートします。 
その後、関数 **CreateClassVariablesFromBlueprint()** の UClass のスコープ上に 
 UProperties が作成されます。

### 関数リストの作成

コンパイラは、イベント グラフを処理し、通常の関数グラフを処理し、関数を _プリコンパイル_ する、つまり各コンテキストに対して **PrecompileFunction()** を呼び出すことによって、 
クラスの関数リストを作成します。

#### イベント グラフの処理

イベント グラフの処理は、**CreateAndProcessUberGraph()** 関数によって行われます。従って、 
全てのイベントグラフを 1 つの大きなグラフへコピーします。その後、ノードの拡張が可能になります。続いてグラフ内の各イベント ノードに対して関数スタブが作成され、 
各イベント グラフに対して **FKismetFunctionContext** が作成されます

#### 関数グラフの処理

通常の関数グラフの処理は、**ProcessOneFunctionGraph()** 関数によって行われます。 
これは、各グラフを一時グラフに複製し、そこでノードが拡張可能になります。各関数グラフに対して  
**FKismetFunctionContext** も作成されます。

#### 関数のプリコンパイル

関数のプリコンパイルは、各コンテキストの **PrecompileFunction()** によって処理されます。この関数は、 
以下のアクションを行います。

* 実行をスケジュールしてデータ依存関係を計算します。
* スケジュール外または非データ依存のノードを取り除きます。
* ノードハンドラ―の **RegisterNets()** を残りのノードそれぞれで実行します。
* これにより 関数内の値に **FKismetTerms** を作成します。
* **UFunction** と関連プロパティを作成します。


### クラスのバインドおよびリンク

コンパイラがクラスに対する UProperties と UFunctions を認識したので、コンパイラはクラスをバインドおよびリンクすることができます。 
これには、プロパティ チェーン、プロパティ サイズ、関数マップなどを書き込むことを伴います。この時点で、 
基本的にクラスヘッダがありますが、最終的なフラグとメタデータおよびクラスのデフォルト オブジェクト (CDO) がありません。

### 関数のコンパイル

残りのノードのために **FKismetCompiledStatment** オブジェクトを生成します。 
**AppendStatementForNode()** を使用して、ノードハンドラ―の **Compile()** 関数を用いて実現しました従って、 
ローカルでの使用に限り、コンパイル関数で **FKismetTerm** オブジェクトを作成します。

### クラスのコンパイルの完了

クラスのコンパイルを終了するために、コンパイラはクラスのフラグを確定し、親クラスからフラグとメタデータを伝搬してから、 
コンパイルが問題なく終了したことを確認するために、いくつかの最終チェックを実行します。

### バックエンドによる生成コードの吐き出し

バックエンドはステートメントのコレクションを各関数コンテキストからコードへ変換します。以下の 2 種類の 
バックエンドを使用します。

* **FKismetCompilerVMBackend** - FKCS をアンリアル・スクリプトの VM バイトコードへ変換します。これはその後、関数のスクリプト配列でシリアル化されます。
* **FKismetCppBackend** - デバッグ作業限定で _C++_ のようなコードを吐き出します。

### クラスのデフォルト オブジェクト プロパティのコピー

特殊な関数、**CopyPropertiesForUnrelatedObjects()** を使用して、コンパイラは 
古い CDO からの値を新しい CDO にコピーします。プロパティは、シリアル化をタグ付けしてコピーされるため、 
名前が統一されている限り、正確に転送されます。CDO のコンポーネントは再インスタンス化されて 
この段階で的確に修正されます。GeneratedClass CDO は信頼できる CDO です。

### 再インスタンス化

クラスのサイズ変更やプロパティが追加または削除された可能性があるため、コンパイラは 
コンパイルしたばかりのクラスですべてのオブジェクトを再インスタンス化する必要があります。このプロセスでは、**TObjectIterator** を使用してクラスのすべてのインスタンスを検索し、 
新しいインスタンスをスポーンした後に、 
**CopyPropertiesForUnrelatedObjects()** を使用して旧インスタンスから新インスタンスにコピーします。

詳細は、**FBlueprintCompileReinstancer** クラスを参照してください 
