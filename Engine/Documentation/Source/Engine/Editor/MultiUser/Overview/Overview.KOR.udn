INTSourceChangelist:6409500
Availability: Public
Title: 멀티 유저 편집 개요
Description: Multi-User Editing 시스템 작동 방식에 대한 개념 개요입니다.
Type: overview
Version: 4.22
Parent: Engine/Editor/MultiUser
Tags: Getting Started
Tags: Early Access
Tags: Multi-User Editing
topic-image: multiuserediting-workflow-topic.png
Order: 0
hero-image:multiuserediting-workflow-banner.png

Multi-User Editing (멀티 유저 편집) 워크플로는 하나의 *서버* 가 다수의 *세션* 을 호스팅하는 클라이언트-서버 모델을 기반으로 만들어졌습니다. 각 세션은 동일한 네트워크상의 모든 언리얼 에디터 인스턴스가 공유 환경 내에서 동일한 프로젝트 콘텐츠를 공동 작업하기 위해 연결할 수 있는 별도의 가상 작업 공간입니다.

![Multi-User Editing network server and clients](multiuser-editing-overview.png "Multi-User Editing network server and clients")

세션 작업 공간 내부에서 각 사용자는 자신의 언리얼 에디터 인스턴스에서 가능한 모든 방법으로 프로젝트 콘텐츠와 상호 작용할 수 있습니다. 예:

*   일부 사용자는 표준 데스크톱 PC 구성에서 키보드 및 마우스를 사용하여 작업 할 수도, 필요에 따라 다른 플랫폼에서도 작업할 수도 있습니다.

*   다른 사용자는 에디터의 VR 편집 모드를 사용해서 VR 헤드셋과 컨트롤러를 사용하여 씬을 시각화하고 작업할 수도 있으며, [Virtual Camera](Engine/Plugins/VirtualCameraPlugin) (가상 카메라)같은 플러그인으로 모바일 디바이스를 사용하여 같은 씬에 들어갈 수도 있습니다.

연결된 사용자가 프로젝트에서 레벨을 변경하거나 애셋을 저장하는 경우, 그 언리얼 에디터 인스턴스는 변경에 대한 정보를 서버로 자동 전달합니다. 서버는 이 모든 변경 레코드, 또는 **transaction** (트랜잭션)을 기록하고, 그 트랜잭션을 다른 모든 연결 클라이언트에 전송하는 작업을 담당합니다. 그러면 각 클라이언트는 동일한 환경 내에서 로컬로 동일한 변경 사항을 적용합니다. 이런 식으로 모든 사람이 프로젝트의 현재 레벨과 다른 애셋 화면이 최신 변경사항이 적용된 상태로 유지됩니다.

## 트랜잭션 동기화

멀티 유저 편집 시스템은 작업 중인 애셋 및 변경사항 유형에 따라 연결된 클라이언트 사이 변경사항을 동기화하는 여러 전략을 선택합니다.

### 레벨: 즉시 동기화

레벨 콘텐츠에 대한 변경사항은 세션의 다른 모든 컴퓨터와 즉시 동기화됩니다. 액터를 추가 또는 제거하거나, 한 곳에서 다른 곳으로 이동하거나, 머티리얼을 교체하거나, 액터의 프로퍼티를 변경하는 경우, 세션의 다른 모든 사용자는 그 변경사항이 즉시 적용되는 것을 확인할 수 있습니다. 툴을 드래그하여 액터를 이동, 회전, 스케일 조절하는 경우 드래그 도중 다수의 트랜잭션을 발생시킵니다. 다른 사용자는 마우스를 떼기도 전에 변경사항을 확인할 수 있습니다.

예를 들어 다음 비디오에서, 왼쪽 사용자가 곳곳의 액터를 드래그하여 변경하면, 오른쪽의 사용자는 마우스를 떼기도 전에 뷰포트에서 그 변경사항이 즉시 반영되는 것을 확인할 수 있습니다. 마찬가지로 오른쪽의 사용자가 오브젝트를 회전하면, 왼쪽의 사용자도 즉시 변경사항이 보입니다.

[OBJECT:EmbeddedVideo]
[PARAMLITERAL:width]
100
[/PARAMLITERAL]
[PARAMLITERAL:height]
56.25
[/PARAMLITERAL]
[PARAMLITERAL:units]
%
[/PARAMLITERAL]
[PARAMLITERAL:type]
simple
[/PARAMLITERAL]
[PARAMLITERAL:videoid]
12Hg4v45CfI
[/PARAMLITERAL]
[/OBJECT]

[REGION:note]
다른 사용자의 변경사항 확인은 같은 에디터 모드에 있을 때만, 즉 둘 다 편집 모드에 있거나, **에디터에서 플레이(PIE)** 또는 **시뮬레이트** 모드에 있는 경우입니다.
[/REGION]

### 다른 애셋: 저장 시 동기화

멀티 유저 편집 시스템은 언리얼 엔진 프로젝트의 대부분의 애셋 유형을 수정할 때마다 즉시 동기화하지 않습니다. 그 애셋 유형에는 머티리얼, 머티리얼 인스턴스, 스태틱 메시 애셋, 블루프린트 클래스 등이 포함됩니다. 이 경우 그 애셋을 수정하면, 그 변경사항이 즉시 확인되는 것은 자기 자신 뿐입니다. 변경사항을 저장하면, 멀티 유저 편집 시스템은 그 트랜잭션을 세션의 다른 모든 사용자에게 전송합니다. 

이 경우 트랜잭션은 단순한 변경사항 레코드가 아닌, 실제 저장된 애셋입니다. 이 업데이트 패키지 중 하나를 받는 에디터 각 인스턴스는 즉시 핫 리로드하여 변경사항을 표시합니다.

예를 들어 다음 비디오에서, 왼쪽 사용자가 머티리얼을 변경해도, 그 변경사항이 즉시 동기화되지 않습니다. 그러나 사용자가 변경사항을 애셋에 저장하면, 트랜잭션을 처리하여 오른쪽의 사용자에게 변경사항이 표시됩니다.

[OBJECT:EmbeddedVideo]
[PARAMLITERAL:width]
100
[/PARAMLITERAL]
[PARAMLITERAL:height]
56.25
[/PARAMLITERAL]
[PARAMLITERAL:units]
%
[/PARAMLITERAL]
[PARAMLITERAL:type]
simple
[/PARAMLITERAL]
[PARAMLITERAL:videoid]
8f1ImAFu4rU
[/PARAMLITERAL]
[/OBJECT]

[REGION:note]
애셋을 저장하면 자동으로 애셋이 잠깁니다. 추가로 일부 애셋 유형에 저장되지 않은 변경사항이 있는 동안, 멀티 유저 편집 시스템은 다른 사용자에 대해 그 애셋을 더디 마킹합니다. 아래 [상충 피하기](#상충 피하기) 부분을 참고하세요.
[/REGION]

### 시퀀서: 재생 동기화 및 선택적 UI 동기화

멀티 유저 편집 시스템은 레벨 시퀀스와 마스터 시퀀스를 레벨처럼 취급하여, 사용자가 레벨에 트랙 추가 또는 제거나 새 키프레임 추가와 같은 변경을 하면, 세션의 다른 모든 사용자에게 즉시 동기화됩니다. 

추가로 한 사용자가 시퀀스를 재생하면, 같은 시퀀스가 열려있는 모든 사용자에 대해 시퀀스가 즉시 재생됩니다. 재생을 시작한 사용자만 재생을 중지할 수 있습니다. 시퀀스 중지 후 모든 사용자가 재생을 재시작할 수 있습니다.

한 명의 사용자가 시퀀서 UI 를 열면 멀티 유저 편집 시스템이 자동으로 열도록 할 수도 있습니다. 시스템은 같은 시퀀스가 열린 모든 사용자에 대해 재생을 동기화하므로, 이 UI 동기화 옵션을 활성화하면 모든 사용자가 동시에 같은 시퀀스를 재생하도록 할 수 있습니다.

다음 비디오는 멀티 유저 편집 시스템이 시퀀서 UI 이벤트, 재생 이벤트, 편집 이벤트를 동기화하는 방법을 보여줍니다.

[OBJECT:EmbeddedVideo]
[PARAMLITERAL:width]
100
[/PARAMLITERAL]
[PARAMLITERAL:height]
56.25
[/PARAMLITERAL]
[PARAMLITERAL:units]
%
[/PARAMLITERAL]
[PARAMLITERAL:type]
simple
[/PARAMLITERAL]
[PARAMLITERAL:videoid]
_RPKUze91n8
[/PARAMLITERAL]
[/OBJECT]

[REGION:note]
위와 같은 시퀀서 UI 동기화를 활성화하는 방법은: `Concert.EnableOpenRemoteSequencer` 콘솔 명령을 사용하면 됩니다. 자세한 내용은 [멀티 유저 편집 기능 레퍼런스](Engine/Editor/MultiUser/Reference) 의 [콘솔 명령](Engine/Editor/MultiUser/Reference#콘솔명령) 부분을 참고하세요.
[/REGION]
[REGION:note]
멀티 유저 편집 시스템은 재생 이벤트를 동기화하지만, 다른 컴퓨터에서 재생되는 애니메이션은 프레임 속도가 다를 수 있습니다. 언리얼 에디터 인스턴스마다 프레임 단위로 정확한 결과물을 기대하지는 마세요.
[/REGION]

## 현재상태

멀티 유저 편집 시스템에서는 세션의 다른 사용자가 하는 작업을 확인하는 방법을 몇 가지 제공합니다.

[REGION:tip]
다음 부분에 설명되는 presense (현재상태) 정보는 표시명과 색을 사용해서 연결된 사용자를 구분합니다. 각 사용자는 **프로젝트 세팅** 의 **Display Name** 및 **Avatar Color** 세팅으로 이 값을 사용자 정의할 수 있습니다. 자세한 내용은 [멀티 유저 편집 기능 레퍼런스](Engine/Editor/MultiUser/Reference#프로젝트세팅) 부분을 참고하세요.
[/REGION]

### 위치 및 뷰포트

다른 사용자와 같은 레벨 작업을 하는 도중, 씬에서 그 위치를 나타내는 아바타와 뷰포트가 보입니다. 씬 상호작용을 하면서, 그 마우스 커서 또는 모션 컨트롤러가 선택한 오브젝트를 나타내는 레이저도 보입니다.

예를 들어, 다음 이미지는 같은 레벨에서 작업하는 두 데스크톱 사용자의 아바타를 보여줍니다.

![Multi-User Editing desktop avatars](multiuserediting-ov-presence-avatars.png "Multi-User Editing desktop avatars")

언제든 **Connected Clients** (연결된 클라이언트) 패널의 컨트롤을 사용하면 이 현재상태 정보를 사용할 수 있습니다. (이 패널은 **Multi-User Session** (멀티 유저 세션) 창과, 현재 서버 이름 및 세션을 선택한 상태에서 **Multi-User Browser** (멀티 유저 브라우저) 창에서도 확인할 수 있습니다.)

![Multi-User Editing Connected Clients panel](multiuserediting-ov-presence-connectedclients.png "Multi-User Editing Connected Clients panel")

| 아이콘 | 설명 |
| --- | --- |
| ![Teleport to user's point of view](multiuserediting-ov-presence-location.png "Teleport to user's point of view") | 이 사용자와 같은 위치 및 시점으로 즉시 순간이동합니다. |
| ![Toggle presence visibility](multiuserediting-ov-presence-visibility.png "Toggle presence visibility") | 이 사용자에 대한 아바타와 레이저 포인터 표시를 토글합니다. |

### 세션 변경 히스토리

**멀티 유저 세션** 창의 목록에 현재 세션에서 발생한 각 편집 트랜잭션, 그리고 사용자가 세션에 연결 및 해제될 때마다 표시됩니다.

![Session change history](multiuserediting-ov-presence-sessionhistory.png "Session change history")

### 애셋 변경 히스토리

각 개별 애셋의 변경사항 목록도 볼 수 있습니다. 콘텐츠 브라우저에서 애셋에 우클릭하고 **Multi-User > Asset History** (멀티 유저 > 애셋 히스토리)** 를 선택합니다. 이 특정 애셋을 수정한 모든 트랜잭션 목록이 나옵니다.

![Asset change history](multiuserediting-ov-presence-assethistory.png "Asset change history")

## 상충 피하기

동시에 여러 사람이 같은 콘텐츠 작업을 하게 되면, 결국 동시에 같은 것을 변경 시도하게 됩니다. 권한 설정에 너무 관대하면, 사람들이 제어권을 놓고 싸우거나 변경사항을 잃어 버려 좌절감을 느낄 수 있습니다. 반면 너무 엄격하면, 사람들이 무언가 필요할 때 수정할 수 있는 능력이 줄어 작업 속도가 저하되거나 완전 막힐 수도 있습니다.

멀티 유저 편집 시스템은 이 양 극단 사이 균형을 찾아 사용자 사이 자주 발생할 수 있는 분쟁 및 덮어쓰기 문제를 방지합니다.

### 드래그 선택 잠금

레벨 뷰포트에서 선택을 실제로 드래하는 도중, 예를 들어 이동, 회전, 스케일 조절할 때는 해당 액터를 독점 제어합니다. 이 상태에서는 다른 사용자가 **레벨 뷰포트** 에서 툴을 드래그하든 **디테일** 패널에서 프로퍼티를 설정하든 같은 액터를 수정하려고 하면 변경사항이 반영되지 않습니다.

처음 사용자가 드래그 동작을 중단하면, 여전히 선택한 상태라도 다른 사용자가 그 액터 작업을 다시 시작할 수 있습니다.

### 애셋 잠금

다른 사용자가 특정 애셋을 수정하지 못하게 하려는 경우, 잠그면 됩니다. 애셋이 잠긴 동안에는 잠근 사용자만 새 수정사항을 저장할 수 있습니다. 다른 사용자도 자신의 로컬 프로젝트에서 잠긴 애셋을 수정할 수 있지만, 그 소유자가 해제할 때까지 수정을 저장할 수는 없습니다.

잠기고 수정된 애셋은 **콘텐츠 브라우저** 에서 애셋의 섬네일에 오버레이 표시로 알 수 있습니다. 애셋에 커서를 올리면 잠근 소유자와 애셋을 수정한 사람 세부 정보가 표시됩니다.

![Asset locks and dirty flag](multiuserediting-assetlocking.png "Asset locks and dirty flag")

| 오버레이 | 설명 |
| --- | --- |
| ![Locked by you](icon_ConcertMyLock_16x.png "Locked by you") | 초록은 자신이 애셋을 잠갔음을 나타냅니다. 언제든 계속 수정할 수 있습니다. 다른 사용자는 잠금 해제할 때까지 애셋을 수정할 수 없습니다. |
| ![Locked by someone else](icon_ConcertOtherLock_16x.png "Locked by someone else") | 주황은 다른 사용자가 이 애셋을 잠갔음을 나타냅니다. 로컬 프로젝트에서 수정할 수는 있지만, 잠근 소유자가 해제할 때까지 수정 사항을 저장하고 다른 사용자와 동기화할 수 없습니다. |
| ![Modified but unsaved on another computer](icon_ConcertModifiedByOther_16x.png "Modified but unsaved on another computer") | [INCLUDE:#excerpt_0] |

<!--
[EXCERPT:excerpt_0]
주황 별표는 애셋이 다른 컴퓨터에서 더티(수정되었지만 저장되지는 않은) 상태가 되었음을 나타냅니다.  
[REGION:note]
선택된 애셋 유형만 이 아이콘으로 마킹됩니다. 이 상태의 애셋을 수정할 때는 주의하세요. 파일이 잠겼을 때 처음 저장된 변경사항만 다른 모든 클라이언트에 전파되어, 다른 이의 변경사항을 잃을 수 있습니다.
[/REGION]
[/EXCERPT:excerpt_0]
-->

애셋을 잠그거나 해제하려면, **콘텐츠 브라우저** 에서 우클릭하고 **Multi-User > Lock Asset(s)** (멀티 유저 > 애셋 잠금) 또는 **Multi-User > Unlock Asset(s)** (멀티 유저 > 애셋 잠금해제)를 선택하면 됩니다.

![Lock and unlock Assets](multiuserediting-assetlocking-menu.png "Lock and unlock Assets")

[REGION:tip]
잠금해제된 애셋에 수정사항을 저장할 때마다, 멀티 유저 편집 시스템은 다시 수정할 것이라는 가정 하에 자동으로 잠급니다. 다른 사용자가 애셋을 수정할 수 있도록 잠금해제하려면, 수동으로 해야 합니다.
[/REGION]

### 실행 취소 및 다시 실행

연결된 각 사용자는 자신의 작업 히스토리에만 액세스할 수 있습니다. 그 히스토리 안에서 각 사용자는 마치 세션 일부가 아닌 오프라인 작업인 것처럼 동작을 자유롭게 실행 취소 또는 다시 실행할 수 있습니다. 그러나 다른 사용자가 수행한 작업을 실행 취소 또는 다시 실행할 수는 없습니다.

## 일반 상태에서 시작

긴 지연시간과 높은 대역폭 사용량을 피하기 위해, 멀티 유저 편집 시스템의 서버는 연결된 사용자 사이 프로젝트 전체 콘텐츠를 전송하지 않습니다. 대신, 즉시 동기화가 필요하면 경량 트랜잭션 레코드 교환에 의존하고, 레벨, 스태틱 메시, 블루프린트 등의 애셋은 세션 진행 도중 수정 및 저장된 경우에만 순환시킵니다.

들어오는 트랜잭션이 연결된 모든 사용자에 대해 똑같은 방식으로 적용되고 그에 따라 모든 사용자의 콘텐츠가 다른 모든 사용자의 콘텐츠와 동기화되도록하는 유일한 방법은, 모든 연결된 사용자가 똑같은 콘텐츠 똑같은 상태에서 시작하도록 하는 것입니다. 이렇게하면 같은 순서로 각 클라이언트에 동일한 트랜잭션 목록이 적용되므로 각 사용자의 콘텐츠 전체 상태가 동기화된 상태로 유지됩니다.

모든 사용자가 동일한 컨텐츠로 시작하게 하는 일반적인 방법은 Perforce, Git, 또는 SVN 과 같은 소스 컨트롤 시스템을 사용하고 각 사용자가 이전의 다른 사용자와 동일한 변경 목록 또는 리비전에 로컬 사본을 동기화한 뒤 세션에 같이 연결하는 것입니다. 아래 [멀티 유저 편집 및 소스 컨트롤](#멀티유저편집및소스컨트롤) 부분을 참고하세요.

소스 컨트롤 사용이 필수는 아니며, 외부 소스 컨트롤 시스템 없이도 멀티 유저 편집 기능을 사용할 수는 있습니다. 그러나 그 경우 공동 작업할 모든 사용자가 안정적으로 똑같은 프로젝트 콘텐츠로 시작할 수 있도록 프로젝트 콘텐츠를 공유하는 방법을 직접 찾아야 합니다.

### 세션 유효성 검사

사용자가 세션에 연결을 시도할 때마다, 서버는 콘텐츠와 작업 환경의 특성을 통해 세션 초기 시작에 사용된 콘텐츠가 일치하는지 확인합니다. 이 검사 중 하나라도 실패하면, 서버는 사용자가 세션에 참여하는 것을 허용하지 않습니다.

*   **UE4 버전** - 서버는 세션에 접속하려는 사용자가 시작한 사용자와 같은 언리얼 엔진 버전을 사용하는지 검사합니다. 예를 들어 세션을 시작한 사용자가 4.22, 다른 사용자가 4.23 으로 연결하려는 경우, 서버는 연결을 허용하지 않습니다. 이렇게 하면 서로 다른 버전 간에 애셋 포맷이 변경되어 발생하는 문제를 방지할 수 있습니다.

*   **프로젝트 이름** - 서버는 세션에 참가하려는 사용자가 열어둔 프로젝트 이름이 세션을 만들 때 사용한 프로젝트 이름과 일치하는지 검사합니다. 이 검사가 실패하면, 서버는 두 프로젝트의 콘텐츠가 같을 수 없다 가정하고 연결을 거부합니다.  
    ![Failure to connect - invalid Project name](multiuserediting-ov-projectname.png "Failure to connect - invalid Project name")

*   **소스 컨트롤 리비전** - 세션을 시작한 사용자가 언리얼 에디터에서 소스 컨트롤 제공사에 연결된 경우, 서버는 프로젝트의 changelist 또는 revision 을 세션과 연관시킵니다. 소스 컨트롤 제공사가 활성화된 다른 사용자가 그 세션에 연결을 시도하면, 서버는 그 changelist 또는 revision 이 세션에 연관된 것과 일치하는지 검사합니다. 

*   **로컬 수정 파일** - 소스 컨트롤 제공사에 연결되어 있고 로컬 수정된 파일이 있는 경우, 서버는 새 세션을 만들거나 기존 세션에 참여하지 못하도록 합니다. 사용자마다 changelist 는 같지만 특정 애셋 버전이 달라질 수 있는 가능성을 방지합니다.  
    ![Failure to connect - locally modified files](multiuserediting-ov-locallymodified.png "Failure to connect - locally modified files")

## 트랜잭션 및 변경사항 지속

자신과 팀원이 라이브 세션에서 작업할 때, 에디터는 로컬 프로젝트 콘텐츠 위에 일종의 가상 샌드박스 형태로 트랜잭션을 적용합니다. 디스크의 프로젝트 파일은 세션에 남아있는 한 전혀 실제 수정되지 않습니다. 멀티 유저 편집 시스템은 변경사항 기록을 유지하고, 그 트랜잭션을 프로젝트 콘텐츠에 적용한 결과를 언리얼 에디터에 보여줍니다.  

언제 어느 세션 참여자가 세션 변경사항을 **persist** (지속)하도록 선택하면, 현재 세션에 이루어진 모든 수정 사항을 디스크의 로컬 파일에 적용합니다. 소스 컨트롤 제공사에 연결된 상태에서 세션을 시작했다면, 선택적으로 같은 변경사항을 새로운 changelist 또는 revision 에 체크인 할 수도 있습니다.  

![Persist Session Changes from the Toolbar](multiuserediting-ov-persist.png "Persist Session Changes from the Toolbar")

변경사항을 지속시키지 않고 세션을 나가면, 에디터는 세션 시작 또는 참여 이전 상태로 프로젝트를 자동 되돌립니다. 세션에서 수정한 내용을 버리고 프로젝트의 모든 애셋을 핫 리로드합니다. 세션을 나가면 세션 변경사항이 더이상 보이지 않지만, 트랜잭션을 완전히 잃은 것은 아닙니다. 각 세션은 모든 사용자가 나간 후에도 모든 트랜잭션 기록을 유지합니다. 나중에 같은 세션에 다시 참여하면, 멀티 유저 편집 시스템은 그 모든 트랜잭션을 그대로 에디터에 재적용합니다.

### 중복성

서버는 세션을 생성한 사용자가 명시적으로 삭제할 때까지, 또는 서버 자체가 종료될 때까지 각 세션을 유지합니다. 그래서 개별 클라이언트의 크래시나 연결 해제가, 심지어 모든 클라이언트에 발생해도 절대 수정 사항을 잃지 않습니다. 서버에 다시 연결하면 나갔던 상태 그대로 이어집니다.

서버는 세션 레코드를 디스크에 저장하므로 예상치 못한 종료로 인해 정보가 손실되는 것도 방지합니다.

*   서버가 비정상 종료되면, 다음 번 서버를 재시작할 때 모든 세션을 그 상태 그대로 즉시 복원합니다.

*   서버를 완전히 종료하면 열려있는 모든 세션이 삭제됩니다. 그러나 서버에서 세 세션을 저장하도록 했다면, 나중에 복원할 수 있을 것입니다. 자세한 내용은 다음 부분을 참고하세요.

### 세션 저장 및 복원

새 세션을 만들기 전, 나중에 지금 이 세션을 그만 둔 지점에서 재시작할 수 있도록 하려면, 멀티 유저 편집 서버에서 세션 트랜잭션 레코드에 이름을 붙여 저장하면 됩니다.

세션 레코드를 저장하려면, 새 세션을 만들 때 **세션 생성** 창의 **세션을 다른 이름으로 저정** 박스를 체크합니다. 그 이름은 **세션 이름** 박스에 입력한 이름으로 기본 설정되지만, 다른 값으로 덮어쓸 수 있습니다.

![Save Session As](multiuserediting-ov-savesession.png "Save Session As")

서버에서 세션을 삭제하거나 서버를 정상 종료한 이후, 더이상 **세션 브라우저** 창에 원래 세션이 나열되지 않으므로, 복원하기 전까지는 연결할 수 없습니다.

세션을 복원하려면, 새 세션을 처음부터 시작하는 것과 마찬가지로 **세션 생성** 창을 엽니다. 그러나 이번에는 **복원할 세션** 박스를 체크하고, 목록에서 복원하려는 세션 이름을 선택합니다.

![Restore a saved session](multiuserediting-ov-restoresession.png "Restore a saved session")

[REGION:note]
기존 세션에 참여할 때와 마찬가지로 세션을 복원 할 때도 디스크의 프로젝트 내용이 세션이 처음 생성 된 시점의 프로젝트 내용과 일치해야 합니다.
[/REGION]

서버가 세션 레코드를 저장하는 위치는 언리얼 엔진 설치 폴더 아래 `Engine/Programs/UnrealMultiUserServer/Saved/Concert` 입니다. 저장된 세션을 절대 복원할 수 없도록 완전히 삭제하려면, 이 위치의 폴더를 삭제하면 됩니다.

## 멀티 유저 편집 및 소스 컨트롤

멀티 유저 편집 시스템에는 소스 컨트롤 시스템과 비슷한 기능이 몇 가제 제공됩니다. 예로 트랜잭션 히스토리를 저장하는 서버, 경쟁 감소를 위해 사용자가 애셋을 잠그는 기능 등입니다. 그러나 **멀티 유저 편집 기능이 소스 컨트롤을 대체하는 것은 아닙니다**.

멀티 유저 편집 기능은 Perforce, SVN, 또는 Git 처럼 일반적으로 변경사항을 프로젝트에 기록하는 전용 소스 컨트롤 시스템을 통한 표준 협업 워크플로를 보완하는 데 가장 적합합니다.

[REGION:tip]
Perforce 를 사용하는 경우, UnrealGameSync (UGS) 를 사용하면 이 프로세스가 한결 쉬워집니다. 자세한 내용은 [UGS 문서](Programming/Deployment/UnrealGameSync) 를 참고하세요.
[/REGION]

팀에서 사용하는 버전 컨트롤 시스템이 있는 경우, 멀티 유저 편집 기능은 특정한 changelist 위에 한정 시간 라이브 협업 환경으로 사용하세요.

*   각 라이브 세션 (촬영, 하루 작업, 검토 회의, 또는 팀과 같이 하는 모든 작업) 시작 시, 모든 참여자는 시작할 (보통 최신) changelist 를 결정하고 동기화합니다.

*   라이브 세션이 끝나면, 한 사람이 그 변경사항을 팀의 일반적인 소스 컨트롤 시스템에 제출하여 보존합니다.

*   세션의 변경사항을 소스 컨트롤에 제출한 이후, 세션은 더이상 필요치 않으니 삭제해도 됩니다.

*   다음 번 라이브로 이동해야 하는 경우, 최신 changelist 기반으로 새 세션을 시작합니다.

오랜 기간, 즉 며칠 또는 몇 주 동안 하나의 멀티 유저 편집 세션을 계속 사용하지 않는 것이 좋습니다. 끊어서 변경사항을 정기적으로 소스 컨트롤에 제출하세요.

[REGION:note]
언리얼 에디터 UI 를 소스 컨트롤 제공사와 연결하는 데 대한 정보는 [언리얼 엔진 4 의 협업](Engine/Basics/SourceControl) 및 [소스 컨트롤](Engine/UI/SourceControl) 문서를 참고하세요.
[/REGION]

## 네트워킹

라이브로 이동하면, 언리얼 에디터 인스턴스는 선택한 서버로 연결할 때 UDP 포트 **6666** 을 사용합니다.

*   서버에 연결하기 위해 언리얼 엔진을 실행하는 각 컴퓨터는 해당 서버 컴퓨터의 개이 ㄴIP 주소를 볼 수 있어야 합니다.

*   서버의 컴퓨터는 로컬 네트워크에서 오는 UDP 트래픽 **6666** 포트가 열려 있어야 합니다.

[REGION:note]
이 연결 방식은 하나의 LAN 안에 있거나, 또는 두 종점이 같은 VPN 안에 있어야 합니다. 개방형 인터넷 연결을 통해 언리얼 에디터 세션을 공유하려는 기대는 하지 **마세요**.
[/REGION]
[REGION:tip]
시작하기 페이지의 안내면 간단한 LAN 환경에서의 실행 구성은 충분할 것입니다. 클라이언트와 서버 사이 연결을 설정하는 데 어려움이 있으면, 언리얼 에디터 인스턴스 및 서버에 대한 UDP 메시징 세팅을 조정해야 할 수 있습니다. [고급 네트워킹](Engine/Editor/MultiUser/Reference#고급네트워킹) 부분을 참고하세요.
[/REGION]
