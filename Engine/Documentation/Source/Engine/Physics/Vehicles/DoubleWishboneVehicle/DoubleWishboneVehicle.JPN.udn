INTSourceChangelist:2713167
Availability:Public
Title:ダブルウィッシュボーン式サスペンション ビークルのビルド方法
Crumbs: %ROOT%, Engine, Engine/Physics
Description:アンリアル エンジン 4 を使ってダブルウィッシュボーン式サスペンション ビークルをビルドする方法
Navigation:topic
SkillLevel:Advanced
Version:4.9

[TOC (start:2)]

## はじめに

本プロジェクトおよびチュートリアルは、コミュニティ メンバーの Xenome 氏の提供であり、ご本人の許可を得て掲載しております。

Xenome 氏に感謝いたします。

_________________________

このチュートリアルでは、高度なビークル テンプレートの詳細を紹介します。チュートリアルを一通り完了すると、理論的な仕組みや、似ているテンプレートのビルトや設定方法について、かなり理解できるようになっています。チュートリアルはサスペンションを中心に進めていきます。

ビークル テンプレートで使用しているすべての FBX アセットは **[こちら](DoubleWishboneVehicle_Files.zip)** からダウンロードできます。FBX ファイルの読み書きが可能なモデリング パッケージであれば、オリジナルと体験版を自分のデザインで分析することができるはずです。

ダブルウィッシュボーン式サスペンション ビークルの設定は、標準のアンリアル エンジン 4 のビークルに比べてかなり複雑です。まだ未完了の設定がある場合は、そちらを完了しておくことを強くお勧めします。Epic は YouTube で標準的な手順を大変わかりやすいビデオでご紹介しています。**[リンクはこちら](https://wiki.unrealengine.com/Introduction_to_Vehicles_in_UE4_Playlist)**。

このビデオをみて基本となるビークルの設定が無事完了したら、本題のダブルウィッシュボーン式サスペンション ビークルに取りかりましょう。まずは、基本的な理論から説明します。

## シュミレートされた車輪と本物のサスペンションのリンケージ

ビークル移動コンポーネントを設定し、それに車輪を割り当てると、車輪の垂直の移動がビークルの Animation ブループリント内の WheelHandler ノードに反映されます。ハンドラは各フレーム上でローカルの Z 軸に平行にホイールを上下移動させてサスペンションのシミュレーションを行い、可能な時はいつでも車輪がグラウンドに触れることを確かめます。

さらに **WheelHandler** は、シュミレーションしたモーターとギアボックスの回転速度で車輪が Y 軸周りでスピンするように回転も適用します。この他に、現在のステアリングを操作し、車輪を Z 軸の周りで回転させます。

デフォルトの垂直なサスペンションの移動は、**VehicleWheel** で操作されるクラス内の **[Suspension Max Raise]** 設定と **[Drop]** 設定でクランプされます。この移動は、以下のように、完全に線形です。

![](simwheeldefaultmovement.gif)(convert:false)

_WheelHandler によって作成される標準的な垂直移動_

サスペンション アームまたはスプリングやショックなどの他のコンポーネントを通常は見えない部分なので、このタイプのサスペンションのシミュレーションは完全にリアルでなくても実はほとんどのビークルに適しています。ボディ全体のカー モデルであれば、通常はうまく処理できます。

ただし、移動部品がむき出しになっているバギーやフォーミュラー 1 カーなどのオープン型のビークルの場合、この移動が問題になります。なぜなら、このタイプの移動を生み出す実用的なサスペンション設計が現実の世界には存在しないからです。

より現実的な結果を出すには、ビークルのボディに固定された回転軸に沿って回転するタイプのモーションが必要です。

![](realwheelmovement.gif)(convert:false)

_理想的な垂直および横方向の移動_

この難題を解決するために、まずはホイールを次の 2 種類に想定して見てみましょう。1 つ目は WheelHandler ノードによってシミュレーションされる Wheel ノード、2 つ目は車を運転する時に実際のレンダリングを見ることができる車輪です。その後で、希望する結果を出すために WheelHandler からのデータを残りのサスペンション設定へ送ることができます。

つまり、表示される車輪とシミュレーションされた車輪は実は全く別の 2 つオブジェクトであり、後者は全く表示しなくてもよいのです。

VehicleWheel クラスで定義した Wheel パラメータで、**コリジョン メッシュ**、**半径** と **幅** を明示的に指定することができます。これらの指定は、ビークルのスケルタル メッシュ内の実際のジオメトリと必ずしも一致する必要はないので、メッシュ内でシミュレートされた車輪のノードは実際のジオメトリの適用には全く必要ないのです。さらに、ビークルのブループリントの車輪設定セクションで、車輪のオフセットを追加できます。従って、車輪の回転軸を表示されている車輪メッシュのジオメトリの中心とそろえる必要はありません。

メカニカルな視点から本当に動くようなサスペンションをビルドする必要があるというのが、基本的な見解です。

## Skeletal ノードの機能

さてここで、設定時に特に便利な 2 つの Animation ブループリントノードについて説明しなければなりません。さきほど説明した WheelHandler ノードは絶対に使うのですが、このタイプのリギングに非常に重要で強力なツールがあと 2 つあります。それは **CopyBone** と **LookAt** ノードです。両方ともアニメーション ブループリントの Skeletal Control カテゴリに存在し、標準位置、回転、エイム コンストレイントは基本的に Maya のようなアプリケーションで実行されるので、 2 つともほぼ同じタスクを実行します。

### Copy Bone ノード

名前の通り、 CopyBone ノードは、あるボーン (ソース) のトランスフォーム データを別のボーン (ターゲット) にコピーすることができます。

![](node_copybone.png)

_CopyBone animation Blueprint ノードおよびデフォルト設定_

つまり、WheelHandler がシミュレーションした車輪のをトランスフォーム情報を更新すると、例えば作成された回転値のみを取得し、表示中の車輪に適用することができます。この基本的なステップでは、是非とも使いたい車輪のスピンとステアリングを処理し、必要のないトランスレーション (位置) データを取得しないようにします。

### Look At ノード

LookAt ノードは、基本軸の 1 つが別のボーンの方を向くように、任意のボーンを回転させます。

![](node_lookat.png)

_LookAt animation Blueprint ノードとデフォルト設定_

シミュレーションした車輪の現在位置で、直接または間接操作されるサスペンション メカニズムのすべてのコンポーネントが正しい方向のポイントへ常に更新されていることを確認できるので、設定の際に便利です。LookAt ノードで向きを変えることができるボーンがあることを確認しておきます。このノードはアニメーション ブループリントのいくつかのボーンに使用します。

## 実装の概要

要点をまとめると、4 つの車輪それぞれに対して、管理用に非表示の車輪を 1 つ使い、ゲームでの実際のレンダリング用に表示された車輪を 1 つ使います。非表示の車輪はメッシュのウェイト付けがない単一のボーン / ジョイントです。後者はモデリング パッケージでビルドしてからビークル モデルに追加した車輪の形をしたメッシュで、 UE4 の最終的な設定にインポートされます。

すべてが目的どおりに機能するように、サスペンションの主要パーツが必要なトランスフォーム データを他のボーンからコピーする、あついはモデルで設定したターゲットの方を向かせて方向を調整します。

## モデルの作成

理論はこのくらいにして、デモで使われているビークルの作成方法を見てみましょう。メインのモデリング アプリケーションで Assets/FBX/vehicle_proto_S2.9.fbx を開くと分解図が表示され、すべての部品の組み合わさり方が分かります。

このチュートリアル用に作成したビークルのサスペンション リグは、このような設計になっています。

![](keycomponents.png)

_プロトタイプ ビークルのフロントの右側のサスペンションを拡大してみます。この図では分かりやすいように色をつけてありますが、FBX ファイルのマテリアルには色はついていません。_

ここでキーとなるコンポーネントは、上腕と前腕 (黄色) 、キングピン (赤) 、ハブ (青) です。それぞれの六角ボルトの周りのアーム軸は、画像のかなり右に表示されています。

ロワアーム上の緑のボルトに近くが、すべてが集まる中心点です。まずここに、シミュレーションしたジョイントである `PhysWheel_[loc]` を配置します。キングピン、ハブ、表示された車輪にも、全く同じ位置に軸があります。

これらの各コンポーネントには、非常に厳格な責任とトランスフォーム範囲があります。アームは前方軸に沿った回転のみです。キングピンはロワアームの先端位置を追いますが、終始垂直に保たれ、ビークルにつられて動くことはありません。ハブは、ステアリングに反応して、垂直軸周りの回転のみです。表示された車輪はシミュレーションした車輪の回転をコピーして、ロワアームの先端からその位置を受け取ります。こうすると、全体がしっかりロックされた状態になります。

かなり複雑なリグの場合、階層を保ち順序を更新することがとても重要だと覚えておいてください。このケースは特殊で、ロワアームが回転する時、キングピンは CopyBone ノードで正しい位置にくるために後に必要となる子メッシュ (下側の緑のボルト) を使わなければなりません。アッパーアームは LookAt ノードで方向を変えるために、キングピンの子メッシ (上側の緑のボルト) の更新された位置にアクセスする必要があります。お分かりのように、異なるコンポーネントが正しい順番で更新されていることを確認するのは必須です。そうでないと、サスペンションの部品が他の部品の移動より遅れて見えてしまう場合があります。

このようなフレームごとの更新はすべて Animation ブループリントで処理されます。

DCC (Digital Content Creation) アプリケーションでモデルをビルドする時は、コンポーネントの軸の階層と正確な位置と方向だけを注意していればいいのです。LookAt ノードで更新された回転を持つコンポーネントの場合は、方向に気をつけることはとりわけ重要です。

一般的には、この種類のメカニズムを作成する間は、お持ちのモデリング パッケージで提供されているコンストレイントを使うと便利です。UE4 へのインポート時に FBX をフォローしませんが、モデルのビルド中に基本的な移動をいくつか取得する場合にすべきことの計算が楽になります。異なるコンポーネントが交差することなく必要な方法での移動を可能にするために、ただし、Animation ブループリント内での再作成ができないコンストレイントの使用は避けてください。

## アンリアル エンジン 4 の設定

このデモがアンリアル エンジンでどのように設定されたかを見てみましょう。エディタにプロジェクト ファイルをアップし、ビークルの Animation ブループリントを開きます。ほとんどの操作は、車輪ごとに 1 回で合計 4 回適用されることにご注意ください。

ビークルの操作中、 Animation ブループリントでは次のことが起こります。

まず、 WheelHandler がシミュレーション中の車輪 (「PhysWheel」のボーン) を更新します。それから、表示中の車輪 (`VisWheel` のボーン) が `PhysWheels` から回転をコピーして、回転を更新します。

![](animBP_1.png)

_WheelHandler の後に表示された車輪の Copy Rotation_

これにより、スピンとステアリングが視覚的に正しくなりますが、車輪の位置は変わりません。これは後で別途説明します。

次に、ロワ アーム (`ArmLower` ボーン) は `PhysWheel`の位置の方へ向きます。ビークルの右側のアームは look at axis として Y を使用し、左側のアームは Negative Y を使用します。

![](animBP_2.png)

_PhysWheel の位置を見る ArmLower ボーン_

LookAt ノードの結果は Animation ブループリント エディタの 3D ウィンドウで簡単にプレビューできます。選択された LookAt ノードの現在のターゲットが赤い十字でマークされます。プレビュー ビューポートをワイヤーフレーム モードに設定すると、簡単に表示できます。

`ArmLower` ボーンが回転して LookAt ターゲットと一致すると、`POS_Hub` と呼ばれる子のコンポーネントも付いてきます。次のステップではこれを使って `POS_Hub` ボーンのトランスレーションのみを取得する CopyBone ノードを使ってキングピンを正しく配置します。

![](animBP_3.png)

_キングピンの位置設定_

Hub と `VisWheel` は同じ方法で同じ位置に後で設定します。

次のステップでは、これらがキングピン ボーンの子供であるという事実により正しい位置に配置されている各ターゲットを見て、前のステップで更新されたアッパーアーム (`ArmUpper` ボーン) を調整します。

![](animBP_4.png)

_アッパーアームを方向づける_

ハブの位置の設定後、フロントのハブだけはステアリングに起因する Z 軸周りの回転を起こすために、まだ作業が必要です。フロントの PhysWheels の子供である`LAT_Hub` ボーンの方を向いた LookAt ノードで処理されます。

![](animBP_5.png)

_ハブの位置とステアリング角度を設定する_

最後に、VisWheel の位置が `POS_Hub` と一致するように設定したら、ショックの上部がロアショックマウント (`ShockMount_Low`) の方を向いていて、ロアショック ボーンはまさに同じショックマウントの位置になっていることを確認します。

![](animBP_6.png)

_表示中の車輪の配置とショック コンポーネントの調整_

##PhAT

プロトタイプの物理アセットの設定は、若干の例外を除けば、標準のビークル テンプレートとほぼ同じです。アンテナに沿って多数存在する小さな球体のボディの違いが目立ちますが、メインのビークル フレームの周りに存在するカスタムしたコリジョン形状の方が重要です。

![](phat_1.png)

_PhAT コリジョン ボディ_

このモデルのルート コンポーネントは実際はジョイントなので、細かいコリジョン ボリュームの作成のために使用できるジオメトリはありません。メインのボディ ボリュームは、 UCX メッシュ (Assets/FBX/vehicle_collision_S2.9.fbx) のある別のスタティックメッシュをインポートして作成されました。

![](phat_2.png)

_別途インポートされたコリジョンのあるスタティックメッシュ_

これについては、PhAT 内では全く対処できません。最初のステップは、選択した 3D モデリング パッケージでコリジョン アセットをビルドします。できれば、メインとなるボディメッシュから開始することが望ましいです。このコリジョン モデルはその後、標準メッシュとして UCX と一緒に UE4 へンポートされます。1 度これを行えば、PhAT 内のビークルのルートノードへこのコリジョン データを簡単にコピーできます。このオプションを使用するには、PhAT の階層パネルに存在するボディを右クリックします。ターゲットのボーンにまだボディが割り当てられていない場合は、カプセルなどを追加して使用します。カスタムしたコリジョンが追加されたら、カプセルは削除します。

![](phat_3.png)

_メニューの一番下の [Adcanced (詳細)] にあるコリジョン オプションをコピーします。_

### アンテナの設定

アンテナはダブルウィッシュボーン サスペンションの部品ではないですが、ビークルの処理全般に影響します。
完全に固定されたアンテナは物理の影響を受けないので、もちろん一番簡単な方法ですが、
このテンプレートでは、ビークルの移動に悪影響を与えずに移動を操作できるアンテナの設定方法を説明します。

このテンプレートでは、最初の **Antenna1** から先端にある最後の **Antenna10** までのそれぞれのアンテナのボーンは、 
アンテナのメッシュそのものの半径とほぼ一致するような半径を持っている球体ボディで設定されています。このボディの **Enable Gravity** を無効にして、 
アンテナが物理システムからの最小の負荷で直立できることを確認します。これらのボディの質量は、16 に設定された一番下の最初の質量スケールから開始して、最後に近づくにつれて急激に減衰します。ボディの質量のスケールを前のボディの 50 `%` に設定するようにし、 
一番下から先端に向かって値を 16、8、4、2、1、0.5、0.25、0.12、0.06、0.03 と設定します。これで、基盤は重たく、先端は軽く設定され、 
この 2 点の間にはスムーズなグラディエントが作成されました。

![](phat_antenna_1.png)

これらのボディに適用されるコンストレイントは、線的にも角度的にも完全にロックされます。ボーン チェーンがかなり長いので、加速に反応して方向が若干変わります。上記の質量のスケールと組み合わせることで、シミュレーションが安定します。 
オシレーションを緩やかにすると、安定したシミュレーションが可能になります。

過度の加速中にシミュレーションが爆発することがないように、**[Angular Tolerance (角度許容値)]** を 1.0 にしてすべてのアンテナのコンストレイントの **[Enable Projection (プロジェクションを有効にする)]** にチェックを入れておくと、 
ボディの **[Position Solver Iteration Count]** が 16 まで上昇します。

![](phat_antenna_2.png)

最後に、アンテナのボディおよびビークルの残りのボディ間での内部的なコリジョンはすべて、不要な内部の衝突を防ぐために無効にされています。これを簡単に行うためには、
 階層パネルのボディを持つボーンをすべて選択し、メインの PhAT ツールバーの **[Collision Off]** ボタンをクリックします。

![](phat_antenna_3.png)

## 実際にモデルをビルドする

設定方法が理解できたら、プロトタイプを自分のモデルでビルドしたくなったと思います。できるだけ困ることがないように、以下のポイントをお役だてください。

まずは、名前と階層をプロトタイプと極力同じにしておきます。こうしておくと、 Animation ブループリントを一切変更せずに、異なるスケルタルメッシュへの再割り当てや再利用が可能になります。時間の節約にもなります。もちろん、メッシュはすべて再モデル化できますし、異なる位置への移動も可能です。すべて正しく調整されていることだけを確認してください。サスペンションの主要コンポーネントの階層全体の妨げにならない限り、モデルにメッシュ ノードを追加しても問題にはなりません。

ビークルのルートはグローバル空間の 0 、0 、0 に配置し、一切回転してはいけません。ルートを単純なジョイント オブジェクトにすると、特に、ショック メッシュの変形などのゆるく結合されたコンポーネントを使用する場合、 FBX のエクスポートとインポート時の問題発生を最小限にすることができます。

Z を Up 軸として使用する設定が可能なモデリング パッケージの場合は、そのようにしてください。いずれにせよ、選択したアプリケーションが Y を Forward 軸と判断した場合でも、X を Forward 軸だと想定します。

モデリング アプリケーションで車輪のメッシュはフロア / グリッドに触れるはずです。モデルのそれぞれのコンポーネントに対して、目的とする回転の中心に回転軸があり、回転がゼロ設定になっていることを常に確認してください。ただし、ショックはもちろん例外です。これはルート ジョイントと先端のジョイントがお互い向き合った方向になります。操作に確信が持てない場合は、トランスフォームや同等の関数がフリーズしないように、1、1、1 のスケールは決して使わないようにしてください。

## インポート オプション

自分でカスタムしたモデルをインポートする場合には、プロトタイプに使用した以下のインポート設定をガイドラインにしてください。

![](import_options.png)

_プロトタイプのビークルに使用したインポート オプション_

... 高度なビークルのビルド方法について、かなり理解が深まったはずです。それでは皆さん、がんばってください！





