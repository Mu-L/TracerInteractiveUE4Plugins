INTSourceChangelist:3242329
Availability:Public
Title:カスタム仕様の UV
Crumbs: %ROOT%, Engine, Engine/Rendering/Materials
Description:頂点シェーダーで計算を実行する場合に、ピクセルごとの計算実行パフォーマンスを高める機能
Version:4.9
parent:Engine/Rendering/Materials
order:12
topic-image:CUVs_topic.png
type:overview
tags:Materials


[TOC(start:2)]


GPU では、頂点シェーダーは頂点ごとに、ピクセル シェーダーはピクセルごとに実行されます。アンリアル エンジン 4 のほとんどのマテリアル ノードはピクセルごとに実行されます。**UV Coordinate** ノードは頂点またはピクセル シェーダーいずれかの一部となり、**CustomizedUVs** 機能が頂点シェーダー内でのみ実行され、同じ計算をピクセル シェーダー内で実行するパフォーマンスを向上させます。テクスチャのタイル処理のみを高速化したい場合にも最適です。システムは UV 上で実行した計算だけに制限されず、結果はメッシュの細分化処理に依存します。

注意：カスタム仕様の UV は現時点では以下の限られたコンポーネント タイプにしか実装されていません。スタティックメッシュ、スケルタルメッシュ、 BSP 、メッシュ パーティクルスプライト パーティクルは、まだカスタム仕様の UV をサポートしていないことに注意してください。

## プロパティ 
  
**マテリアル エディタ** では、メインのマテリアル ノードを選択し、**Material** カテゴリの **Num Customized UVs** プロパティを編集することで、**CustomizedUVs** 入力ピン数を設定することができます。**Num Customized UVs** が 0 より大きい数に設定されている場合、CustomizedUVs ピンはメインのマテリアル ノード上に表示されます。

[REGION:lightbox]
[![](CUVs_matEd.png)(h:250)](CUVs_matEd.png) [![](CUVs_propLocation.png)(h:250)](CUVs_propLocation.png) [![](CUVs_addedPins.png)(h:250)](CUVs_addedPins.png)
[/REGION]

## 非線形計算
  
実施している演算処理で定数を使用する場合、または頂点ごとの属性に合わせて線形に変化する場合、頂点シェーダーでその作業を行うと原則的にはピクセル シェーダーで行う場合と同じ結果がでます。線形に変化するとは、乗算と加算のような、直線でカーブなしの結果となる処理のみを意味します。サイン、コサインを使った二乗、あるいは「長さ」のような処理の結果は、非線形方程式になります。

非線形計算が望ましい結果を出すかどうかは、適用先のメッシュの詳細に依存します。

![](CUVs_highVsLowDetailMesh.png)(w:935)

_左のメッシュはポリゴン グリッドが 9x9 、右は 4x4 です。_

[REGION:lightbox]
[![](CUVs_LVSNL_01.png)(w:935)](CUVs_LVSNL_01.png) 

それとは対照的に、同じメッシュがテクスチャに直接入力されると、ピクセル シェーダーで評価され、メッシュの詳細に関係なく同じ結果がでます。

[![](CUVs_perPixel.png)(h:211)](CUVs_perPixel.png) [![](CUVs_LVSNL_02.png)(h:211)](CUVs_LVSNL_02.png)
[/REGION]

## 線形計算

UV をパラメータでスケール (乗算) すると両方で同じ処理がされます。UV は頂点ごとの属性で、スケーリングは線形処理です。次の画像は、線形処理をする際に頂点シェーダーで計算された CustomizedUV が、ピクセル シェーダーで同じ計算を行った場合と同じエフェクトが生み出していることを表します。

[REGION:lightbox]
[![](CUVs_VequalP_01.png)(h:191)](CUVs_VequalP_01.png) [![](CUVs_VequalP_02.png)(h:191)](CUVs_VequalP_02.png)
[/REGION]
  

  
## 動作の仕組み 
  
CustomizedUV ピンはデフォルトでメッシュ内のテクスチャ座標経由で渡されます。ピクセル シェーダー入力 (BaseColor のような) に Texcoord ノードを配置すると、メッシュのテクスチャ座標を取得することができます。ただし、CustomizedUV0 で何かをする場合は BaseColor 入力の Texcoord 0 を使うと、修正された UV 値が取得されます。Texture sample ノードはデフォルトで TexCoord 0 を使用することにご注意ください。 


  
PC 上の **Shader Model 5** では 8 個の Custom UV を使用でき、モバイル上の **OpenGL ES2** は 3 個しか使用できません。 
 
以下は、元になるマテリアルがワールド空間 y と z を使ってテクスチャをマッピングしている例です。 

![](CUVs_EX01.png)
  
このマテリアルは同じこと、つまり Customized UV 0 のロジックが Texcoord0 経由で BaseColor ピクセル シェーダー入力へ渡されます。ただし、 Texcoord0 の計算は頂点シェーダー内で行われました。 
  
![](CUVs_EX02.png) 

_Texture Sample ノードは暗黙的な TexCoord0 ノードを内部に含みます。_
  
## パフォーマンス全般 
  
頂点はピクセルよりもかなり少ない場合が多いので、計算を頂点シェーダーに移せばパフォーマンス上かなりの利点があります。かなり高いポリゴン数でメッシュを作成する場合、またはポリゴン数の高いメッシュで UOD を使用しない場合、余分な頂点シェーダー作業がボトルネックとなる場合があります。メッシュが 4 ピクセルに渡る距離でオフになっていようが画面を覆っていようが、頂点シェーダー作業は同じだからです。 
  
## モバイル限定 
  
モバイルでは、**テクスチャ座標を操作するテクスチャ サンプルは slow path を使います**。これらは _依存した_ テクスチャ フェッチと呼ばれます。Customized UV 入力を使用すれば、全てのテクスチャ フェッチが _独立_ している限り、タイル処理やワールド空間テクスチャ マッピングを実行できます (fast path)。  
  
さらに、モバイルではピクセル シェーダーの全てが半精度浮動小数点数で評価されます。ピクセル シェーダー計算をテクスチャ座標で行うと、ブロック体のようなテクスチャやその他のアーティファクトを引き起こします。ただし、 Customized UV 入力は最大精度で行うので、この問題を回避します。 
  
以下は異なる 2 つのレートを使った洞窟のマテリアル設定です。

![](CUVs_independentTiling.png)
  
 
