INTSourceChangelist:3242329
Availability:Public
Title:レイヤー マテリアル
Crumbs: %ROOT%, Engine, Engine/Rendering/Materials
Description:UE4 のレイヤー マテリアル技術に関する入門書
Version:4.9
parent:Engine/Rendering/Materials
order:8
topic-image:Engine/Rendering/Materials/LayeredMaterialsTopic.png
type:overview
tags:Materials

[REGION:fullwidth]
![](LayeredMaterials.png)
[/REGION]

[TOC(start:2 end:3)]



レイヤー マテリアルは、「マテリアル内のマテリアル」として考えることができます。レイヤーマテリアルは、一連のサブマテリアル (または _レイヤー_) を持つ単一マテリアルの作成手段です。サブマテリアルは、マスクなどのピクセル単位の操作でオブジェクトのサーフェス全体へ配置することができます。ユニークなサーフェス タイプ間の複雑なブレンド処理に最適です。上記のロケットの画像は、一番右寄りのロケットに独自のマテリアル レイヤーを使用しています。クロム、アルミニウム、そして銅を使用して、ピクセル単位ベースで各マテリアルをブレンドしています。このエフェクトは、レイヤー マテリアルで簡単に実現できます。

レイヤー マテリアルは、拡張マテリアル関数として存在するのが特徴です。覚えている方もいるかもしれませんが、関数は自己完結型のノード ネットワークで、複雑な数式など特定の操作を実行します。これらの関数は、さまざまなマテリアルで再利用することができます。_Make Material Attributes_ ノードと _Break Material Attributes_ ノードにより、関数を使うと、完全に関数 _だけで_ マテリアルを定義することもできます。その後、関数を最終マテリアルへ取り込むことで、レイヤー マテリアルが作成されます。

![](ChromeLayer.png)(w:600)

上記の画像は、 Make Material Attributes ノード経由で、シンプルなクロム マテリアルを Material 関数だけで作成しました。この関数を **マテリアル レイヤー** として使用し、別のマテリアル レイヤーとブレンドすることができるようになりました。

Material 関数は直接サーフェスへ適用することができないため、新規マテリアルへ Material Layer 関数を取り込みむ必要があることに留意してください。その後でオブジェクトへの適用が可能になります。この関数の素晴らしい点は、マテリアル レイヤーを好きなだけ取り込むことができ、自由にブレンドできることです。

以下は、ワークフローの概要です。

* 新規のマテリアルを作成して、完成度を高めるための微調整をします。
* コンテンツ ブラウザで新規のマテリアル関数を作成して、その中にマテリアル関数ノードを全てコピー/貼り付けします。
* ネットワークを新規の Make Material Attributes ノードと接続して、ノードを関数の出力値と接続します。
* 関数を保存します。
* コンテンツ ブラウザ からマテリアル エディタへ関数をドラッグおよびドロップします。これでマテリアル レイヤーが作成されました。
* Material Layer Blend 関数を使用して、複数のマテリアル レイヤーを一緒にブレンドします。


最終オブジェクトには、サーフェス全体にはっきりとブレンドされた複数のマテリアル レイヤーが作成されます。

## 便利な点

レイヤー マテリアルを使用する 1 つの利点は、未使用ではとても困難なマテリアルの作成を可能にしてくれる点です。将来的な編集の観点からも、より簡単な処理が可能になります。例えば、従来のマテリアル (レイヤーなし) でマテリアル レイヤーの効果を作成することは _可能_ ですが、この方法は _各マテリアル入力_ に対して異なるテクスチャと値をブレンドする複雑なネットワークを必要とします。ほとんどのマテリアルは複数の入力値を使用するため、このようなマテリアルの複雑性はかなり増します。

![](RocketLayers.png)(w:300)

以下のネットワークの複雑性を考えてみてください。このネットワークは、マテリアル ネットワークを使用せずに、上記のようなクロムと銅のエフェクトをブレンドしています。

**マテリアル レイヤーを使用しない**
[REGION:lightbox]
![](Rocket_Material_Beforelayers.jpg)(w:900)
[/REGION]


ただし、レイヤー マテリアルの場合、各種マテリアル タイプは独自のノードに格納されるため、編集やデバッグ作業を行うアーティストは、ブレンドをよりシンプルかつ簡易に行うことができます。Make Material Attributes ノードと Break Material Attributes ノードを使用して、個別のプロパティとの接続を気にすることなく、異なる全てのマテリアル レイヤーを直接つなぐこができます。

以下に表示しているネットワークは上記のネットワーク同様に機能しますが、クロムと銅の効果は独自のマテリアル レイヤーへモジュール化しています。

**マテリアル レイヤーを使用する**
[REGION:lightbox]
![](MatieralLayering.jpg)
[/REGION]

マテリアル レイヤーのその他の利点は、マテリアル関数の利用により再利用が出来る点です。これにより、マテリアル アーキタイプのライブラリ、または基本的な現実世界の表面タイプの定義の設定が可能になります。例えば、アルミニウム、スチール、皮、プラスチック、ゴムなどの一般的な表面を表現するレイヤーを作成することができます。レイヤー間のブレンドにはレイヤー マテリアルを使用します。別々に表面へ適用しようとして膨大なマテリアル対象を作成せずに、例えばキャラクターなど、詳細なオブジェクトの作成にとても実用的です。



![](CarrierBreakdown.png)(w:600)


## ブレンドタイプ

マテリアル エディタのマテリアル関数リスト内に、さまざまな Material Layer Blend 関数のリストがあります。リストは、特定のマテリアル機能をオーバーライドする能力など、異なるタイプを特別なブレンドタイプに仕上げるため、ブレンド処理に役立ちます。

![](MatLayerBlendFunctions.png)


|Material Layer Blend 関数||
|---|---|
|**MatLayerBlend_AO**| 反射を除去するために表面上にアンビエントオクルージョン (AO) マップをブレンドします。|
|**MatLayerBlend_BaseColorOverride**| ベースカラーの置き換えを可能にします。|
|**MatLayerBlend_BreakBaseColor**| 入力されるマテリアル レイヤーからベース カラーを出力します。|
|**MatLayerBlend_BreakNormal**| 入力されるマテリアル レイヤーから法線を出力します。|
|**MatLayerBlend_Decal**| 2番目の UV チャンネルを使用してマテリアル上へデカールシートをブレンドします。|
|**MatLayerBlend_Decal_UV3**| 3番目の UV チャンネルを使用してマテリアル上へデカールシートをブレンドします。|
|**MatLayerBlend_Emissive**| マテリアル レイヤーへエミッシブ テクスチャをブレンドします。|
|**MatLayerBlend_GlobalNormal**| マテリアル レイヤーへ法線テクスチャをブレンドします。|
|**MatLayerBlend_LightmassReplace**| Lightmass のベースカラーを置き換えます。間接光の効果に変更をもたらします。|
|**MatLayerBlend_ModulateRoughness**| 入力テクスチャでマテリアル レイヤーのラフネスを乗算します。「脂で汚れた」ように見せる場合に便利です。|
|**MatLayerBlend_NormalBlend**| 表面全域で法線テクスチャをブレンドしますが、マスクテクスチャの処理手法でブレンドすることによって、法線が表示される位置の制御を可能にします。|
|**MatLayerBlend_NormalFlatten**| 法線マップの効果を弱めます。|
|**MatLayerBlend_RoughnessOverride**| マテリアル レイヤーのラフネス テクスチャを置き換えます。|
|**MatLayerBlend_Simple**| 2 つのマテリアル レイヤーにシンプルな線形補間 (Lerp) ブレンドソリューションを提供します。法線をブレンドしない代わりに、ベースマテリアルの法線を保持します。|
|**MatLayerBlend_Stain**| ベース マテリアルの上にトップ マテリアルをステイン (染み) としてブレンドします。つまり、トップ マテリアルのベース カラーとラフネス値のみを使用します。|
|**MatLayerBlend_Standard**| 2 つのマテリアル レイヤーの全ての属性をブレンドします。|
|**MatLayerBlend_Tint**| ティント (色合い) の位置を制御するために、淡彩色とマスクを入力してマテリアル レイヤーの色調を弱めます。部分的な色の変更に実用的です。|
|**MatLayerBlend_TintAllChannels**| ティントに良く似ていますが、スペキュラにも影響を及ぼします。これは極めて特別な機能なので、通常は必要ありません。|
|**MatLayerBlend_TopNormal**| 両マテリアルの全ての属性をブレンドしますが、トップ マテリアルの法線のみを使用します。|




## レイヤー マテリアルのインスタンス

レイヤー マテリアルは基本的にマテリアル関数であるため、インスタンス化のためにこれらをパラメータ化するには事前計画が多少必要になります。スカラー パラメータとベクター パラメータを使いやすくするために、関数入力表現式をマテリアル レイヤーの一部として作成することもできます。そうしておくと、最上位のマテリアルからこの入力式へパラメータを接続することができます。詳細は [物理アセット ユーザーガイド](Engine/Rendering/Materials\Functions) を参照してください。

フローは以下のようになります。


[REGION:raw]![](LayeredMatParamDiagram.png)[/REGION]
1. Material パラメータ (Scalar パラメータ 、 Vector パラメータなど)
1. Material Layer (関数)
1. Function Input 式
1. マテリアル レイヤーを定義するあるネットワーク
1. 関数の出力
1. 最終マテリアル


**ヒント**

* レイヤーの作成時に Material 式を関数へ渡すとき、全パラメータを適切な名前が付けられた Function Input ノードと置き換えます。
* マテリアルへマテリアル レイヤーを取り込む時、新規のパラメータ ノードを入力値と接続します。
* これで最終マテリアルをインスタンス化することができます。パラメータがレイヤーに適した部分を操作します。
* Function Input ノードには、必ずデフォルト値の設定をしてください。変更を加える必要のない場合、開発者のワークフローが迅速化します。


## 注意事項

レイヤー マテリアルは、複数のマテリアル設定の処理に便利ですが、使用には細心の注意をはらわなくてはいけません。パフォーマンスに関しては、レイヤー マテリアルを使用すると動作が重くなることがあり、特にレイヤーに複雑なマテリアルを使用した場合は重くなります。 

レイヤーはすべて同時にレンダリングされて、その後ブレンドされることに留意してください。例えば、マテリアルに 4 つのレイヤーがある場合、オブジェクトの各ピクセルに対して、システムはブレンドされているレイヤーを特定するためのテストを実行し、未使用のレイヤーを拒否しなくてはいけません。計算を追加すれば、レイヤー マテリアルのパフォーマンスが強化されます。

オブジェクトに複数のサーフェス タイプを設定する場合、常にレイヤー マテリアルを使用したい衝動に駆られるかもしれません。例えば車のモデルの場合、ペイントにあるマテリアル レイヤーを使用し、スチール、ゴム、ガラスにそれぞれ別のマテリアル レイヤーを使用します。ただし、これらのマテリアルは、ジオメトリ レベルで分離されている場合が多いです。オブジェクトによってはマテリアル エレメントが多く作成されるのでドローコールが増加しますが、一般的には効率性がかなり向上します。要するに、レイヤー マテリアルを使用する代わりに複数マテリアルを適用 _できる_ 場合は、複数マテリアルを使用してください。マテリアルを配置した位置にピクセル別の調節が _必要な_ 場合は、レイヤー マテリアルを使用してください。

複数の個別のマテリアルを 1 つに簡略化することによりドローコールは減りますが、ほとんどの場合レイヤー マテリアルをモバイル機能と考えると重すぎる動作になります。
