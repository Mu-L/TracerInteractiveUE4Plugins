INTSourceChangelist:3242329
Availability: Public
Title:레이어드 머티리얼
Crumbs: %ROOT%, Engine, Engine/Rendering/Materials
Description:UE4 의 레이어드 머티리얼 기법에 대한 소개 문서입니다.
Version: 4.9
parent:Engine/Rendering/Materials
order:8
topic-image:Engine/Rendering/Materials/LayeredMaterialsTopic.png
type:overview
tags:Materials

[REGION:fullwidth]
![](LayeredMaterials.png)
[/REGION]

[TOC(start:2 end:3)]



레이어드 머티리얼(Layered Material)이란 "머티리얼 안의 머티리얼" 개념으로 생각해 볼 수 있습니다. 하나의 머티리얼 안에 하위 머티리얼 시리즈 (또는 _레이어_) 를 만든 다음, 그것을 마스크와 같은 픽셀 단위 연산을 통해 전체 오브젝트 표면에 배치할 수 있는 것이지요. 독특한 표면 유형들이 복잡하게 섞여있는 것을 처리하는 데 딱입니다. 위의 로켓 그림에서 거의 오른쪽 끝에 있는 로켓은 크롬, 알루미늄, 구리 등 독립된 머티리얼 레이어를 사용중이며, 픽셀 단위로 각각의 머티리얼을 혼합하고 있습니다. 이러한 효과는 레이어드 머티리얼을 사용해서 쉽게 이뤄낼 수 있습니다.

레이어드 머티리얼은 머티리얼 함수의 특징적인 확장 기능으로써 존재합니다. 아시는 바와 같이 함수란, 복잡한 수학 방정식 등 특정 연산을 수행을 위해 자체적으로 독립된 노드 망입니다. 이러한 함수는 나중에 다수의 머티리얼에서 필요한 만큼 재사용 가능합니다. _Make Material Attributes_ / _Break Material Attributes_ 노드 덕분에 순전히 함수 _안에서도_ 머티리얼을 정의하는 데 함수를 사용할 수 있습니다. 그 후 그 함수를 최종 머티리얼에 끌어오면 레이어드 머티리얼을 가질 수 있습니다.

![](ChromeLayer.png)(w:600)

위 그림에서 보시는 단순한 크롬 머티리얼은 순전히 머티리얼 함수 안에서만 Make Material Attributes 노드를 통해서 만든 것입니다. 이제 이 함수를 머티리얼 레이어로 사용할 수 있으며, 다른 머티리얼 레이어와 섞을 수도 있습니다.

한 가지 중요한 사실은, 머티리얼 함수를 표면에 직접 적용할 수는 없기 때문에, 머티리얼 레이어 함수를 새 머티리얼에다 들여 놔야 오브젝트에 적용할 수 있다는 것입니다. 이 방법의 좋은 점은, 원하는 만큼의 머티리얼 레이어를 들여 놓은 다음 알맞게 블렌딩해 주면 되는 것입니다.

즉 하이 레벨에서의 작업방식은 이렇습니다:

* 새 머티리얼을 만든 다음 완벽한 수준으로 미세조정합니다.
* 콘텐츠 브라우저에서 머티리얼 함수를 새로 만든 다음 모든 머티리얼 함수 노드를 그 안에 복사해 붙여넣습니다.
* 망을 새 Make Material Attributes 노드에 연결한 다음, 함수 출력에 연결합니다.
* 함수를 저장합니다.
* 콘텐츠 브라우저에서 함수를 끌어 머티리얼 에디터에 놓습니다. 이제 머티리얼 레이어가 됩니다.
* Material Layer Blend 함수를 사용하여 여러 머티리얼 레이어를 섞습니다.


이제 최종 오브젝트는 표면 전반에 독립적으로 블렌딩되는 머티리얼 레이어를 다수 가질 수 있습니다.

## 핵심 장점

레이어드 머티리얼의 장점 중 하나는, 머티리얼 레이어가 아니었다면 매우 복잡해질 머티리얼을 쉽게 만들 수 있는데다, 앞으로의 수정 용이성 관점에서도 관리하기가 훨씬 편리하다는 데 있습니다. 예를 들어 레이어드 머티리얼로 제작한 이펙트를 (레이어 없는) 기존 머티리얼을 사용해서 만드는 것이 _가능은_ 하지만, _각각의 머티리얼 입력_ 에 대한 여러가지 텍스처와 값을 블렌딩하기 위해 복잡한 망이 필요하게 됩니다. 대부분의 머티리얼이 다중 입력을 활용하기에, 그러한 머티리얼은 심각하게 복잡해 질 것입니다.

![](RocketLayers.png)(w:300)

머티리얼 레이어를 사용하지 않고 위와 같은 크롬과 구리 혼합 효과를 내는 아래 망의 복잡도를 살펴 봅시다:

**머티리얼 레이어 없음**
[REGION:lightbox]
![](Rocket_Material_Beforelayers.jpg)(w:900)
[/REGION]


그러나 레이어드 머티리얼 방식으로는, 각기 다른 머티리얼 유형이 자체 노드에 포함되어 있어, 블렌딩이 훨씬 간편하고 아티스트의 편집이나 디버깅도 훨씬 쉬워집니다. Make / Break Material Attributes 노드를 사용하면, 프로퍼티 하나하나 신경쓸 필요 없이 온갖 머티리얼 레이어를 바로 연결할 수 있습니다.

아래 망은 위와 같은 식으로 작동하나, 크롬과 구리 효과가 자체 머티리얼 레이어 안에 모듈화되어 있습니다.

**머티리얼 레이어 있음**
[REGION:lightbox]
![](MatieralLayering.jpg)
[/REGION]

머티리얼 레이어의 또다른 장점은, 머티리얼 함수를 활용하기 때문에 재사용이 가능하다는 점입니다. 머티리얼 아키타입의 라이브러리, 또는 현실의 기본적인 표면 유형이 정의된 머티리얼을 구성하는 것이 가능합니다. 예를 들어 알루미늄, 강철, 가죽, 플라스틱, 고무 등등 일반적인 표면을 나타내는 레이어를 만들 수 있습니다. 그런 다음 레이어드 머티리얼 방식을 사용하여 섞습니다. 표면에 각기 따로 적용해 줘야 하는 머티리얼 세트를 대량으로 만들 필요 없이, 캐릭터와 같은 디테일한 오브젝트를 만들고자 할 때 매우 유용합니다.



![](CarrierBreakdown.png)(w:600)


## 블렌드 유형

머티리얼 에디터의 머티리얼 함수 리스트 내부는 다양한 머티리얼 레이어 블렌드 함수 리스트입니다. 이들은 다양한 유형과의 블렌딩을 돕기 위해 있는 것으로, 특수 유형 블렌딩은 물론 특정 머티리얼 요소를 덮어쓰는 것도 가능합니다.

![](MatLayerBlendFunctions.png)


|머티리얼 레이어 블렌드 함수||
|---|---|
|**MatLayerBlend_AO** 앰비언트 오클루전|표면에 앰비언트 오클루전 (AO) 맵을 블렌딩하여 리플렉션을 제거합니다.|
|**MatLayerBlend_BaseColorOverride** 베이스 컬러 덮어쓰기 |베이스 컬러를 대체할 수 있습니다.|
|**MatLayerBlend_BreakBaseColor** 베이스 컬러 분리 | 입력되는 머티리얼 레이어에서 베이스 컬러를 출력합니다. |
|**MatLayerBlend_BreakNormal** 노멀 분리 | 입력되는 머티리얼 레이어에서 노멀을 출력합니다. |
|**MatLayerBlend_Decal** 데칼 | 머티리얼 위에 2차 UV 채널을 사용하여 데칼 시트를 블렌딩합니다. |
|**MatLayerBlend_Decal_UV3** 데칼 UV3 | 머티리얼 레이어 위에 3차 UV 채널을 사용하여 데칼 시트를 블렌딩합니다. |
|**MatLayerBlend_Emissive** 이미시브 | 머티리얼 레이어 위에 이미시브 텍스처를 블렌딩합니다. |
|**MatLayerBlend_GlobalNormal** 글로벌 노멀 | 머티리얼 레이어 위에 노멀 텍스처를 블렌딩합니다. |
|**MatLayerBlend_LightmassReplace** 라이트매스 대체 | 라이트매스의 베이스 컬러를 대체, 간접광 결과에 변화를 줄 수 있습니다. |
|**MatLayerBlend_ModulateRoughness** 러프니스 변조 | 머티리얼 레이어의 러프니스에 입력받는 텍스처를 곱합니다. "끈적한" 느낌에 좋습니다. |
|**MatLayerBlend_NormalBlend** 노멀 블렌드 | 표면에 걸쳐 노멀 텍스처를 블렌딩하되 마스크 텍스처를 사용, 노멀이 나타나는 곳을 제어 가능합니다. |
|**MatLayerBlend_NormalFlatten** 노멀 평탄화 | 노멀 맵 효과를 상쇄시킵니다. |
|**MatLayerBlend_RoughnessOverride** 러프니스 덮어쓰기 | 머티리얼 레이어의 러프니스 텍스처를 대체합니다. |
|**MatLayerBlend_Simple** 단순 | 두 머티리얼 레이어에 대해 단순한 선형 보간 (Lerp) 블렌딩을 제공합니다. 노멀은 블렌딩하지 않는 대신, 베이스 머티리얼의 노멀을 유지합니다. |
|**MatLayerBlend_Stain** 얼룩 | 베이스 머티리얼 위에 탑 머티리얼을 얼룩으로 블렌딩, 즉 탑 머티리얼의 베이스 컬러와 러프니스 값만 사용합니다. |
|**MatLayerBlend_Standard** 표준 | 두 머티리얼 레이어의 모든 특성을 블렌딩합니다. |
|**MatLayerBlend_Tint** 색조 | 틴트 컬러와 마스크 입력을 통해 색조 위치를 조절하는 식으로 머티리얼 레이어에 색조를 더할 수 있습니다. 부분 염색에 좋습니다. |
|**MatLayerBlend_TintAllChannels** 모든 채널 색조 | Tint 와 비슷하나, 스페큘러에도 영향을 끼칩니다. 매우 특이한 경우의 함수로, 보통은 필요치 않습니다. |
|**MatLayerBlend_TopNormal** 탑 노멀 | 양쪽 머티리얼의 모든 특성을 블렌딩하나 탑 머티리얼의 노멀만 사용합니다. |




## 레이어드 머티리얼 인스턴싱

레이어드 머티리얼은 본질적으로 머티리얼 함수이기 때문에, 인스턴싱에 쓸 파라미터를 만드는 작업에는 약간의 사전 숙고가 필요합니다. Scalar 나 Vector Parameter 같은 파라미터 표현식 활용도를 높이기 위해서는, Function Input 표현식을 머티리얼 레이어의 일부로 만들어 줘야 합니다. 그런 다음 파라미터를 탑 레벨 머티리얼에서 이 입력으로 연결해 주면 됩니다. 자세한 정보는 [머티리얼 함수 개요](Engine/Rendering/Materials\Functions) 문서를 참고해 주시기 바랍니다.

작업의 흐름은 이렇습니다:


[REGION:raw]![](LayeredMatParamDiagram.png)[/REGION]
1. 머티리얼 파라미터 (스칼라 파라미터, 벡터 파라미터 등)
1. 머티리얼 레이어 (함수)
1. Function Input 표현식
1. 머티리얼 레이어를 정의하는 망 제작
1. 함수 출력
1. 최종 머티리얼


**도움이 될만한 팁:**

* 머티리얼 표현식을 함수 속에 붙여넣어 레이어를 만들 때는, 모든 파라미터를 적합한 이름의 Function Input 노드로 바꿔 주세요.
* 새 머티리얼 레이어를 머티리얼 속에 들여올 때, 새 파라미터 노드를 입력에 연결하세요.
* 이제 최종 머티리얼의 인스턴싱이 가능하며, 레이어의 올바른 부분을 파라미터에 반영됩니다.
* Function Input 에 기본값을 주는 것 잊지 마세요. 변경할 필요가 없는 작업방식 속도가 향상됩니다.


## 주의사항

레이어드 머티리얼이 다중 머티리얼 구성을 처리하는 데 좋기는 하지만, 이용하는 데 있어서는 주의가 필요합니다. 퍼포먼스 측면에서는 비용이 많이 들 수 있으며, 레이어에 쓰인 머티리얼 자체가 복잡한 경우에는 더더욱 그렇습니다.

염두에 두실 것은, 모든 레이어는 동시에 렌더링되고, 그 이후 블렌딩이 적용됩니다. 예를 들어 머티리얼에 레이어가 넷 있다면, 오브젝트의 각 픽셀에 대해서 시스템은 넷 중 어느 것이 블렌딩되는지 검사한 다음 사용되지 않는 것은 버립니다. 이와 같은 추가적인 계산때문에 레이어드 머티리얼이 퍼포먼스에 민감해집니다.

레이어드 머티리얼을 사용하고픈 충동을 처음 느끼는 것은, 오브젝트에 여러가지 유형의 표면을 사용하고 싶을 때일 것입니다. 예를 들어 차량 모델이 있는 경우, 페인트, 강철, 고무, 유리 등 각각에 대해 머티리얼 레이어를 하나씩 쓰고 싶을 수가 있습니다. 그러나 이러한 머티리얼 중 다수는 지오메트리 레벨에서 분리 가능합니다. 그러면 오브젝트에 머티리얼 엘리먼트 수가 늘어 드로 콜이 늘어날 수는 있겠지만, 일반적으로는 훨씬 더 효율적입니다. 요약하자면, 레이어드 머티리얼 대신 다수의 머티리얼을 적용하는 것이 _가능하다면_ 그렇게 하시고, 머티리얼을 픽셀 단위로 배치 _해야만 한다면_ 레이어드 머티리얼을 사용하시기 바랍니다.

다수의 개별 머티리얼을 하나의 머티리얼로 응축시키면 드로 콜은 감소되겠지만, 그 결과 나오는 레이어드 머티리얼은 모바일에서 쓰기에 비용이 과다한 경우가 일반적입니다.