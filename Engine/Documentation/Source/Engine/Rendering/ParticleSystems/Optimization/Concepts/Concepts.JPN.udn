INTSourceChangelist:3243860
Availability:Public
Title:パーティクル システムのコア最適化のコンセプト
Crumbs: %ROOT%, Engine, Engine/Rendering/ParticleSystems, Engine/Rendering/ParticleSystems/Optimization
Description:エフェクトを最適化するためにトラブル領域と問題のコンテンツを特定します。
Version:4.9
Parent:Engine/Performance
tags:Particles



[TOC]

## GPU、レンダリング スレッド、ゲーム スレッドの問題を特定する

UE4 には、エフェクト アーティストがパフォーマンス問題のトラブルシューティングを行うための機能がいくつかあります。まず、エフェクトのどの部分がボトルネックを作り出しているかを特定することが、真の問題を最適化する長いプロセスの始まりとなります。それにより、ビジュアル的な完成度と品質を保ちます。

レベル全体をプレイしながら問題をモニタリングする方法の 1 つとして、 STAT UNIT (統計ユニット) デバッグ オーバーレイを表示させるということがあります。 


1. ゲームを起動します。
1. **\`** (バックスラッシュ) キーを押して、コンソールに `stat unit` を入力します。

    ![statunit.png](statunit.png)


`stat unit` コマンドによって、ゲームスレッド上で現在のフレームのために使われた時間、レンダリングスレッドのために使われた時間、GPU のために使われた時間が表示されます。stat unit によって更新されるこれらの異なる時間をモニタリングすることによって、パフォーマンス問題をかかえるレベルの部分を調べることが可能です。

これらの異なるスレッド時間を監視し、目標のフレームレートが 30 fps である場合は、すべてのスレッドが 33.3 ms よりも低い値を保たなければなりません。

33 ms を超えるスレッドがあり、パーティクルが元凶と目される場合は、 `STAT PARTICLES` (パーティクルの統計) コマンドを使用して、それぞれのスレッド上におけるパーティクルの時間を判定します。

[REGION:lightbox]
[![statparticles.png](statparticles.png)(w:920)](statparticles.png)
[/REGION]

`STAT PARTICLES` によって、ゲーム スレッドおよびレンダリング スレッドに関係する複数の統計項目がリスト表示されます。Draw Calls (描画コール) (レンダリング スレッド) と Tick Time (ティック時間) (ゲームスレッド) に注目してください。 

[COMMENT:none]

[PUBLISH:Licensee]



## Pix を使用して GPU 関連の問題を見つける

Xbox 360 の GPU の問題を診断するうえで最も信頼性が高い方法は、PIX を使用することです。このドキュメントでは、Xbox 360 でPIX キャプチャを行うプロセスについて詳細には説明しません。PIX およびこのプロセスに関するチュートリアルのダウンロードは以下を参照してください。


* [PIX for Artists](http://www.microsoft.com/download/en/confirmation.aspx?id=22904)


PIX の関連情報を入手し、問題を生じているパーティクル システムが判明したら、いくつか解決の道を探る方法があります。


1. エミッタの列がまっすぐになっていないために、オーバードロー シナリオの作成が非効率になっていないか確認してください。
1. パーティクル システムのエミッション レートを下げます (オパシティを高める、レートを減らす)。
1. マテリアルのインストラクション数を減らします (シェーダー複雑度のビューを使用して、負荷のかかるシステムを対象にする)。 明るい赤＝ 300 インストラクション、ピンク＝ 600 インストラクション、白＝ 900 インストラクションこのプレビューは PIE で F5 を押しても表示することができます。
1. LOD 距離を緊密にし、近接/遠方のLOD ほどエミッション カウントを低くして、シーンの奥に進むほど描画するスプライト数が少なくなるように、またエフェクトに近づくほどスプライト数が少なくなるようにします。
1. パーティクルのスケールを下げ、スクリーンのより狭い範囲を満たすようにします(必要に応じて、パーティクル パラメータを使用してこれをアクタ単位で行うことができます)。 
1. Spawn Per Unit (単位当たりのスポーン) を使用している場合、スポーンの距離が長くなるように Unit Scalar (単位スカラー) を増やすか、Spawn Per Unit (単位当たりのスポーン) を減らします（または両方）。
1. エフェクトが A 点から B 点に急にテレポートあるいは飛んでしまう場合は、maxFrameDistance がパーティクル スポーン レートをもっと制御できるように調節してください (そうすると spawnPerUnit 大量のパーティクルをダンプしないようにします)。


[/PUBLISH:Licensee]

[/COMMENT]


##ゲーム スレッド関連の問題に的を絞る

ゲーム スレッド関連の問題があるとわかったら、`STAT PARTICLES` コマンドを使用してその問題を検証します。

この統計では、かなりの情報が提供されるため、リンク付けされたページの説明を参照して何が最も負荷が高いかを判断してください。パーティクルの Tick Time (ティック時間) と数に注意してください。

[REGION:note]
パーティクル システムはエフェクトを構成するコンポーネント (エミッタ / モジュール) の合計であることを覚えておくことは重要です。システムで使用するユニークなエミッタとモジュールが多くなるにしたがって、あるいは、このシステムがシーン内に増えるにしたがって、ゲームスレッドの負荷は高くなります。
[/REGION]

[COMMENT:none]

ティック時間が大きい場合は、`ParticleTickStats` (パーティクルティック統計) コマンドを使用することによって、どのシステムが主要因となっているかを判定します。

`ParticleTickStats` コマンドには、次の 3 つの引数があります。

* **Single** - この引数が渡されると、単一のフレームがキャプチャされ、ファイルに書き出されます。
* **Start** -  この引数によって、統計情報のキャプチャリングが開始されます。
* **Stop** - この引数は、統計を終了させて、一定期間のティック時間が表示されるようにします。


`ParticleTickStats` のレポートは、次のディレクトリに書き出されます。

`[UE4 Directory]\\[YourGame]\Profiling\PSTick-[sys time].csv`

スプレッドシートが、行と列に分解されて、エフェクトによる負荷の概略が示されます。       

![particletickstats.jpg](particletickstats.jpg)(w:630 h:42)

$ **Total Tick ms** :当該パーティクル システムのインスタンスをすべてティックするのに要した合計時間です。
$ **Avg Tick ms** :当該パーティクル システムをティックするのに要した平均時間です。(Total Tick ÷ Ticks)。
$ **Max Tick ms** :当該パーティクル システムのインスタンスに要した最も大きいティック時間です。
$ **Ticks** :当該パーティクル システムのインスタンス数です。
$ **Avg Active/Tick** :当該パーティクル システムのティック期間にアクティブであるパーティクルの Avg #  (平均数) です。
$ **Max Active/Tick** :当該パーティクル システムのティック期間にアクティブであるパーティクルのMax #  (最大数) です (単一のインスタンスにおいて)。

プラットフォームによっては、適切な手段で、ディレクトリを調べてみなければならない場合があります。このファイルは、コンマでデータが区切られており、Excel などで開くことができます。

[/COMMENT]

原因となっているゲームスレッドのシステムを特定したら、取るべき手段がいくつかあります。


* 使用中のシステム上にあるパーティクル エミッション数を減らす。
* シーン内にあるパーティクル システムの数を減らす。
* エミッタのいくつかのライフタイム (パーティクルの評価を計算する時間の量) を減らす。
* コリジョンなどの負荷が高い計算をチェックすることによって、使用している設定値が最適になるようにするとともに、コリジョンまたはパーティクル / メッシュがコリジョンする量を減らす。
* 必要に応じて、コリジョンや動的なパラメータなどの負荷が高い計算を取り除く。
* 可能な場合、ゲームスレッドで計算されるパーティクル エフェクトの代わりに、静的メッシュのエフェクトを使う。
* パーティクル システム上に固定した領域を設定することによって、フレーム毎に計算しないようにする。
* LodDistanceCheckTime (LOD 距離チェック時間) を増やして、LOD のチェック回数を減らす(LODMethod が自動に設定されたループエフェクトのため)。



(#LaunchGame)

[COMMENT:none]

[PUBLISH:Licensee]

## ビルドを開始する

ゲームのビルドを開始するには、様々な方法があります。このドキュメントでは、一般的に使用される 2 つの方法を説明し、デフォルトのデバッグ機能を無効にするコマンドラインの引数を使用できるようにします。

ビルドを開始する方法はいくつかありますが、エフェクト アーティストとして最もやりやすいのはバッチファイルまたは 「Unreal Frontend」 を使用する方法です。プリクックされ、ローカルでのクックなしでターゲット プラットフォームに供給されたゲームのビルドを開始するには、バッチファイルが非常にうまく機能します。ターゲットに対してローカルにクックしたビルドまたは単一レベルを提供し起動する場合に、Unreal FrontEnd はとても直観的で使いやすいです。


### バッチファイルを使用してコンソール上でビルドを開始する

Windows でのバッチファイル作成に慣れていない場合は、バッチファイル作成プロセスについて説明しているいくつかのウェブサイトがあります。以下のウェブサイトは一例であり、他にも多くのサイトがあります。http://www.computerhope.com/batch.htm

開発キットが実行していて、Xbox 360 Neighborhood で適切にセットアップされていることを確認してください。デバッグ コマンドを開始する、またはクラッシュ レポートを集めたい場合は、「UnrealFrontend」から Unreal コンソールを開きます。

以下は、「Gears of War 3」で使用されるバッチファイルの例です。
   
    cd\Program Files (x86)\Microsoft Xbox 360 SDK\bin\win32
    xbreboot /yourIpAddress DEVKIT:\YourGame[Build]\UnrealEngine3\YourGame.xex -novsync -nomovie -noailogging -noverifygc
    ポーズ
    

一行目で定義されている場所で、このプロセスを開始する必要があります。

次に、ゲームのビルドに対するパスをポイントします。この場合は、Gear_[06-06_05.51] です。Xbox 360 Neighborhood でファイルを表示し、バッチファイルを編集して、使用したい適切なビルドに変更することができます。

ビルドをテストするために使用するコマンドライン引数が続きます。バッチファイルを使用する重要な点は、こうしたコマンドライン引数を使用して、特定の機能を有効または無効にした状態でビルドをテストできるということです。このケースでは、垂直同期、ムービー、AI ロギング、ガーベジ コレクションを無効にしています。

一番最後を "Pause" にするとコマンドライン ウィンドウが開いたままになるので、エラーとメッセージを読み取ることができます。

[/PUBLISH:Licensee]


### UnrealFrontend を使用してコンソール上でビルドを開始する

Unreal FrontEnd は、プロジェクトの Binaries (バイナリ) フォルダの中にあります。

`[UE4 Directory]\Binaries\UnrealFrontend.exe`

Unreal FrontEnd は、どのようなやり方であってもすばやくビルド、またはレベルをクックおよびデプロイすることによって、 ターゲットプラットフォーム上でローカルのデータに関する結果を表示することができる GUI です。Unreal FrontEnd は、エディタや他の多数のツールへのリンクをともなって、プロジェクトの起動場所として使用することが可能です。 

エフェクトのパフォーマンスに関して、ゲームを起動してどの程度適切にゲームが進行しているかを比較的正確に測定するために、2 つのパラメータの使用に重点をおきます。[Launch Options (オプションの起動)] 欄に、-novsync、-noverifygc、-noailogging を入れます。

-novsync は、垂直同期を無効にします (fps を 30 に固定します)。これにより、シーン内にどの程度オーバーヘッドが存在するかを知ることができます。-noverifygc は、目に見える処理落ちの原因となる定期的なガーベジ コレクションを無効にします。-noailogging は、ゲームの速度をかなり遅くする AI ロギングを無効にします。AI ロギングとガーベジ コレクションは、有効になっている場合、バックグラウンドで稼働して、パフォーマンスを遅くします。こうした機能を無効にすることで、最終的なリリースビルドにおける実際のフレームレートをより忠実に再現することができます。ただし、ディスクのロード時間を除きます。

![frontend.jpg](frontend.jpg)(w:624 h:415)

デバッグビルドでこのテストのいずれかを行う場合に忘れてはならないのは、デバッグでゲームを稼働することに対して負荷が発生し、それは最終的なリリースビルドでは見られないということです。stat (統計) オーバーレイのようなツールを使用すると、負荷がかかり、結果がわずかに不正確になります。



## FX のトラブルシューティング バッチ

複数の一般的な問題について多数のエフェクトをチェックし、スプレッドシートに出力して原因をリスト表示するコマンドレットがいくつか用意されています。

こうしたコマンドレットには、以下があります：


### ParticleSystemAudit

このコマンドレットは、MineCookedPackages から生じたデータベースに含まれるすべてのパーティクル システム上で監査を実行します。

**注記:** これにより 'On DVD' タグの使用に変更されます。存在するすべてのパーティクル システムを単純にチェックし、

このコマンドレットは、次のような項目を含む csv ファイルを作成するため、コンテンツの最適化 / 修正に役立ちます：

$ **All particle systems w/ NO LOD levels**:NO LOD levels とは、パーティクル システムが空であることを意味します。
$ **All particle systems w/ a single LOD level** :これらのシステムは見直して、環境 (レベル配置の) エフェクトではないことを確認すべきです。そのような場合は、通常、LOD を利用することによって、遠方のエミッタを無効にする必要があります。
$ **All particle systems w/out fixed bounds set** ：固定された相対的な境界を利用している可能性のある全パーティクル システムです。
$ **All particle systems w/ LOD Method of Automatic & a check time of 0.0** :パーティクル システムがフレームごとに LOD をチェックするシナリオを表示します。
$ **All particle systems w/ bOrientZAxisTowardCamera enabled** ：このようなパーティクル システムは、ゲームが分割スクリーンをサポートしている場合に、問題を引き起こす可能性があります。 
$ **All particle systems w/ missing materials** ：そのようなパーティクル システムは、デフォルトのマテリアルを使ってレンダリングされます。
$ **All particle systems w/ no emitters** ：これらのシステムは 'empty' ですが、削除すべきですか？
$ **All particle systems w/ collision on in at least one emitter** ：現在のコリジョンのメソッドは、パーティクルにとって非常に負荷が高い操作となっています。


### FindOnDvDPsysDynamicParameter

このコマンドレットは、機能中の動的パラメータマテリアル式を使わずにマテリアルの参照を行いながら、動的パラメータモジュールを使用しているあらゆるエフェクトを見つけます。このプロセスのフール プルーフは、完全ではありません。したがって、動的パラメータモジュールを削除する前に、マテリアルエディタを通じて結果を検証することが大切です。

[/COMMENT]
