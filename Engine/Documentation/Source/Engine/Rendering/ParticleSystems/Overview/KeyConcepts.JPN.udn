INTSourceChangelist:3801260
Availability:Public
Title:キー パーティクルのコンセプト
Crumbs: %ROOT%, Engine, Engine/Rendering/ParticleSystems
Description:アンリアル エディタおよびカスケード パーティクル エディタにおいてパーティクルを操作するための非常に重要な概念
Version:4.9
tags:Particles
tags:Getting Started
parent:Engine/Rendering/ParticleSystems
order:1
type:overview
topic-image:Engine/Rendering/ParticleSystems/particles_topic.png


[TOC(start:2 end:3)]

**パーティクル システム** と **カスケード** は _パーティクル システム_ エディタで、非常に柔軟でパワフルです。しかし、実際の作業に着手する前に、重要な概念をしっかり理解しておく必要があります。本ドキュメントの目的は、ユーザーインターフェースの微妙な違いやパーティクル エフェクト作成の詳細には触れずに、パーティクル システムのこうした特性がどのように機能するのかを体感してもらいながら主要な概念を紹介することです。

## パーティクル エフェクトへのモジュール式アプローチ

カスケードで最優先する概念は、モジュール式に作成されたパーティクル システムの概念です。Maya などの 3D エフェクト パッケージの中には、動作に必要なプロパティが既に準備された状態で作成されているものもあります。ユーザーは希望する結果を得るために、これらのプロパティを後から変更することができます。

一方カスケードでは、パーティクル システムは _必要最小限の_ プロパティやいくつかの動作のモジュールのみで起動します。

それぞれのモジュールはパーティクルの動作の特定の特性を表しており、カラー、生成や移動、スケーリング位置など、その動作を制御するプロパティのみを保有します。ユーザーはモジュールの追加や削除による調整ができ、調整結果がパーティクルの動作として定義されます。必要な動作のモジュールのみ追加するので、不要なプロパティのために無駄な計算をする必要がありません。

特に、モジュールは、追加、削除、コピー、さらにはパーティクル システム内のエミッタからのインスタンス化までもが簡単に行えるので、利用可能なモジュールに慣れてしまえば、複雑なステップも簡単にこなせます。



### デフォルトのモジュール

![DefaultEmitter.png](DefaultEmitter.png)(convert:false)

[INCLUDE:#Modules]


[COMMENT:none]

[EXCERPT:Modules]
モジュールの中には、パーティクル エミッタ上にデフォルトで存在するものもあります。全てのパーティクル システムの主要コンポーネントであるスプライト エミッタがパーティクル システムに追加される場合は常に、以下の **デフォルト** モジュールで作成されます。

* **Required** - パーティクルに適用するマテリアル、エミッタのパーティクル放出時間、パーティクル システムに絶対に必要な各種プロパティを含みます。
* **Spawn** - パーティクルがエミッタからスポーンする速度、一気にスポーンするのか、パーティクルの生成タイミングに関連するプロパティがあるのかを制御するモジュールです。
* **Lifetime** - 各パーティクルが生成後に生存する期間を管理します。このモジュールがなければ、パーティクルは永遠に生存します。
* **Initial Size** - 生成する瞬間のパーティクルのスケールを制御します。
* **Initial Velocity** - - 生成する瞬間のパーティクルの動きを制御します。
* **Color Over Life** - 生存期間における各パーティクルの色の変化を制御するモジュールです。
[/EXCERPT:Modules]

[/COMMENT]

[REGION:note]
	*Required* と *Spawn* モジュールは永続的で、エミッタから削除することはできません。ただし、他のすべてのモジュールは自由自在に削除することができます。
[/REGION]


### モジュールのカテゴリ

パーティクル エミッタには様々なモジュールを追加することができます。混乱しないように、モジュールをカテゴリに分類しました。以下になります。

| カテゴリ | 説明 |
| --- | --- |
| **Acceleration** | 牽引力など、パーティクルの加速への影響を管理するモジュールです。 |
| **Attraction** | パーティクルを空間の様々な位置に引き寄せてパーティクルの動きを制御するモジュールです。|
| **Camera** | カメラ空間でのパーティクルの動きを制御するモジュールで、ユーザーはカメラに近づけたり遠ざけたりすることができます。|
| **Collision** | パーティクルとジオメトリ間のコリジョンの処理方法を制御するモジュールです。 |
| **Color** | パーティクルのカラーに影響するモジュールです。 |
| **Event** | パーティクル イベントのトリガーを制御するモジュールで、各種インゲーム レスポンスを順番に返すことができます。 |
| **Kill** | パーティクルの削除を管理するモジュールです。 |
| **Lifetime** | パーティクルの存在期間を制御するモジュールです。 |
| **Light** | パーティクルのライトを管理するモジュールです。 |
| **Location** | エミッタ アクタの位置と相対してパーティクルが生成される場所を制御するモジュールです。 |
| **Material** | パーティクル自体に適用されるマテリアルを制御するモジュールです。 |
| **Orbit** | 画面空間の軌道上での動作を可能にし、エフェクトへモーションを追加するモジュールです。 |
| **Orientation** | パーティクルの回転軸のロックを可能にするモジュールです。 |
| **Parameter** | ブループリントやマチネなど外部ソース経由でのパラメータ化や制御が可能なモジュールです。 |
| **Rotation** | パーティクルの回転を制御するモジュールです。 |
| **RotationRate** | スピンなど、回転速度の変更を管理するモジュールです。 |
| **Size** | パーティクルのスケールを管理するモジュールです。 |
| **Spawn** | 移動距離に基づいたパーティクルのスポーンなど、特定のパーティクル スポーン レートを追加するモジュールです。 |
| **SubUV** | アニメートされたスプライト シートをパーティクル上に表示させるモジュールです。 |
| **Velocity** | 各パーティクルの速度を制御するモジュールです。 |


個別のパーティクル モジュールに関する詳細については、[パーティクル モジュール リファレンス](Engine/Rendering/ParticleSystems/Reference/) を必ず確認してください。

### Initial vs.Over Life

パーティクル モジュールで作業する時にしっかり覚えておいて頂きたい重要な概念が 2 つあります。1 つが *initial* プロパティで、もう 1 つが *over life* または *per life* プロパティです。

* **Initial** モジュールは、ワールドにスポーンされた瞬間のパーティクルの特性の制御に使用します。
* **Over Life** または **Per Life** モジュールは、パーティクルの特性を生存期間中に変更するためのモジュールです。

例えば、*Initial Color* モジュールでパーティクルの生成時にモジュールのカラーを設定できます。一方、*Color Over Life* プロパティでは生成時および機能停止時 (デス時) の間、パーティクルのカラーを徐々に変更することが可能です。

### モジュールの時間計算

プロパティを時間経過と共に変化するディストリビューション タイプに変更すると、モジュールによって「相対時間」を用いるものと、「絶対時間」を用いるものがあります (ディストリビューションについては下記を参照)。


* 基本的に、絶対時間は含まれているエミッタの時間です。エミッタに 2 秒のループが 3 回設定されている場合、そのエミッタ内のモジュールには、絶対時間が 0 から 2 秒まで 3 回実行されます。 

* 相対時間は、各パーティクルの存続期間を示す 0 から 1 までの時間です。


現在使用可能なモジュールの説明は [パーティクル システムのリファレンス](Engine/Rendering/ParticleSystems/Reference) でご覧いただけます。



## エミッタ、パーティクル システム、エミッタ アクタ

カスケードを使ってパーティクル エフェクトを作成する場合、1 つのオブジェクトと他のオブジェクトとの関係性を覚えておくことが重要です。本ドキュメントでは既にモジュールの概念について説明しましたが、モジュールはパーティクル エフェクト全体を構成する 1 コンポーネントにすぎません。つまり、パーティクル システムのコンポーネントは、モジュール、 エミッタ、パーティクル システム、エミッタ アクタ となります。それぞれのコンポーネントの相関は、以下のように覚えると確実です。

* **モジュール** はパーティクルの動作を定義し、場所は・・・にあります。
* **エミッタ** は、エフェクト用の特定のパーティクル タイプを放出するために使用し、数に制限なく・・・に置くことができます。
* **パーティクル システム** は、**コンテンツ ブラウザ** で利用できるアセットで、・・・から順々に参照することができます。
* **エミッタ アクタ** は、レベル内に存在する配置可能なオブジェクトで、シーン内でのパーティクルの使用場所、使用方法を制御します。


## パーティクルの計算

パーティクル システムで作業する場合、計算順序に注意することが重要です。カスケード エミッタ リスト領域の各カラムには別のエミッタが表示され、カラムの各ブロックには別のモジュールが表示されます。計算は以下の順序で実施されます。

* エミッタは、エミッタ リストの左から右へ計算されます。
* モジュールは、スタックの上から下へ計算されます。



## エミッタ タイプ

パーティクルを使って作成したいエフェクト タイプの種類が幅広いように、エミッタ タイプにも様々な種類が利用できるので、まさに必要とするタイプを作成した場合に便利です。利用可能なエミッタ タイプは以下の通りです。

タイプに関係なく、エミッタはすべて、最初はスプライト エミッタであることに注意してください。後から各種エミッタ *Type Data* モジュールをエミッタに追加して別のタイプに変更します。 

* **Sprite Emitters** - 最も基本的なエミッタ タイプで、一番よく使用されます。パーティクルは、常にカメラ方向を向く多角形スプライト (2 つのポリゴンをもつカード) として放出されます。煙、炎、他の幅広いエフェクトで役立ちます。

* **AnimTrail Data** - アニメートされたスケルトンのソケットからトレイルを作成するために使用します。

* **Beam Data** - レーザー、稲妻のストリーク、あるいは同類のエフェクトなどビームの作成に使用します。

* **GPU Sprites** - 実行時間の計算の大部分が GPU に渡される特別なパーティクル タイプです。これにより、数千から *数十万* の CPU パーティクルをもつ莫大な数のパーティクルが起動されます。数はターゲット システムの GPU のタイプにより異なります。

* **Mesh Data** - 一連のスプライトを放出する代わりに、多角形メッシュを放出するタイプのエミッタです。岩崩れ、残骸などのエフェクトに最適です。

* **Ribbon Data** - 端から端まで適用するパーティクルのストリングを生成して、移動するエミッタの後をトレイルするリボンの形成します。


利用可能なエミッタのタイプに関しては、 [エミッタのタイプのページ](Engine/Rendering/ParticleSystems/Reference) をご覧ください。


## パラメータ

パーティクル システムの特性はそのすべてを事前に定義できるわけではありません。時として、パーティクル システムの動作の中に実行時の制御や変更が必要な部分もあります。例えば、魔法がかけられた時、消費した魔力の量に応じてカラーを変える魔法エフェクトも作成できます。この場合、パーティクル システムにパラメータを追加する必要があります。

*parameter* は、ブループリント、マチネ、マテリアル、その他さまざまなソースなどの他のシステムとのデータのやり取りが可能なプロパティのタイプです。カスケードでは、どんなプロパティにもパラメータを割り当てることができるので、パーティクル システム外からプロパティを制御することが可能です。

例えば、炎のエフェクトに対してスポーン レートを制御するパラメータを設定することで、プレイヤーは実行時に放出される炎の量を増減できるようになります。

逆に、特定のマテリアルに使用するカラーなどレベル内の他のものを操作できるパーティクル システムにパラメータ モジュールを追加することもできます。

カスケードでは、パラメータの作成方法として、通常 Distributions (ディストリビューション)、つまりプロパティ内のデータを処理する方法を使用します。Distributions の概要については以下の [ディストリビューション](#Distributions（ディストリビューション）)、または [ディストリビューションのページ](Engine/Basics/Distributions) の詳細をご覧ください。

## Lit (ライティング有り) パーティクル

パーティクル システムでライトを受け取る設定ができますが、特別な設定が必要です。

Lit パーティクルの設定方法：


1. マテリアルが unlit 以外のシェーディング モデルを使用していることを確認してください。DefaultLit を使用すると、法線マップ、スペキュラリティ （鏡面反射性）などへアクセスできます。
1. カスケードの LODSettings (モジュールおよびエミッタが何も選択されていないと表示される LOD プロパティの中にあります) には、bLit と呼ばれる LOD 別のフラグがあります。このフラグを必ず選択してください。このフラグはカスケード内でしか更新することができません。


この手順に従えば、ご自分のパーティクルが lit としてゲーム中に表示されるはずです。これらはエミッタ基点から光を発しているので、ワールド内で基点を動かして光源が変わるか確認する、または動的ライトをそばでスポーンしてみてください。


##詳細度 (LOD)

パーティクル システムは計算コストがすぐに高くなります。パーティクル計算の大部分を GPU にオフロード処理するGPU パーティクルを使用したとしても、プレイヤーが遠すぎて見えなかったり正しく認識できないパーティクルから算出した値を考慮することは重要です。

例えば、キャンプ ファイアーのパーティクル システムを考えてください。近くで見ると、燃えさしと火花が煙の中へ立ち上っていくのが見えます。しかしながら、数百メートル離れて見ると、その燃えさしが小さすぎてモニターや画面はレンダリングすらできません。ではなぜ計算をするのでしょうか？

ここで詳細度 (LOD) が関わってきます。パーティクル システムが自動的に簡素化するカスタム距離範囲を LOD システムで設定できます。各範囲ではもう 1 つ LOD が構成されます。プロパティ値の低いものから非アクティブのモジュール、非アクティブのエミッタという順序で簡素化されていきます。上記のキャンプファイアーの例で言えば、プレイヤーが遠すぎて見えなくなったら、エフェクト全体に火花を追加したエミッタを完全に非アクティブにするのが理想的です。

パーティクル システムでは好きなだけ LOD を構成し、各 LOD の範囲を手動で制御できます。

## Distributions（ディストリビューション）

Distributions は、値に対して範囲を使用したり、カーブに沿って値を補間するなど、特定の方法によるデータ処理の対象になるデータ タイプです。ランダム化やパーティクルのある特性を時間経過と共に変化する能力がパーティクル システムから要求された時に、そのプロパティを制御するためディストリビューションを使用します。

カスケード内のモジュールにあるほとんどのプロパティに、様々なディストリビューションを適用できます。そのプロパティの実際の値を後にディストリビューション内に設定します。

ディストリビューションのタイプは主に 5 種類あります。

* **Constant** - 絶対に変化しない 1 つの静的な値を指定します。
* **Uniform** - 最低値と最高値を提供し、この 2 つの値の間からランダムに選択した値を出力します。
* **Constant Curve** - 時間経過と共に値が補間する 1 つのカーブを提供します。この場合、通常時間とは、パーティクルの生成から機能停止までの期間、あるいはパーティクル エミッションの開始から停止までの時間を指しします。
* **Uniform Curve** - 最低カーブと最高カーブを提供します。最終値は、グラフにおいてこの 2 つのカーブの間にある点から選択されます。
* **Parameter** - プロパティをパラメータ化できるディストリビューションのタイプなので、ブループリント、マチネなど外部から操作することができます。

[REGION:note]
	上記のディストリビューション タイプは、データ タイプ値に対して Float ディストリビューションと Vector ディストリビューションが別々に存在します。例えば、Float Uniform Curve と Vector Uniform Curve ディストリビューションの両方が存在します。しかし、それぞれのディストリビューションで float 型を使うか vector 型を使うかは制御中のプロパティ タイプ次第で、ユーザーは選択できません。例を挙げれば、Vector Uniform ディストリビューションでカラー (vector 値で RGB) を制御する一方で、Float Uniform ディストリビューションでは Lifespan (1 つの float 値) を制御します。
[/REGION]


ディストリビューションおよびディストリビューションの機能については [ディストリビューションのページ](Engine/Basics/Distributions) をご覧ください。
