INTSourceChangelist:3474032
Availability:Public
Crumbs: %ROOT%
Title:블렌더블
Description:Blendable, 블렌더블은 부드러운 보간에 사용되는 애셋으로, 포스트 프로세싱, 포그, 앰비언트 큐브맵, 앰비언트 오클루전 등 렌더링에 영향을 끼치는 데 사용됩니다.
Type: Overview
SkillLevel:Beginner
Version:4.16
Parent:Engine/Rendering/PostProcessEffects
Order:3
Tags:Post Process
Topic-image:Blendables_topic.png

[EXCERPT:Blendables_Desc]
**Blendable** (블렌더블)은 다른 블렌더블과 부드럽게 보간(블렌딩)시킬 수 있는 프로퍼티를 가진 애셋입니다. 블렌더블은 거의 포스트프로세스 머티리얼에 사용하지만, 
이 시스템은 뷰에 (보통 카메라 위치에) 의존하는 것이면 어디에든 사용 가능합니다.
[/EXCERPT:Blendables_Desc]


## 블렌더블

이전에도 엔진에 **Blendable** (블렌더블)이 있었던 적이 있었지만, 포스트프로세스 머티리얼 / 포스트프로세스 머티리얼 인스턴스에만 사용했었습니다. 하지만 그 개념을 좀 더 일반화시켜 임의의 (최적은 선형 또는 컬러) 값을 
어떤 최종 데이터로 블렌딩하는 것이 가능해졌습니다. 어느 서브시스템에서도 뷰의 데이터를 집어들어 렌더링에 영향을 끼칠 수 있습니다. 데이터는 뷰마다 블렌딩되므로 
분할화면에서는 각 뷰마다 (피격 알림이 포스트 프로세스에 영향을 끼친다든가) 각기 다른 세팅의 블렌딩이 가능합니다.

**블렌더블** 은 IBlendableInterface 를 갖는 오브젝트로, 현재 다음과 같은 애셋 유형에 구현되어 있습니다:
* 포스트프로세스 머티리얼 PostprocessMaterials (todo: link)
* 포스트프로세스 머티리얼 인스턴스 PostprocessMaterialInstances (todo: link)
* 라이트 프로퍼게이션 볼륨 블렌더블 LightPropagationVolumeBlendable (아래 참고)

**블렌더블** 컨테이너는 PostProcessSettings 에서 찾을 수 있으며, 다음 오브젝트에 포함되어 있습니다:
* 포스트 프로세스 볼륨 PostProcessVolume
* 포스트 프로세스 컴포넌트 PostProcessComponent
* 씬 캡처 액터 SceneCaptureActor
* 카메라 컴포넌트 CameraComponent

**LightPropagationVolumeBlendable** 애셋은 새 블렌더블을 만드는 방법과 기존 포스트 프로세스 세팅을 덮어쓰는 방법에 대한 데모로 만든 것입니다. 기존 시스템은 
규모가 작을 때는 잘 돌아갔지만, 세팅 규모가 커지자 좀 더 세련된 시스템의 필요성이 대두되었습니다.

[REGION:imagetable]
| ![](CreateBlendableAsset.png) |
| ------ |
| 블렌더블 애셋은 콘텐츠 브라우저의 **Blendable** 카테고리에 나타납니다. 이 카테고리에서 **신규 추가** 또는 애셋 필터링이 가능합니다. |
[/REGION]

새로운 시스템의 장점:
* 엔진 확장 및 변경사항 유지가 용이합니다 (하나의 중심 구조체를 변경할 필요 없이 별도의 모듈 안에 있을 수 있습니다).
* 패키지에 대한 인디렉션으로 레벨 접근(버전 컨트롤) 없이 콘텐츠 조절이 가능합니다.
* 인디렉션(indirection)이란 하나의 애셋을 여러 곳에 재사용할 수 있다는 뜻입니다 (중복 감소, 성능 증가).
* 각 블렌더블에 대한 커스텀 UI 가 가능합니다 (단일 구조체로는 훨씬 힘듭니다).
* 각 블렌더블 레퍼런스는 별도의 웨이트(weight, 가중치)를 가질 수 있으며, 애셋도 웨이트를 가질 수 있고 (LightPropagationVolumeBlendable 참고) 프로퍼티별 웨이트도 쉽게 가능합니다.
* 거다란 구조체를 분해하여 블루프린트와의 상호작용이 단순해져 효율이 높아집니다.

## 블렌더블 컨테이너

컨테이너는 웨이트 배열 및 IBlendableInterface 레퍼런스로 구현됩니다.

포스트 프로세스 볼륨 세팅을 열고 블렌더블 배열을 보면, 블렌더블 애셋으로의 레퍼런스 포함 웨이트 배열이 보입니다. 웨이트는 보통 0..1 범위로,
패키지 안에 있는 (콘텐츠 브라우저로 생성한) 애셋 또는 블렌더블 배열이 들어있는 오브젝트 안에 있는 애셋으로의 레퍼런스가 가능합니다.

[REGION:imagetable]
| ![](BlendablesUI.png) |
| ------ |
| 블렌더블 컨테이너는 포스트 프로세스 세팅에서 (여기 포스트프로세스 볼륨에서) 찾을 수 있습니다. 여기 배열에는 세 가지 엘리먼트가 있는데, (볼륨 오브젝트에 있는) LightPropagationVolumeBlendable, 아직 사용되지 않는 배열 엘리먼트, LPV0 이라 불리는 (패키지에 있는) 애셋으로의 레퍼런스 입니다. 웨이트는 두 블렌더블 모두 1.0 입니다. |
[/REGION]

배열에 엘리먼트를 새로 만들 때, 특정 유형(현재는 오직 LightPropagationVolumeBlendable)의 블렌더블을 만들거나, 
(LightPropagationVolumeBlendable, Material, Material Instance 등의) 애셋 레퍼런스를 사용하도록 선택할 수 있습니다. 서서히 만들 수 있는 블렌더블 유형을 (Bloom, SceneColor, DepthOfField 등) 늘려갈 계획입니다. 
레퍼런스는 블렌더블인 (블렌딩 가능한, 즉 IBlendableInterface 를 구현하는) 어떤 유형도 가능합니다. 배열 내 순서는 레이어가 쌓이는 순서와 반대인데, 그 블렌딩은 위에서 아래로 적용되며, 
기존의 데이터를 덮어쓰기 때문입니다. 다수의 볼륨 (또는 오브젝트)의 데이터는 가중치와 우선권을 고려하여 합쳐진다는 점 유념하시기 바랍니다.

주: 레벨에 "global" 이라는 낮은 우선권의 바인딩되지 않은 PostProcessVolume 을 만들어 두는 것이 좋습니다. 기존 레벨을 완벽히 제어하려면, 높은 우선권의 바인딩되지 않은 볼륨을 
추가해 주면 됩니다. 블렌더블 효과가 나는지 확인하기 위해서는, 간단히 웨이트를 0 으로 바꿔보고 돌려놓으면 됩니다.

## 패키지 내, 볼륨같은 오브젝트의 일부 또는 블루프린트에서 동적으로 생성한 블렌더블

선택은 자유지만 패키지( 안의 네임드 애셋으로의 레퍼런스)를 활용하는 것이 좋은데, 그래야 나중에 대량 조정 작업을 할 때도 버전 컨트롤 충돌이 최소화되어 수월하기 때문입니다.
프로그래밍을 최대한 활용하기 위해, 블루프린트에서 블렌더블을 만드는 것이 가능합니다. 블루프린트는 일종의 프로그래밍 형태이므로, 세팅을 UI 에 넣고 코드에 하드코딩하는 것과 비슷합니다.
코드를 통한 방법은 좀 더 복잡하며, 다른 세팅 트윅 작업도 힘들어집니다.

[REGION:imagetable]
| ![](AssetWithDifferentOuter.png) |
| ------ |
| LightPropagationVolumeBlendable 은 에디터에서 보이는 것처럼 디테일합니다. 블렌더블을 콘텐츠 브라우저에서 만들었든 (왼쪽), 오브젝트(포스트 프로세스 볼륨 등)에서 만들었든, 유저 인터페이스는 비슷합니다. 각 프로퍼티에 (웨이트를 0 또는 1 로 설정하는) 체크박스를 만들고 전체 구조체에 블렌드 웨이트를 주는 것도 좋습니다. |
[/REGION]

주: LightPropagationVolumeBlendable 프로퍼티는 하위 호환성을 위해 PostProcessSettings 에 여전히 존재합니다만, 앞으로 제거할 계획이며 블렌더블만 유일한 방법으로 만들 것입니다.

## 자체 블렌더블 만드는 법 (C++)

현재는 LightPropagationVolumeBlendable 플러그인을 복사할 것을 제안합니다. 애셋을 만든 이후에는 라이트 프로퍼게이션 볼륨이 했던 것과 똑같은 방식으로 블렌더블 데이터를 집어들면 됩니다.
**GetSingleFinalDataConst()** 메서드를 사용해서 블렌딩 이후의 데이터를 구합니다. 최적의 퍼포먼스를 위해서는 이 함수를 불필요하게 (너무 자주) 호출하지 않는 것이 좋습니다.

## 블루프린트

**AddOrUpdateBlendable** 블루프린트 함수는 PostProcessSettings 를 찾을 수 있는 곳에 노출되어 있어, 블렌더블 컨테이너에 편하게 접근할 수 있도록 해줍니다. 블렌더블 컨테이너를 갖는 오브젝트에 
전달하는 것은 블렌더블에 대한 웨이트와 레퍼런스입니다. 컨테이너에서 이미 레퍼런스를 찾은 경우 단순히 웨이트를 업데이트합니다. 컨테이너 엘리먼트를 제거하지는 않는데, 
컨테이너를 탐색하는 다른 코드에 혼동을 주고 가비지 컬렉션에 악영향을 끼칠 수 있기 때문입니다. 웨이트가 0 인 블렌더블 레퍼런스에 실질적인 퍼포먼스 비용은 없는데, 
엘리먼트 제거가 필요치 않기 때문입니다.

콘텐츠 브라우저에서 블렌더블 애셋을 참조하는 방법은 이렇습니다:

[REGION:imagetable]
| ![](AddBlendableVar.png) |
| ------ |
| LightPropagationVolumeBlendable (오브젝트 레퍼런스) 유형의 'BlendableVar' 변수를 사용해서 'LPV0' 이라는 LightPropagationVolumeBlendable 애셋을 참조했습니다. |
[/REGION]

**ConstructObjectFromClass** 블루프린트 함수로 블루프린트에 새 블렌더블을 만들 수 있습니다. 새 오브젝트의 **Outer** 를 블렌더블 컨테이너가 있는 오브젝트로 설정하면,
UI 에 오브젝트를 만드는 것과 똑같은 (오브젝트의 일부분으로써 블렌더블을 만드는) 작동방식을 낼 수 있습니다.

[REGION:imagetable]
| ![](AddBlendableConstruct.png) |
| ------ |
| 여기서는 LightpropagationVolumeBlendable 유형의 오브젝트를 만들고, 세팅을 구한 뒤, **SetMembersIn...** 함수로 몇몇 멤버를 설정하고 있습니다. |
[/REGION]

주: 현재 플래그를 수동으로 true 설정(체크박스를 체크)해 줘야 하며, 그렇지 않으면 같은 이름의 프로퍼티가 선택되지 않을 것입니다.

실험을 위해 **VisualizeLPV** (에디터에서 시각화/Light Propagation Volume) 표시 플래그를 사용해서 블렌더블 프로퍼티를 표시해 볼 수 있습니다.
이는 C++ 코드로 이 블렌더블 유형에 대해서만 구현되어 있으나, 나중에 코드 변경할 필요 없이 어떤 프로퍼티든 노출시킬 수 있도록 하겠습니다.

[REGION:imagetable]
| ![](VisualizeLPV.png) |
| ------ |
| **VisualizeLPV** 표시 플래그에 블렌더블 값이 표시되어 디버깅에 유용해집니다. |
[/REGION]


## 앞으로
* AddOrUpdateBlendable 함수 탐색시의 컨텍스트에 따라 기능이 아직 작동하지 않습니다 (우회법: '컨텍스트에 따라' 옵션을 해제합니다).
* 모든 PostprocessSettings 를 LightPropagationVolumeBlendable 처럼 분해할 것이므로, 언젠가 PostProcessSettings 는 제거될 수도 있습니다. 이전 레벨은 로드시 데이터 손실 없이 변환 가능합니다.
다수의 오브젝트로 콘텐츠에 스팸이 되는 경우를 피하기 위해, 오브젝트를 레벨의 일부분으로 만들 것입니다.
* 블루프린트 상호작용을 더욱 가다듬어 쓰기 편하게 만들고자 합니다.
* 월드 세팅과 프로젝트 세팅에도 블렌더블 배열을 쉽게 노출시킬 수 있습니다.
* 어느 블렌더블이 적용되는지 좀 더 투명성 제고를 위해 애셋/오브젝트 이름과 유형 및 웨이트를 표시하는 디버그 뷰가 있었으면 좋겠습니다.


