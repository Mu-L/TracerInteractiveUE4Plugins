INTSourceChangelist:3782314
Availability:Public
Crumbs:
Title:ポストプロセス マテリアル
Description:マテリアル エディタでカスタム ポストプロセスを作成しブレンドする方法 
Type:reference
Version:4.16
Parent:Engine/Rendering/PostProcessEffects
Order:8
Tags:Post Process
Topic-image:PPMaterials_Topic.png

[TOC(start:2 end:4)]

[REGION:banner]
![](Teaser_Banner.png)
[/REGION]

[COMMENT:none]
-
![](Teaser3.png)
![](Teaser0.png)
![](Teaser1.png)
![](Teaser2.png)

[/COMMENT]


ポストプロセス マテリアルは、ポストプロセスで使用できるマテリアルのセットアップを使用して、広域効果のビジュアル スクリーン エフェクトを作成したり、
ポストプロセス マテリアルを介してのみ利用できるゲームの全体的な雰囲気を作り出すことができます。 

ここでは、様々なバッファ、複数のポストプロセス マテリアルをブレンドするなどして
独自のポストプロセス マテリアルの設定例を見てみましょう。 

## ポストプロセス グラフ

[EXCERPT:PostProcessMaterials_Desc]
アンリアル エンジンにはポストプロセス ノードのグラフに基づいた複雑なポストプロセスがあります。**ポストプロセス マテリアル** は
特定の位置に追加で挿入することができます。すべてのグラフでダンプされた内容を確認するには [以下のFAQ に掲載した](#FAQ) **r.CompositionGraphDebug** を参照してください。
グラフはポストプロセス処理のみではなく、ライティングの一部も処理しています。 
[/EXCERPT:PostProcessMaterials_Desc]

ほとんどの場合、グラフは中間レンダリング ターゲットを自動作成します。つまりその前の色とブレンドしたい場合、
(PostProcessInput0 からの入力を使って) シェーダーでブレンドする必要があります。

[EXCERPT:PostMatWarning]
[REGION:warning]
ポストプロセス マテリアルは、必要な場合に限り注意して使用してください。色補正や調整、ブルーム、被写界深度や他の様々なエフェクトに対しては、可能な限り最適化がされていてより効率的な Post Process ボリュームに継承された設定を使うようにしてください。 
[/REGION]
[/EXCERPT:PostMatWarning]

## ポストプロセス マテリアルの使用

ポストプロセス設定 (通常はポストプロセスボリュームまたはカメラ設定で定義) を使って、いわゆるブレンド可能なアセットをブレンドすることができます。
現時点でブレンド可能なアセットは、**マテリアル** と **マテリアルインスタンス** のみです。アンリアル エンジンにはいくつかのポストプロセス マテリアルがありますが、
プログラマーの支援なしに独自の **カスタム仕様のポストプロセス** を作成することができます。

1 つ以上のポストプロセス マテリアルを **[Blendables]** セクションのポストプロセス ボリュームへ割り当てます。まず **[＋]** キーを押して新スロットを追加し、
**コンテンツ ブラウザ** でマテリアルを選択して左矢印キーで割り当てます。順序はここでは重要ではなく、未使用のスロットは無視されます。

![](PostProcessSettings.png)

## 簡単なポストプロセス マテリアルの作成

ゼロからポストプロセス マテリアルのエフェクト作成概要については、[](Engine/Rendering/PostProcessEffects/PostProcessMaterials/PostProcessDemoMaterialOverview) をご覧ください。

![](Engine/Rendering/PostProcessEffects/PostProcessMaterials/PostProcessDemoMaterialOverview/FinalPostEffect.png)(w:640)

##ポストプロセス マテリアルの重要な設定

ポストプロセス マテリアルではマテリアル ドメインで **[Post Process (ポストプロセス)]** を指定する必要があります。

![](DomainPostProcess.png)

このマテリアルでは新しい色の出力に **EmissiveColor ** のみを使用するようにします。さらに、ポストプロセス処理中でこのパスを適用するタイミングを定義することが可能であり、
複数の場合は処理順序 (優先順位) を定義することができます。

![](PostProcessMaterialProps.png)


| ブレンド可能な位置| 説明 |
| -------- | ----------- |
| **Before Tonemapping (トーンマッピングの前)** | PostProcessInput0 は、HDR (ハイダイナミック レンジ) で最大限のライティングでシーンの色を提供します。 これを使用して Temporal AA や GBuffer ルックアップ (例、深度や法線) の問題を修正します。|
| **After Tonemapping** | 色が LDR (ローダイナミック レンジ) 時の好ましい位置で、より低い精度と少ない帯域幅を必要とします。これはトーンマッピングとカラーグレーディングの後です。|
| **Before Translucency** | これはパイプライン内で 'Before Tonemapping' より早く、透過がシーンカラーと組み合わさる前になります。SeparateTranslucency (別々の透過) が、法線透過より後に合成されることに注意してください。 |
| **Replacing the Tonemapper** | PostProcessInput0 は HDR シーンカラー、PostProcessInput1 は SeparateTranslucency (アルファはマスクです) を提供し、PostprocessInput2 には解像度の低いブルーム入力が付いています。 |

通常のポストプロセスの入力は、前のパスから入ってきます。**PostProcessInput0** を使用する場合、 SceneTexture マテリアル式かから色にアクセスできます。SceneColor を使用した場合、適切な結果が得られないことがあります。

## 異なるマテリアル インスタンスのブレンド

[ポストプロセス マテリアルの使用](#ポストプロセスマテリアルの使用)

ポストプロセス ボリュームでは、複数のポストプロセス マテリアル間で滑らかな遷移を簡単に設定することができます。ここでは「Unbound」にマークが付けられ、より大きなブレンド半径を持つボリュームを使用しています (例えば 1000)。

[REGION:imagetable]
| ![](BlendingAVolume.png) | ![](BlendingAVolume1.png) |
|----|----|
| Unbound に設定したポストプロセス | ボリュームを結合するポストプロセス |
[/REGION]

各ボリュームで同一マテリアルの異なるマテリアル インスタンスを指定します。色はこの 2 つのマテリアル インスタンスに対して違う設定ができるマテリアル パラメータとして指定されます。

[REGION:lightbox]
![](PP_BlendedMaterial.png)
[/REGION]

[REGION:imagetable]
| ![](BlendMatInst1.png)(w:400) | ![](BlendMatInst2.png)(w:400) |
|----|----|
| 赤のマテリアル インスタンス | 緑のマテリアル インスタンス |  
[/REGION]

Blend Radius が以下の範囲内の場合、カメラ位置に合わせてボリューム設定が使用されてブレンドされます。

[REGION:imagetable]
| ![](Blend1.png)(w:300) | ![](Blend2.png)(w:300) | ![](Blend3.png)(w:300) |
|----|----|----|
| Unbound Post Process Volume Material Instance (RED) を 0.75 に設定 | Blend Radius が 1000  | Post Process Volume Material Instance (GREEN) を 0.75 に設定 |  
[/REGION]


[COMMENT:none]
-
[OBJECT:ComparisonSlider]
	[PARAM:before]
	![Green vignette material instance](VignetteG.png)(w:450)
	[/PARAM]
	[PARAM:after]
	![Red vignette material instance](VignetteR.png)(w:450)
	[/PARAM]
[/OBJECT]
-
[/COMMENT]

カメラがの移動を介して、2 つのエフェクト設定をスムーズに順番に切り替えることができます。

2 つのボリュームを持つレベルを上から見ると、以下のような図になります。境界をもたない大きなボリュームは赤のマテリアル インスタンス、小さなボリュームは緑のマテリアル インスタンスを持ち、ブレンド可能になっています。
小さなボリュームは優先度が高くなります。マテリアルのパラメータはカメラ位置に応じてブレンドされます。
かすかな境界部分は、ボリュームによって指定される BlendRadius プロパティで定義され、ボリュームの形状を拡張します。

正しくセットアップすると、すべてのブレンドは期待通りに行われます。

[OBJECT:ComparisonSlider]
	[PARAM:before]
	![Bad Setup](VolumeBlendBad.png)(w:450)
	[/PARAM]
	[PARAM:after]
	![Good Setup](VolumeBlendGood.png)(w:450)
	[/PARAM]
[/OBJECT]


この 2 つの構成の違いは、マテリアル (スカラーまたはベクター) のパラメータで指定するデフォルト値です。 
良い構成では、パスが何もエフェクトを持たないかのように見える値になっています (例えば白に乗算、または 0 で線形補間)。

**この 2 つの構成から分かること：** カメラがいずれかのボリュームの影響範囲外にあるとポストプロセスのパスはレンダリングされません (グレイのグリッドに視覚化)。
いずれかのボリュームの影響範囲内にあると、正しいブレンドが表示されます。

**悪い構成 :** カメラが影響半径に入る時の遷移がぎこちなく見える理由は、デフォルト パラメータを誤って指定したからです。

**良い構成 :** カメラに影響半径が入る遷移がうまく隠されていて、ボリュームの色がの遷移がスムーズになります。

[REGION:note]
すべてのマテリアル インスタンスのプロパティは、プロパティのチェックボックスのチェック状況に関係なくブレンドされます
(チェックが入っていなければ、親からのプロパティをブレンドします)。チェックされていないプロパティは何のエフェクトも持たないという点で、ポストプロセス設定とは異なります。
つまり、マテリアル インスタンスをブレンドすると、すべてのプロパティがブレンドされます。
[/REGION]

## SceneTexture マテリアル式

**SceneTexture*** マテリアル式をマテリアルに追加して、式プロパティで参照するテクスチャを選択します。

![](SceneTextureProps.png)

以下のように、ノードには任意の入力値と複数の出力値があります。 

![](SceneTextureExpression.png)

**UV** 入力値で、テクスチャ ルックアップ位置を指定することができます (Color 出力値のみに使用)。
Color 出力値は 4 チャンネル出力 (実際のチャンネル割り当てはシーンテクスチャ ID に依存します) です。**Size** は、テクスチャの幅と高さを持つ
2 コンポーネントのベクターです。この逆数 (1/幅、1/高さ) は、 **InvSize** 出力値で有効です。以下の例のように、
隣接するサンプルの参照に便利です。

![](DepthNextTo.png)

このマテリアル式は、現ピクセルと隣接するピクセルとの深度の違いを計算します (例、In = 0,1 で、下のピクセルへデルタ値を返します)。

## GBuffer プロパティの使用

GBuffer は、シェーディングの計算 (ライトとマテリアルの相互処理方法) にマテリアルを格納する複数のテクスチャ (例えばサブサーフェス / スペキュラカラー、ラフネスなど) や、
シェーディングを計算 (ライトがマテリアルとどのように相互作用するか) します。ディファード レンダラーでは、最初に GBuffer をレンダリングしてから GBuffer 属性と一緒に
すべてのライティング (ディファード) を計算します。UE4 でディファード シェーディング パスを使用する場合 (例、DirectX 11またはハイエンドの OpenGL)、ポスト プロセス処理中にこれらのバッファへアクセスすることができます。

アンチエイリアス処理の場合は、GBuffer ピクセル / テクセルが出力ピクセルと 1：1 で関連付けられなくなるため、アクセスしずらくなります (以下のセクション参照)。

## CustomDepth

オブジェクトを別の深度バッファ (カスタム深度バッファ) でレンダリングすると、そのオブジェクトをマスクすることができる独立した機能です。
ドローコールは増えますが、マテリアルは追加しません。深度のみを出力するため、レンダリングは比較的低負荷です。この機能はメッシュで有効にすることができます
(例えば、スタティックメッシュプロパティやレンダリングのカスタム深度):

![](CustomDepth.png)

以下のシーンでは 2 つのオブジェクトでこの機能を有効にしていますが、ポストプロセス パスがコンテンツを視覚化しないので、この機能は不可視のままです。

![](scene.png)

以下は CustomDepth を視覚化したものになります。

![](sceneCustomDepth.png)

視覚化のために使用したマテリアルです。

![](CustomDepthMat.png)

## CustomDepth Stencil

Custom Depth Stencil (カスタム デプス ステンシル) は、ステンシル (別名カットアウト) を使用することができるレンダリングされたオブジェクトの Custom Depth の拡張で、 
オクルードされたオブジェクトを視覚化したり、オブジェクトの輪郭を描画したり、特定の角度でのみ見えるようにするなど、視覚的に面白い作業をすることができます。シーンのアクタのステンシルへのアクセスがあると、
いろいろなことができるようになります。ステンシル値を有効にして割り当てるには、以下の設定を使用します。

![](CustomStencilSettings.png)

このシーンでは、3 つのオブジェクトで Custom Depth を有効にし、それぞれに **Custom Depth Stencil Value** を設定しましたが、コンテンツを可視化するポストプロセッシング パスがなければ、この機能は見えないままになります。

![](CustomDepthStencilScene.png)(w:520)

ポストプロセス マテリアルを設定すると、Custom Depth Stencil の見え方を視覚化することができます。オクルードされたオブジェクトは使用された **Custom Depth Stencil Value** に基づいてランダムに割り当てられた色でレンダリングされます。 

![](CustomDepthStencilVisualization.png)(w:520)

視覚化のために使用したマテリアルの構成です。

[REGION:lightbox]
[![](CustomDepthStencilMaterial.png)(w:768)](CustomDepthStencilMaterial.png)
[/REGION]
[REGION:caption]
_画像をクリックしてフルサイズで表示_
[/REGION]

Custom Depth Stencil の使用方法はこれだけではありません。この特別なマテリアル構成では、ステンシルは 1 から 255 までの値を使用するように分割されています。 
その間の値についてはマスクを使用し、その値に対してランダム色を作成するだけでなく、カスタムデプス ステンシル値と色が一緒に変わるようにします。
そして最終的に、オブジェクトがオクルードされた場合にのみステンシル色が付くようにマスクが生成されます。


## テンポラル アンチエイリアシングまたは GBuffer でジッターが生じる理由

テンポラル アンチエイリアシングは UE4 の特殊な機能で、パフォーマンス負荷をほとんどかけずに画像品質を大幅に向上させます。

デフォルト設定で、ポストプロセス マテリアルはポストプロセス グラフの最後に挿入されます (トーンマッパーの後)。つまり、トーンマッピング、カラー グレーディング、そしてテンポラル アンチエイリアシングが適用された後に
最終的な LDR カラーを取得します。パフォーマンスや使いやすさの観点から、多くの簡易なポストプロセス エフェクトにとって最高の場所です。

以下は特定のオブジェクト周りのシルエットを可視化させるためにカスタムの深度入力値をどのように使用したかの例です。

![](sceneAfterTonemapper.png)

この前の画像ではシルエットにアンチエイリアス処理が見受けられませんが、動作中はシルエットに 1 ピクセル程度のジッター (小刻みな揺れ) が見えます。
その理由は、テンポラル アンチエイリアシングでは、シーン全体のレンダリングを各フレームでサブ ピクセルごとに動くからです。アンチエイリアス処理がされた最終画像を作成するために、複数のフレームが一緒に結合されます。
しかしながらこの問題は、ポストプロセス グラフでマテリアルの位置をより前方に移動することもで修正できます。

以下がその結果となります。

![](sceneBeforeTonemapper.png)

安定したアンチエイリアス処理が施された画像となります。動作中はテンポラル アンチエイリアシングでいくつかのアーティファクトに気づくかもしれません。この機能は古い画像を置換するために深度バッファを使用しています。オブジェクトの内側でボーダーがレンダリングされた状態で問題なく機能しますが、
オブジェクトの外側では深度バッファを調整する必要があります (パフォーマンスの負荷が余分にかかるためまだ行っていません)。
これは理想的ではありません。 

## UV と ScreenPosition

ポストプロセス マテリアルを使って、画面ソートされたバッファの中をルックアップして見ることができますが、適切な UV を知る必要があります。 
マッピング オプションを **[ViewportUV]** に設定した **ScreenPosition** マテリアル式は、ビューポートの左上 0,0 と右下 1,1 に UV を出力します。
一方、このマテリアル式で **tSceneTextureUV** マッピング オプションを使うと異なる結果を得ることができます。実際のテクスチャ (もっと正確にはレンダー ターゲット) は、ビューポートよりも大きい可能性があるためです。
このテクスチャを複数のビューポートに共有し、最大のものがすべてのビューポートに使用されるため、エディタで大きくなる可能性があります。
ゲームではさらに大きくなる場合があります (例、SceneCaptureActors はビューポート、マチネブラックボーダー、分割画面、 VR などが小さくなる)。
**SceneTextureUV** オプションを使うと、大きいテクスチャ用の UV が提供されます。相対オフセット (ピクセルサイズのエッジ探知など) だけが必要な場合は、正しいサイズでスケールする必要があります。
**SceneTexture** マテリアル式には、サイズの出力とサイズ反転の出力があります (ピクセル オフセットに効果的かつ便利です)。
すべてをテストするには、様々なビューポート コンフィギュレーションをテストすることができるコンソール変数 **r.ViewPortTest** を使います。

## フィルター済みテクスチャ ルックアップ

SceneTexture マテリアル式には、[bilinear (バイリニア)] でフィルター処理したルックアップを取得するためのチェックボックスがあります。このオプションを使うと、レンダリング速度が落ちるので、必要な場合のみ使用してください。
スクリーン空間テクスチャの多くはフィルター処理をサポートしていません (GBuffer など)。このプロパティを公開していないと、適宜エンジンはデータを圧縮できるようになります (パッキングでフィルタリングが回避されます)。

## トーンマッパの置き換え

トーンマッパでブレンド可能な位置を置き換えることによって、エンジン トーンマッパを独自のものでオーバーライドすることができます。この機能は開発途中であり、今後変更される場合があります。また、機能はまだ完全に実装されていません。

![](ReplacingTheTonemapper.png)

ポストプロセス設定パラメータをトーンマッパへ公開していますが、大幅な変更が予想されます。
値はマテリアル パラメータとして公開され、正確な名前が必要になります。 

ベクター パラメータ：
	Engine.FilmWhitePoint
スカラー パラメータ:
	Engine.FilmSaturation
	Engine.FilmContrast


[EXCERPT:PostMatWarning]
[REGION:warning]
パラメータを取得するには、ポストプロセス マテリアルからマテリアル インスタンスを作成する必要があります。
[/REGION]
[/EXCERPT:PostMatWarning]

独自のパラメータを使って、他のポストプロセス マテリアルのようにブレンドすることも可能です。

## 既知の問題
以下は今後修正すべき問題です。

  * **マテリアル式 SceneTexture**
    * SeparateTranslucency が機能しない。
    * 特定のパスで特定のルックアップが作動しない (パフォーマンス負荷が高すぎると修正されない場合があります)。
    * MaterialFunction がエラーを報告しても PostProcess ドメインでマテリアルで使用ができる。
  * **Material**
    * PostProcessMaterial の UV が 0 から 1 の範囲にないことがあります (例えばエディタでビューポートを小さくした時)。ルックアップと一致しますが、ビネット エフェクトなどの実装が難しくなります。
    * ポストプロセス マテリアルのアセット サムネイルの見た目が正確ではない。
    * アルファ値の出力がいまだサポートされていない (オパシティを通過しなくてはいけません)。
    * マテリアル エディタのプレビュー マテリアルの見た目が正確ではない。
    * マテリアルの変化がポストプロセス処理の変化につながらない。回避策としてエディタを再起動します。
	* **コンテンツ ブラウザ** でポストプロセス マテリアルのフィルタリングを簡単にできるようにする。
  * **ブレンド**
    * ブレンド半径で 2 つのポストプロセス ボリュームをブレンドした時の遷移がぎこちない。* デフォルト値であるマテリアル インスタンスを設定した境界をもたないボリュームを使用してこれを防ぎます。


## FAQ
  * **入力値に "Lighting only mode (ライティングのみのモード)" のテクスチャを使用できますか？**

    できません。中間段階でこのデータは有効ではありません。このビューモードではマテリアルカラーを無視してこれを
	生成しています。高速オプションにするには大部分のレンダリング コードを再構築する必要があります。

  * **SceneColor のルックアップで表示されるバンディングが PostProcessInput0 の使用時に見えないのは何故ですか？**

    SceneColor が使用されると、現在の書き込み対象となるテクスチャでのルックアップを可能にするために、シーンの低解像度コピーを作成します
	(一般的にはこの処理が不可能なメッシュへレンダリングしています)。
	ポストプロセス処理では PostProcessInput0 を使用します。

  * **ポストプロセス処理に必要なメモリ使用量はどの位ですか？**

    メモリーの負荷はスクリーンの解像度次第です。トーンマッピング処理の前に HDR (ピクセルあたり 8 バイト)、その後は LDR (ピクセルあたり 4 バイト) を使用します。

  * **ポストプロセスのレンダリング負荷を低くする方法を教えてください。**

    ターゲット プラットフォームを測定し、テクスチャ ルックアップ数を低めに維持、数学演算を少なくし、依存するテクスチャルックアップを減らして、
	ランダム化したテクスチャルックアップを回避します (テクスチャのキャッシュ ミスが原因で遅くなることがあります)。

  * **パスはいくつ使用できますか？**

    パスの使用ひとつひとつがパフォーマンス負荷に加算されます。パスを結合し、パスのアクティベートは必要時のみにとどめてください。一般的なゲーム機能、
	例えばノイズを、パフォーマンスを高めるためにエンジンパスへ追加することが可能です。

  * **ポストプロセス処理およびブレンドにかかる CPU のパフォーマンス負荷はどのくらいですか？**

    マテリアルのブレンドはとても低負荷です。すべてのマテリアル インスタンスのプロパティは、ブレンドされ、こうした設定を持つひとつのポストプロセス マテリアルのパスだけがレンダリングされます。

  * **正しい TemporalAA のためには "Before Tonemapper" を使用します。いずれかの色を使用するとトーンマッピングが適用されて、違った見た目となってしまいます。この問題の回避方法は？**
    
	この問題に対する簡単な解決法はありません。逆トーンマッピング演算 (高負荷) をする必要があります。明暗順応によって、
	色の表示が異なる場合もあります。EyeAdaptation レベルを SceneTextures に公開して補正することができます。

  * **ポストプロセス グラフのダンプ内容をすべて取得する方法は？**

	**r.CompositionGraphDebug** でグラフのログをコンソールへ記録することができます。以下はその例です。

		FRenderingCompositePassContext:Debug 'PostProcessing' ---------
		Node#1 'SceneColor'
			ePId_Output0 (2D 1136x768 PF_FloatRGBA RT) SceneColor Dep:2
		Node#4 'Velocity'
			ePId_Output0 (2D 1136x768 PF_G16R16 RT) Velocity Dep:1
		Node#2 'SceneDepthZ'
			ePId_Output0 (2D 1136x768 PF_DepthStencil) SceneDepthZ Dep:1
		Node#5 'MotionBlurSetup0MotionBlurSetup1'
			ePId_Input0:Node#4 @ ePId_Output0 'Velocity'
			ePId_Input1:Node#1 @ ePId_Output0 'SceneColor'
			ePId_Input2:Node#2 @ ePId_Output0 'SceneDepthZ'
			ePId_Output0 (2D 568x384 PF_FloatRGBA RT) MotionBlurSetup0 Dep:2
			ePId_Output1 (2D 568x384 PF_FloatRGBA RT) MotionBlurSetup1 Dep:1
		Node#6 'QuarterResVelocity'
			ePId_Input0:Node#5 @ ePId_Output0 'MotionBlurSetup0MotionBlurSetup1'
			ePId_Input1:
			ePId_Output0 (2D 284x192 PF_FloatRGBA RT) QuarterResVelocity Dep:1
		Node#7 'VelocityBlurX'
			ePId_Input0:Node#6 @ ePId_Output0 'QuarterResVelocity'
			ePId_Input1:
			ePId_Output0 (2D 284x192 PF_FloatRGBA RT) VelocityBlurX Dep:1
		...


