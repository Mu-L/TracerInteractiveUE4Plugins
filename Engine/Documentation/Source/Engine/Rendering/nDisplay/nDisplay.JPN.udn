INTSourceChangelist:4276998
Availability: Public
Crumbs:
Title: nDisplay を使用した複数のディスプレイへのレンダリング
Description: nDisplay システムを使用して、アンリアル エンジン プロジェクトを複数のディスプレイで同時にレンダリングする方法について説明します。
Version: 4.20
Parent: Engine/Rendering
Order: 0
Tags: Rendering 
Tags: Graphics 
Tags: Experimental 
Tags: Landing 
Tags: Page


![](ndisplay_banner.png)

インタラクティブ コンテンツの出力先は、1つの画面や、VR ヘッドセットのような1つのデュアル スクリーン デバイスだけではありません。ますます多くのビジュアル化システムが、同時に複数の画面を介してリアルタイム コンテンツをレンダリングしています。ねらいは、さらに効果的に視聴者をゲーム環境に没入できるようにすることです。これらのシステムは、 [パワーウォール](https://en.wikipedia.org/wiki/Powerwall) ディスプレイなど、複数の物理的な画面を隣接させて構築する場合や、 [Cave](https://en.wikipedia.org/wiki/Cave_automatic_virtual_environment) を始めとする仮想環境などのように、複数のプロジェクターを使用し、ドーム、傾斜のある壁、湾曲状のスクリーンなどの物体の表面に 3D 環境を投影することもあります。

アンリアル エンジンは、 **nDisplay** というシステムを介して、こうした利用シナリオをサポートしています。このシステムにより、 3D コンテンツを複数のディスプレイに同時にレンダリングする際に、下記のように、いくつかの最重要課題を解決できます。

*ネットワーク内に置かれているさまざまなコンピュータにまたがる、プロジェクトの複数のインスタンスをデプロイまたは起動する処理が容易になります。各インスタンスは、1つ以上のディスプレイ デバイスにレンダリングされます。
* ディスプレイ ハードウェアの空間レイアウトに基づき、各画面の視錐台の計算に関わるすべての計算をリアルタイムで管理します。
* さまざまなスクリーン上に表示されているコンテンツは *完全に* 同期しているため、決定論的なコンテンツがエンジンのすべてのインスタンスに存在することになります。
*受動的および能動的なステレオスコピック レンダリングが可能になります。
* VR のトラッキング システムからの入力によって制御されるので、ディスプレイ内の視点は、現実世界で動いている人の視点を正確に追従します。
* nDisplay には、十分な柔軟性があるので、任意の相対的な方向で、任意の数のスクリーンをサポートできます。また、任意の数のプロジェクト間で簡単に再利用できます。

## nDisplay システムの概要

nDisplay はそれぞれ、 *マスター* コンピュータ1台と任意の数の付加的なコンピュータから構成されます。

* ネットワーク内の各コンピュータは、パッケージ化されたプロジェクトの実行ファイルのインスタンスを1つ以上実行します。これらのアンリアル エンジン インスタンスはそれぞれ、同じ 3D シーンのうちの単一の領域を、単一のスクリーンまたはディスプレイにレンダリングします。
* また、マスター ノードは、VRPN デバイスからの入力を受け入れ、それを他の接続してあるコンピュータすべてにレプリケートします。

![ nDisplay ネットワークの概要](image5.png "nDisplay ネットワークの概要")

上記を実現するために、 nDisplay は、通常のアンリアル システム アーキテクチャに次のコンポーネントを追加します。

* **nDisplayLauncher** と呼ばれるネットワーク プロビジョニングおよび管理アプリケーション。ネットワーク上のコンピュータ1台でこのアプリケーションを実行すると、ネットワーク内すべてのコンピュータに、プロジェクトを自動的にデプロイして起動できます。 
* **nDisplayListener** という独立したリスナー アプリケーション。これは、各コンピュータで実行されます。このアプリケーションは、 nDisplayLauncher から送られてくるリクエストを待ち受け、そのリクエストをローカル コンピュータで処理します。
* nDisplay が、正しいコンピュータ上で適切な数のインスタンスを起動するために必要な設定をすべて含んだ共通のコンフィギュレーション ファイル。これにより、各コンピュータは、ゲームの 3D ワールドにおける正しい視点をレンダリングするので、複数のディスプレイ画面またはプロジェクター全体でシームレスにレンダリングが行われているかのような錯覚をもたらすことができます。後段の [nDisplay のコンフィギュレーション ファイルについて](#nDisplayのコンフィギュレーションファイルについて) を参照してください。

## 入門編

このセクションでは、初めて nDisplay を利用するときの方法について説明します。開始前に以下を確認してください。

* スクリーン、プロジェクターなどの物理的な機器が、正しくセットアップされており動作していることを確認してください。
* マスター コンピュータで使用する Windows アカウントに、 nDisplay ネットワークで使用する  *すべての* コンピュータに対する管理者権限があることを確認してください。
* nDisplay ネットワークで使用するすべてのコンピュータが、41000、41001、41002番ポートを介して TCP/IP 通信を受け取れることを確認してください。（代わりに別のポートを使用することもできます。後段の [通信ポートの変更](#通信ポートの変更) を参照してださい。） 

### ステップ1. プロジェクトを nDisplay 用にセットアップする

nDisplay を使用するにあたって、最も簡単なプロジェクトの設定方法は、 nDisplay テンプレート プロジェクトからプロジェクトを作成することです。

![テンプレートから nDisplay プロジェクトを作成します。](ndisplay-create-from-template.png "テンプレートから nDisplay プロジェクトを作成します。")

これにより、自動的に nDisplay プラグインが有効になります。さらに、サンプルのコンフィギュレーション ファイルがプロジェクトに追加され、デフォルトの設定値があらかじめ入っているデフォルトのレベルが加わります。

既存のプロジェクトで nDisplay を使用する場合は、同じ設定を手動で行うことができます。後段の [既存のプロジェクトへ nDisplay の追加](#既存のプロジェクトにnDisplayを追加する) を参照してださい。

### ステップ2. コンフィギュレーション ファイルをセットアップする

nDisplay に、次のことを伝える必要があります。ネットワークで使用したい各コンピュータ、それらのコンピュータがレンダリングするスクリーンまたはプロジェクターのサイズと解像度、レベルの 3D 空間におけるこれらスクリーンの空間的関係などです。これを行うには、一連の設定ですべての情報を含むことができるコンフィギュレーション ファイルを作成します。

このコンフィギュレーション ファイルを作成する作業は、 nDisplay の設定の中で最も難しい部分ですので、注意が必要です。詳細は、後段の [nDisplay のコンフィギュレーション ファイルについて](#nDisplayのコンフィギュレーションファイルについて) を参照してださい。

通常、一旦コンフィギュレーション ファイルが作成されれば、ネットワークのトポロジーが変更された時には修正を加えるだけで済みます。たとえば、レンダリングしているコンピュータを変更した場合や、現実世界でスクリーンとディスプレイの物理的な配置を変更した場合などがそれに該当します。

プロジェクトの Content フォルダにコンフィギュレーション ファイルを保存します。このファイルは、次のステップで使用します。

### ステップ3. パッケージ化とデプロイ

プロジェクトのコンテンツを変更するたびに、ゲームをパッケージ化し、コンフィギュレーション ファイルで指定したすべてのコンピュータにデプロイする必要があります。

1. アンリアル エディタで、ゲームを Windows 用にクックしてパッケージ化します。詳細については、 [ビルド操作（クック、パッケージ化、デプロイ＆実行）](Engine/Deployment/BuildOperations) を参照してださい。
   その後、スレーブコンピュータにアプリケーションをデプロイすると、それは nDisplay によってターゲットコンピュータのそれぞれ同じ場所にコピーされます。そのため、この段階でプロジェクトを、すべてのコンピュータに存在する場所にパッケージ化することをおすすめします。
1. アンリアル エンジンのインストール フォルダに、 *Engine\\Binaries\\DotNET\\nDisplayListener.exe * というアプリケーションがあります。このアプリケーションを、パッケージ化されたゲームの *.exe* ファイルを含むフォルダにコピーします。
1. nDisplay のコンフィギュレーション ファイルを上記フォルダにコピーします。これで、パッケージ化されたプロジェクトの *.exe* ファイル、 *nDisplayListener.exe * アプリケーション、コンフィギュレーション ファイルがすべて同じフォルダに置かれたことになるはずです。
1. アンリアル エンジンのインストール フォルダに入っている *Engine\\Binaries\\DotNET\\nDisplayLauncher.exe * というアプリケーションを実行してください。
   [REGION:lightbox]
   [![nDisplay ランチャーにデプロイする](ndisplay_launcher_config-1.png "nDisplay ランチャーにデプロイする")](ndisplay_launcher_config-1.png) *クリックするとフルサイズで表示されます。*
   [/REGION]
1. パッケージ化されたプロジェクトの *.exe* ファイルをアプリケーションリストに追加します。
   ** [Applications] ** リストの下にある ** [Add] ** をクリックし、パッケージ化されたプロジェクトの *.exe* ファイルを選択します。
1. コンフィギュレーション ファイルを指定します。
   ** [Config Files] ** 欄の右にある ** [Add] ** をクリックしてコンフィギュレーション ファイルを参照、選択してください。
1. ** [Deploy application] ** をクリックしてください。
   nDisplay は、プロジェクトの実行可能ファイルを含むフォルダの中身全体を、コンフィギュレーション ファイルで指定した他のコンピュータ上の同じ場所にコピーします。
    

### ステップ4. すべてのノードを起動する

コンフィギュレーション ファイルで指定したすべてのコンピュータにプロジェクトが正常にデプロイできたら、 **nDisplayLauncher** アプリケーションを使用することによって、すべてのコンピュータで同時にプロジェクトを起動できます。

1. **nDisplayLauncher** アプリケーションをまだ実行していない場合は、これを起動して、アプリケーションとコンフィギュレーション ファイルを直前のセクションで説明されている要領で設定します。
   [REGION:lightbox]
   [![nDisplay ランチャーを実行する](ndisplay_launcher_launch.png "nDisplay ランチャーを実行する")](ndisplay_launcher_launch.png) *クリックするとフルサイズで表示されます*
   [/REGION]
1. ** [Start listeners] ** をクリックします。これにより、nDisplay のコンフィギュレーション ファイルで指定した各コンピュータで nDisplayListener アプリケーションが実行されます。
1. すべてのリスナーがすべてのコンピュータで起動していることを nDisplay で確認できたら、 ** [Run] ** をクリックしてすべてのインスタンスを起動します。

作業を終えたら、次のようにして終了します。

1. ** [Kill] ** をクリックして、すべてのコンピュータ上でアンリアル エンジンのあらゆるインスタンスを自動でシャットダウンするか、もしくは、単にマスターコンピュータ上で実行されているアンリアル エンジンのインスタンスをシャットダウンします。
1.** [Stop listeners] ** をクリックして、 すべてのコンピュータで nDisplayListener アプリケーションをシャットダウンします。

## nDisplay のコンフィギュレーション ファイルについて

[REGION:tip]
nDisplay のコンフィギュレーション ファイルを理解し、自分で作成できるようになる最も良い方法は、 nDisplay プラグインに入っている設定例をまず基にしてみることです。nDisplay テンプレートからプロジェクトを作成した場合、これらのファイルはプロジェクト フォルダの *Content/ConfigExamples* にあります。そこにない場合は、アンリアル エンジンをインストールしたフォルダの *Templates/TP_nDisplayBP/Content/ConfigExamples* にあります。
[/REGION]

nDisplay のコンフィギュレーション ファイルの構造は、ビジュアライゼーションのレンダリングに使用される各種コンポーネントとファイルの各項目が直接対応している形となっています。

* 設定対象の各種コンポーネントには、コンフィギュレーション ファイル内に専用の行があり、割り当てた文字列 ID によって識別されます。これらの文字列 ID は、コンフィギュレーションのあるセクションが別のセクションを参照する必要がある場合に使用できます。
* このファイルで設定するコンポーネントの多くは、仮想 3D 空間での位置（多くの場合、回転も）が定義されます。各オブジェクトの位置と回転は、そのオブジェクトの  *親* を基準とした相対的な位置と回転になっています。デフォルトでは、すべてのオブジェクトの親は VR 空間の原点となっています。この原点は、VR 空間が開始すると見なされる、3D 空間における任意の点のことです。また、3D 空間において、特定の名前をもつトランスフォーム (scene_node シーンノードと呼ばれるトランスフォームであり、1つ以上のコンポーネントのための親として機能する) を設定することができます。これにより、スクリーン、カメラ、その他のコンポーネントを簡単に空間に配置できるようになります。
*パラメータの値の単位は、別途明記されていない限り、すべてメートルおよび度 (°) です。

### カメラ設定

nDisplay は一度に一つの視点からシーンをレンダリングします。複数ある潜在的な視点はそれぞれ、 **camera ** のための設定行で定義されます。

これらの視点は、実行時に切り替えることができます。各視点は、トラッキング デバイスによって制御することも可能です。

#### 設定例

	[camera] id=camera_static loc="X=0.Y=0,Z=1.7" tracker_id=VRPNTracking tracker_ch=0

#### パラメータ

| パラメータ | 説明 |
| --- | --- |
| **id** | このカメラ設定自体につけられた一意の名前です。|
| **loc** | VR 空間におけるこのカメラ位置です。(親を基準とした相対位置)|
| **tracker_id** | 時間経過にともなってカメラの位置を動かす VR デバイスを定義する ** [input] ** 設定の名前。使用は任意です。このパラメータを省略すると、カメラの位置は VR 空間で固定になります。|
| **tracker_ch** | **tracker_id** を指定すると、nDisplay がトラッキング データをデバイスのチャンネルから読み込みますが、このパラメータはそのチャンネルを指定します。|
| **parent** | このオブジェクトの親として機能させたい ** [scene_node] ** 設定の名前です。このパラメータは任意です。親を指定すると、 loc パラメータで設定した値はその親の位置からの相対値になります。親を省略すると、 loc パラメータで設定した値は VR root からの相対値になります。|


### スクリーン設定

各出力ディスプレイは、指定されたサイズと 3D VR 空間内における配置をともなった矩形で定義される視錐台を使用して、現在のカメラの位置からシーンをレンダリングします。これらの矩形は、 ** [screen] ** 設定によって定義されます。通常、これらの投影スクリーンは、VR 空間において、レンダリングに使用する物理的なスクリーンと同じ寸法となっています。

画面の回転軸は、常に正確な中間点にあります。

#### 設定例

以下の定義は、親の真正面にある3メートル×3メートルのスクリーンのためのものです。スクリーンの回転軸は [size] パラメータで定義された矩形の中央にあるので、スクリーンをその高さの半分の距離だけ上に移動するために Z 軸に1.5メートルのオフセットを追加しています。

	[screen] id=screen_front loc="X=1.5.Y=0,Z=1.5" rot="P=0,Y=0,R=0" size="X=3,Y=3" parent=screens

ビューアの左側のスクリーンを定義するために、スクリーンを左に移動させ（ Y 軸上の負の値）、ローカルの Y 軸を中心に回転させます (ヨー）。 

	[screen] id=screen_left loc="X=0,y=-1.5,Z=1.5" rot="P=0,Y=-90,R=0" size="X=3,Y=3" parent=screens

#### パラメータ

| **パラメータ** | **説明** |
| --- | --- |
| **id** | このスクリーン設定自体につけられた一意の名前です。|
| **loc** | VR 空間におけるこの画面の中心の位置です。(親を基準とした相対位置)|
| **rot** | 画面の向きを、ピッチ（P）、ヨー（Y）、ロール（R）方向の度数で表しています。|
| **size** | ローカルの X 軸方向と Y 軸方向における、スクリーン矩形全体のサイズ（メートル単位）です。|
| **parent** | このオブジェクトの親として機能させたい ** [scene_node] ** 設定 の名前です。このパラメータは任意です。親を指定すると、 loc パラメータと rot パラメータで設定した値は、その親の位置からの相対値になります。親を省略すると、 loc パラメータと rot パラメータで設定した値は、 VR root からの相対値になります。|



### クラスター ノード設定

上記で定義した各投影スクリーンは、通常、アンリアル エンジン アプリケーションの異なるインスタンスによってレンダリングされます。これらのインスタンスごとに、 ** [cluster_node] ** 設定を定義する必要があります。 各クラスター ノードは、レンダリング対象の投影スクリーン設定を参照します。 

[cluster_node] 設定では、そのアプリケーション インスタンスを実行するコンピュータのホスト名または IP アドレスも定義します。[cluster_node] 設定ごとに物理的に異なったコンピュータを設置することが可能です。また、同じホスト上で複数の [cluster_node] の設定を実行することも可能です。

#### 設定例

次の例では、マスター ノード（ネットワークごとに1つあります）を設定します。

	[cluster_node] id=node_front addr=192.168.0.1 screen=screen_front viewport=vp_front sound=true port_cs=41001 port_ss=41002 master=true

次の例では、マスターではないクラスター ノードを示しています。

	[cluster_node] id=node_left addr=192.168.0.2 screen=screen_left viewport=vp sound=false

#### パラメータ

| **パラメータ** | **説明** |
| --- | --- |
| **id** | このクラスター ノード設定自体につけられた一意の名前です。|
| **addr** | アンリアル エンジンのこのインスタンスを実行するコンピュータの IP アドレスです。これは IPv4 アドレスでなければなりません。IPv6 はサポートされていません。|
| **screen** | アンリアルのこのインスタンスがレンダリングする投影スクリーンを定義している ** [screen] ** 設定の名前です。|
| **viewport** | ** [viewport] ** 設定の名前を指定します。この ** [viewport] ** 設定では、アンリアル エンジンのこのインスタンスによって実行されるアプリケーション ウィンドウ内においてレンダリングされるフレームの位置が定義されています。|
| **sound** | アンリアル エンジンのこのインスタンスが、サウンド再生を行うかどうかを指定します。任意です。デフォルト値は false です。|
| **Winx WinY** | デスクトップ上におけるアプリケーション ウィンドウ左上隅の位置を指定します。単位は、スクリーン空間のピクセルです。|
| **ResX ResY**	| アプリケーションウィンドウのサイズを指定します。単位は、スクリーン空間のピクセルです。このクラスター ノードに使用するビューポートの定義が、このウィンドウのサイズを超えないようにしてください。|
| **port_cs port_ss** | port_ss	クラスターの同期ポートです。マスター ノードがクラスター内の他のノードと通信するために使用されます。デフォルト値は 14001 と 14002 です。|
| **master** |アンリアル エンジンのこのインスタンスが、クラスターのマスターノードであるかどうかを指定します。このパラメータを true に設定できるのは、一つの [cluster_node] セクションだけです。任意のパラメータです。デフォルト値は false です。|


### ビューポート設定

上で説明した ** [cluster_node] ** 設定はそれぞれ、 ** [viewport] ** 設定を参照します。 ** [viewport] ** 設定では、レンダリングされるフレームがマッピングされるゲームウィンドウの矩形領域が定義されています。
通常は、異なる解像度の設定が行われているディスプレイ デバイスごとに、異なるビューポート設定が必要です。たとえば、すべてのディスプレイ スクリーンが同一の場合、ビューポート設定は1つしか必要になりません。それをすべてのクラスター ノード設定から参照することができるからです。

通常、ビューポートはアプリケーション ウィンドウの左上隅から始まり、幅と高さは親ウィンドウいっぱいになるように設定されます。ただし、親アプリケーション ウィンドウ内でビューポートをオフセットしなければならない場合もあります。たとえば、2台のプロジェクターを部分的にオーバーラップさせる設定にしたい場合は、この方法を使う必要があるかもしれません。

####設定例

	[viewport] id=vp_left X=0 Y=0 width=1920 height=1080

#### パラメータ

| **パラメータ** | **説明** |
| --- | --- |
| **id** |	このビューボート設定自体につけられた一意の名前です。|
| **X Y** | メイン アプリケーション ウィンドウ画面領域内における、ビューポートの左上隅の座標です（ピクセル単位）。|
| **width height** | レンダリングするフレームの幅と高さです（ピクセル単位）。このビューポートを使用する任意の ** [cluster_node] ** 設定の [size] パラメータによって設定されたゲーム ウィンドウのサイズよりも大きい値はとれません。|


### シーン ノード設定

コンフィギュレーション ファイルでは、シーン ノードの階層を定義することができます。各シーン ノードは、 3D 空間におけるトランスフォームを意味します。カメラや投影スクリーンなど、 3D 空間での位置と回転を必要とするコンポーネントで、コンフィギュレーション ファイルで設定されているものは、これらの  * [scene_node] * 設定の1つをその親として使用できます。 これは、ビジュアライゼーション システムのさまざまなコンポーネント間の空間関係を定義するのに役立ちます。

シーン ノードは、カメラと同じように VR トラッキング デバイスによっても制御することが可能です。

####設定例

次の行は、2つのノードの階層を定義しています。子ノードは、親ノードの前方2メートルにオフセットされています。

	[scene_node] id=vr_space_root loc="X=0.Y=0,Z=0" rot="P=0,Y=0,R=0"
	[scene_node] id=walls_front_group loc="X=2.Y=0,Z=0" rot="P=0,Y=0,R=0" parent= vr_space_root

次の行は、VR トラッキング デバイスによって制御されるようにシーン ノードを設定しています。

	[scene_node] id=cave_wand loc="X=0, Y=0,Z=1" tracker_id=CaveTracking tracker_ch=1

#### パラメータ

| **パラメータ** | **説明** |
| --- | --- |
| **id** | このシーン ノード設定自体につけられた一意の名前です。|
| **loc** | VR 空間における、このシーン ノードの親からの相対位置です。|
| **rot** | シーン ノードの角度を、ピッチ（P）、ヨー（Y）、ロール（R）方向で表しています。単位は度 (°) です。|
| **parent** | このシーン ノードの親として機能させる、他の ** [scene_node] ** 設定の名前です。このパラメータは任意です。親を指定すると、 **loc** パラメータ、 **rot** パラメータで設定した値はその親の位置からの相対値になります。親を省略すると、 **loc** パラメータと **rot** パラメータ で設定した値は VR root からの相対値になります。|
| **tracker_id** | 時間経過にともなってシーン ノードの位置を制御する VR デバイスを定義する **input** 設定の名前です。使用は任意です。このパラメータを省略すると、シーン ノードの位置と回転は、VR 空間における親を基準とする相対値に固定されます。|
| **tracker_ch** | **tracker_id** を指定すると、nDisplay がトラッキング データをデバイスのチャンネルから読み込みますが、このパラメータはそのチャンネルを指定します。|


### 入力設定

** [camera] ** およびそれぞれの ** [scene_node] ** は、 VR トラッキング デバイスによって制御することができます (任意) 。これを行うには、各 VR デバイスの ** [input] ** セクションを定義し、 ** [camera] ** もしくは ** [scene_node] ** 設定でその定義を参照するようにしてください。

####設定例

	[input] id=CaveTracking type=tracker addr=Tracker0@192.168.0.1 loc="X=-1.5,Y=0,Z=3.4" rot="P-0,Y=0,R=0" front=X right=Y up=-Z

#### パラメータ

| パラメータ | 説明 |
| --- | --- |
| **id** | この入力デバイスにつけられた一意の名前です。|
| **type** | [INCLUDE:#Excerpt_2] |
| **addr** | [INCLUDE:#Excerpt_3] |
| **remap** | [INCLUDE:#Excerpt_4] |


[COMMENT:none]

[EXCERPT:Excerpt_2]
。この VRPN 入力デバイスのタイプを指定します。
* トラッキング デバイスには tracker を指定します。
* 軸データを生成するデバイスには analog を指定します。
* Bool 型のボタンデータを生成するデバイスには button を指定します。
[/EXCERPT]

[EXCERPT:Excerpt_3]
	この特定のデバイスを処理するVRPN サーバーのアドレスです。値は次の形式と一致する必要があります。
`DEVICENAME@SERVER_ [Add] RESS`
* DEVICENAME の部分にはこのデバイスの VRPN 名を入れます。
* SERVER_ADDRESS の部分には、 VRPN サーバーの IPv4 アドレスを入れます。
[/EXCERPT]

[EXCERPT:Excerpt_4]
このパラメータは、トラッキング デバイスのチャンネル番号を再マッピングします。これにより、アンリアルの異なるチャンネルから入力を読み込むことができるようになります。たとえば、デバイスによっては、ヘッド トラッキングにはチャンネル0を、コントローラーにはチャンネル1を使用するものがある一方で、ヘッド トラッキングにはチャンネル1を、コントローラーにはチャンネル5を使用するものもあります。これらの2つのデバイスを切り替えるには、設定と実行時のコードを変更して一致させる必要が出てくることもあります。このような場合に、余計な変更を行わなくてもよいようにするために、このパラメータを使用してチャンネルを再マッピングします。
例えば、値が
`remap[0:1, 5:2]`
の時は、トラッキング デバイスのチャンネル1からアンリアルのチャンネル0にデータを転送し、トラッキング デバイスのチャンネル2からアンリアルのチャンネル5にデータを転送します。
[/EXCERPT]

[/COMMENT]

type=tracker のデバイスは、以下の追加パラメータも受け付けます。

| **パラメータ** | **説明** |
| --- | --- |
| **loc rot** | 他の設定セクションと同様に、 **loc** パラメータ、 **rot** パラメータは、この入力デバイスのローカル空間における位置および回転のオフセットを指定します。ただし、通常、入力デバイスの場合は、これらのオフセットを使用して、 VR 空間内のトラッキング デバイスのルート位置を調整することによって、シーン ノード階層において置かれるべき位置に合致するようにします。|
| **front right up** | [INCLUDE:#Excerpt_5] |



[COMMENT:none]
[EXCERPT:Excerpt_5]
これらのパラメータは、アンリアルにおいてトラッカーがもつローカルの各軸（前、右、上）と、トラッカーの座標系においてそれらに相当する軸を対応づけます。アンリアルは右手系 z-up 座標系を使っています。トラッカーが異なる座標系を使用している場合は、これらのパラメータを使用して、トラッカーの座標系をアンリアルにマッピングできます。
たとえば、次の行は、トラッカーのY軸をアンリアルの前軸（X）にマッピングし、トラッカーの X 軸をアンリアルの右軸（Y）に、トラッカーの負方向の Z 軸をアンリアルの上方向の Z 軸に設定しています。
front=Y right=X up=-Z
[/EXCERPT]
[/COMMENT]

### 一般設定

** [general] ** 設定の行には、 nDisplay のクラスター全体の動作を制御するパラメータが含まれています。

#### 設定例

	[general] swap_sync_policy=1

#### パラメータ

| **パラメータ** | **説明** |
| --- | --- |
| **swap_sync_policy** | [INCLUDE:#Excerpt_6] |


[COMMENT:none]
[EXCERPT:Excerpt_6]
ネットワークを介して出力をどのように同期させるかを指定します。
* 0: 同期はありません。
* 1: ソフトウェアによるスワップ同期
* 2: NVスワップ ロック（ OpenGL によりレンダリングする NVIDIA カードの場合のみ）
[/EXCERPT]
[/COMMENT]

### ステレオ設定

** [stereo] ** 設定の行は、ステレオスコピック レンダリング用のグローバル パラメータ (任意) を設定します。

#### 設定例

\[stereo\] eye\_swap=True eye\_dist=0.064

#### パラメータ

| **パラメータ** | **説明** |
| --- | --- |
| **eye_swap** | それぞれ両目に生成された画像を、左右入れ替えるかどうかを指定します。任意です。デフォルト値は false です。|
| **eye_ dist** |どう孔間の距離です（単位はメートル）。両目に生成された画像をオフセットするために使用されます。|


### 構造

以上の概略に示された各種設定間における参照は、下図のような構造となっています。赤い矢印の参照は必須で、緑の矢印は任意です。

![設定間参照の構造](ndisplay-configuration-references.png "設定間参照の構造")

### 例

具体例として、 *wall_flat_3x2.cfg* サンプル ファイルを開きます。このファイルでは6つの投影スクリーンが定義しされています。それぞれの投影スクリーンは、別々の物理的なコンピュータによってレンダリングされます。

また、いくつかの [scene_node] も定義されています。これらの [scene_node] は、次の階層を構成します。

![nDisplay シーン階層の例](ndisplay-scene-hierarchy.png "nDisplay シーン階層の例")

 この階層内のノードの相対的な位置と回転によって、VR 空間におけるカメラと 6 つのスクリーンの位置が決まります。6 つの投影スクリーンは隣り合わせに並び、カメラから 1 m の距離のところに配置されることになります。

[REGION:lightbox]
[![nDisplay レイアウト例](ndisplay-example-layout.png)](ndisplay-example-layout.png)
[/REGION]

[REGION:caption]
 クリックするとフルサイズで表示されます。
[/REGION]

なお、この設定には、隣り合わせになっている投影スクリーン間に狭いスペースが含まれています。これは、シーンをレンダリングするモニターの縁を考慮したものです。

## ブループリント API

ブループリント API を使用して、ゲームの実行時のロジックにおいて nDisplay システムの動作を制御できます。

クラスター、入力、レンダリングを管理するために、この API で公開されている関数を呼び出すには次のようにします。

1. ブループリントで新しい **[Display Cluster] > [Get Plugin API] ** ノードを作成します。
2. ** [Out API] ** ピンからドラッグし、次のように ** [Display Cluster] ** カテゴリから探します。
    ![nDisplay の Get Plugin API](ndisplay-get-plugin-api.png "nDisplay の Get Plugin API ")

## アクタのレプリケーション

nDisplay システムへのすべての入力は、マスター ノードによってのみ処理されます。レプリケーションがない場合、シーンの変化はマスター ノードででしか見られなくなります。したがって、マスター ノードが、 nDisplay ネットワークの他のすべての部分に対し変更をレプリケートできる必要があります。

これを実現するために、 nDisplay にはアクタにアタッチできる2種類のコンポーネントがあります。

*   **DisplayClusterSceneComponentSyncParent** コンポーネントは、親コンポーネントの 3D トランスフォームの変更を追跡し、それをネットワーク内の他のクラスター ノードに送信します。
    nDisplay システムで使用されるデフォルトの DisplayClusterPawn は、このコンポーネントを使用します。
    
*   **DisplayClusterSceneComponentSyncThis ** コンポーネントは、子コンポーネントの 3D トランスフォームの変更を追跡し、それをネットワーク内の他のクラスター ノードに送信します。

たとえば、以下に示すアクタでは、 **DisplayClusterSceneComponentSyncParent_DefaultSceneRoot** コンポーネントが、アクタがレベルを移動するときに親アクタの 3D トランスフォームへの変更を追跡してレプリケートします。また、 **DisplayClusterSceneComponentSyncThis** コンポーネントは、その子のキューブコンポーネントがシーン グラフのルートを基準にして動くなか、その動きを追跡し、同期します。

![DisplayClusterSceneComponentSyncParent](ndisplay-actor-replication.png "DisplayClusterSceneComponentSyncParent")

シーンに、ゲームプレイ中影響を受ける可能性があるアクタが他にもある場合は、これら2つのコンポーネントのいずれかを使い、変更をすべてのノードにレプリケートする必要があります。そのためには、以下の方法を実行します。

1. レベル ビュー ポートまたは ** [World Outliner] ** パネルで、レプリケートする必要があるアクタを選択します。
2. ** [Details] ** パネルで、 ** [\+ [Add] Component] ** をクリックします。**DisplayClusterSceneComponentSyncParent** もしくは **DisplayClusterSceneComponentSyncThis** のどちらかを検索し、リストから選択します。
    ![nDisplay の同期コンポーネントを追加する](ndisplay-actor-replication-selection.png "nDisplay の同期コンポーネントを追加する")

[REGION:note]
これらのコンポーネントによって完全なレプリケーションは実行されません。親アクタまたは子コンポーネントのトランスフォームだけがクラスターに送信されます。
[/REGION]

## VRPN 入力の使用

nDisplay で [VRPN](https://en.wikipedia.org/wiki/VRPN) 入力デバイスを使用する方法は、次の通りです。

1. ネットワークに VRPN サーバーをインストールします。
   このバージョンの nDisplay は、VRPN **version 33** が必要です。
1. サーバーの実行ファイルの横にある、サーバーの  *vrpn.cfg* ファイルで、入力デバイスを有効にして名前を付けます。
1. nDisplay のコンフィギュレーション ファイルで、 当該の VRPN 入力デバイスを設定するための項目を追加し、座標系を調整し、カメラを付属させます。

下記は、ART DTrack トラッキング システムを設定する方法の一例です。

* VPRN server exe の横にある Vrpn.cfg に、次の行を追加します。
		vrpn_Tracker_DTrack DTrack  5000	
  これにより、VRPN は 5000 番ポートから DTrack の入力を受信し、その入力を「 DTrack 」という名前のVRPNデバイスにマッピングします。（ DTrack が 5000 番ポートでトラッキング データを出力するように設定されていることを確認してください）
* nDisplay コンフィギュレーション ファイルに、次の行を追加します。
		[input] id=CaveTracking type=tracker addr=DTrack@127.0.0.1 loc="X=1.32,Y=0,Z=0.93735" rot="P=0,Y=0,R=0" front=Z right=-X up=Y
		[camera] id=camera_dynamic loc="X=0,Y=0,Z=0" tracker_id=CaveTracking tracker_ch=0
  最初の行では「 CaveTracking 」という名前の nDisplay 入力デバイスを作成しています。このデバイスは VRPN アドレス 「 DTrack@127.0.01 」からデータを取得します。座標系をここで調整することによって、トラッキング システムとオフセットに適合するようにする必要があります。2行目では、チャンネル0の CaveTracking 入力からカメラ位置を取得するように nDisplay に命じています。

ゲームプレイ コードから VRPN デバイスの状態を管理し、ボタンが押されるなどの入力イベントを検出する方法は、次の通りです。

* C++ では、IDisplayClusterInputManager クラスを使用します。
* ブループリントでは、 ** [DisplayCluster] > [Input] ** の下に置かれているノードを使用してください。それらのノードで設定した ID が、コンフィギュレーション ファイルで設定した ID 値と一致するようにしてください。例:
  ![](ndisplay_vrpn_api.png "ndisplay_vrpn_api.png")

## 通信ポートの変更

nDisplay システムは、3つの TCP/IP ポートを介してホスト間で通信します。そのためのポート番号は、14000、14001、14002番です。 これらのポートがすべてのコンピュータで開いている状態にしてください。

ポート番号を自分で変更したい場合は、次の場所で可能です。

* **実行時の同期ポート ** 。マスター ノードは2つのポートを使用し、クラスター内の他のノードとデータを同期します。これらの2つのポートを設定するには、**port_cs** と **port_ss** の設定パラメータをコンフィギュレーション ファイルに含めます。それらを置く行は、マスター ノードを定義している ** [cluster_node] ** の行です。例:
		[cluster_node] id=node_front addr=192.168.0.1 screen=screen_front viewport=vp_front port_cs=42001 port_ss=42002 master=true

* **nDisplay Launcher のポートと nDisplay のリスナーのポート** 。nDisplayのランチャーと nDisplayListener は、両方とも同じ通信ポートを使用する設定にしなければなりません。これらのアプリケーションを起動する際に、コマンドラインで指定することできます。
  nDisplay Launcher を起動するときに、listener_port 引数を使います。例:
	nDisplayLauncher.exe listener_port=15003

  加えて、port 引数を使用して、各ホスト上で nDisplayListener アプリケーションを自分で起動する必要があります。例:
	nDisplayListener.exe port=15003

## 既存のプロジェクトに nDisplay を追加する

既存のプロジェクトを設定して nDisplay を使用する方法は、次の通りです。

1. nDisplay プラグインを有効にします。
    アンリアル エディタで、メインメニューから ** [Edit] > [Plugins] ** を選択します。「 nDisplay 」で検索し、 ** [Enabled] ** チェックボックスにチェックを入れます。
	[REGION:lightbox]
    [![nDisplay プラグインを有効にします。](ndisplay-enable-plugin.png "nDisplay プラグインを有効にします。")](ndisplay-enable-plugin.png)  
	*クリックするとフルサイズで表示されます。*
    [/REGION]
2. プロジェクトのために nDisplay を有効にしてください。
    メインメニューから ** [Edit] > [Project Settings] ** を選択し、 ** [Plugins] > [nDisplay] ** セクションを探します。** [Enabled] ** チェックボックスにチェックを入れます。
    [REGION:lightbox]
    [![nDisplay プロジェクト設定](ndisplay-project-settings.png "nDisplay プロジェクト設定")](ndisplay-project-settings.png)  
	*クリックするとフルサイズで表示されます。*
    [/REGION]
3. ** [Project Settings] ** ウィンドウのままで ** [Project] > [Description] ** セクションに移動し、 ** [Settings] > [Use Borderless Window] ** チェックボックスにチェックを入れます。
    [REGION:lightbox]
    [![Use Borderless Window](ndisplay-project-settings-borderless.png "Use Borderless Window ")](ndisplay-project-settings-borderless.png)  
	*クリックするとフルサイズで表示されます。*
    [/REGION]
4. アンリアル エディタ を再起動後、プロジェクトを再度開き、プロジェクトのデフォルトのレベルを開きます。
5. ** [World Settings] ** パネルで、 ** [Game Mode] > [GameMode Override] ** を ** [DisplayClusterGameModeDefault] ** に設定します。
    [REGION:lightbox]
    [![nDisplayWorld Settings](ndisplay-world-settings.png "nDisplay World Settings")](ndisplay-world-settings.png)  
	*クリックするとフルサイズで表示されます。*
    [/REGION]    
6. 新しい ** [DisplayClusterSettings] ** アクタをレベルに追加してください。
    このアクタは ** [Modes] ** パネルの ** [All Classes] ** リストにあります。
7. 上記の [ 入門編 ](#入門編) の設定方法の残りの部分 (ステップ 2 以降) に進みます。

## nDisplay Launcher の UI に関するリファレンス

このセクションでは、 nDisplay Launcher のユーザー インターフェイスで使用できる、すべての設定とオプションについて説明します。

[REGION:lightbox]
[![nDisplay Launcher UI](ndisplay-launcher-ui.png)](ndisplay-launcher-ui.png)
[/REGION]

| **コントロール** | **説明** |
| --- | --- |
| **Render API** | 次回 [Run] をクリックしたときに使用するレンダリング API を指定します。|
| **Render mode** | [INCLUDE:#excerpt_9] |
| **Use All Available Cores** |ホスト上で使用可能なすべてのプロセッサを各アンリアル インスタンスに強制的に使用させるようにします。このオプションを選択すると nDisplay Launcher は、各インスタンスの起動に使用するコマンドラインに「 USEALLAVAILABLECORES 」オプションを追加します。|
| **No Texture Streaming** | 各アンリアル インスタンスのテクスチャ ストリーミングを無効にします。最高品質のテクスチャを常にロードします。このオプションを選択すると nDisplay Launcher は、各インスタンスの起動に使用するコマンドラインに「 NOTEXTURESTREAMING 」オプションを追加します。|
| **Custom command line arguments** |各インスタンスの起動に使用するコマンドラインで追加の引数を nDisplay Launcher に渡させる場合は、ここに含めてください。詳細は、 [Command-Line Arguments]("Programming/Basics/CommandLineArguments") を参照してください。|
| **Applications** | nDisplay Launcher で実行可能な、パッケージ化されたすべてのアンリアル アプリケーションを一覧表示します。[Add] および [Delete] ボタンを使用して、リストを編集できます。詳細については、既述のステップ3. パッケージ化とデプロイ]("Engine/Rendering/nDisplay#step3packageanddeploy") を参照してください。|
| **Config Files** | nDisplay Launcher 用に設定したすべてのコンフィギュレーション ファイルを一覧表示します。[Add] および [Delete] ボタンを使用して、リストを編集できます。詳細については、既述の [ステップ3. パッケージ化とデプロイ]("Engine/Rendering/nDisplay#step3packageanddeploy") を参照してください。|
| **Run** | **Config Files** リストで選択したファイルに設定されているすべてのホスト上で、上記 **Applications** リストで選択したアプリケーションを起動します。 |
| **Kill** | Display Launcher が起動させたアンリアル エンジンのインスタンスすべてをシャットダウンします。|
| **Start listeners** | **Config Files** リストで選択したファイルに設定されている各ホスト上で、nDisplay Listener アプリケーションのインスタンスを起動します。|
| **Stop listeners** | この nDisplay Launcher が起動した nDisplay Listener アプリケーションのインスタンスすべてをシャットダウンします。|
| **Deploy application** | **Applications** リストで選択したアプリケーションを、 **Config Files** リストで選択したファイルで設定されている各ホストにコピーします。|
| **Copy** | 左側のログ ウィンドウに表示されているすべてのメッセージをクリップボードにコピーします。|
| **Clean** |左側のログ ウィンドウからすべてのメッセージを除去します。|

[COMMENT:none]
[EXCERPT:Excerpt_9]
nDisplay が生成する出力のタイプを指定します。
* Monoscopic: 非ステレオ レンダリング
*Frame sequential:能動的なクワッド バッファ ステレオ
*Side-by-side:受動的な水平配列ステレオ
*Top-bottom:受動的な垂直配列ステレオ

Monoscopic は特定のハードウェアの機能を必要としませんが、フレーム シーケンシャルはそれを必要とします。ディスプレイ デバイス、 GPU 、ドライバーの設定について、選択した Render mode と互換性があることを確認してくだい。
[/EXCERPT]
[/COMMENT]