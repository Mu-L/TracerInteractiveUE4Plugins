INTSourceChangelist:6666936
Availability: Public
Crumbs:
Title: nDisplay 를 사용한 다중 디스플레이 렌더링
Description: nDisplay 시스템을 사용하여 언리얼 엔진 프로젝트를 여러 디스플레이에 동시 렌더링하는 방법을 설명합니다.
Version: 4.22
Parent: Engine/Rendering
Order: 12
Tags: Rendering 
Tags: Graphics
hero-image: ndisplay_banner.png
topic-image: ndisplay_topic.png
tocend: 3


인터랙티브 콘텐츠를 꼭 하나의 화면, 또는 VR 헤드셋처럼 화면이 둘인 하나의 디바이스에 표시한다는 법은 없습니다. 갈수록 많은 수의 시각화 시스템이 실시간 콘텐츠를 여러 대의 디스플레이에 동시 렌더링하여 시청자의 게임 환경 몰입도를 높이는 것을 목표로 하고 있습니다. 이러한 시스템은 [Powerwall](https://en.wikipedia.org/wiki/Powerwall) 디스플레이처럼 여러 개의 화면을 붙인 것일 수도 있고, [Cave](https://en.wikipedia.org/wiki/Cave_automatic_virtual_environment) 가상 환경처럼 여러 대의 프로젝터로 돔, 벽 타일, 굽은 화면과 같은 물리 표면에 3D 환경을 만든 것일 수도 있습니다.

언리얼 엔진에서는 **nDisplay** 시스템을 사용하여 이러한 상황을 지원합니다. 이 시스템은 여러 디스플레이에 3D 콘텐츠를 동시 렌더링할 때 가장 중요한 몇 가지 문제를 해결합니다.

*   네트워크의 여러 컴퓨터에 프로젝트의 여러 인스턴스를 디플로이하고 실행하여, 각각 하나 이상의 디스플레이 디바이스에 렌더링하는 프로세스가 쉬워집니다.

*   각 화면의 뷰 프러스텀을 실시간 계산하는 데 드는 모든 계산을 관리합니다. 디스플레이 하드웨어의 공간 배치도 고려합니다.

*   여러 화면에 나타나고 있는 콘텐츠를 **정확히** 동기화시켜, 엔진의 모든 인스턴스에 예상한 그대로의 콘텐츠가 나오도록 합니다.

*   수동형 및 능동형 스테레오스코픽 렌더링을 제공합니다.

*   VR 트래킹 시스템의 입력으로 구동하여, 디스플레이의 시점이 현실에서의 시점 이동을 정확히 따르도록 할 수 있습니다.

*   화면의 개수나 방향과 상관 없이 모두 지원할 수 있을 만큼 유연하며, 모든 프로젝트에서 쉽게 재사용할 수 있습니다.

[REGION:tip]
nDisplay 는 [실시간 애니메이션으로 팬을 매료시킨 Childish Gambino](https://www.unrealengine.com/en-US/spotlights/childish-gambino-mesmerizes-fans-with-real-time-animation) 에서 비주얼의 핵심적인 부분을 담당했습니다. 아래 프로젝트 스포트라이트 비디오를 참고하세요!
[/REGION]

[OBJECT:EmbeddedVideo]
    [PARAMLITERAL:width]
    100
    [/PARAMLITERAL]
    [PARAMLITERAL:height]
    56.25
    [/PARAMLITERAL]
    [PARAMLITERAL:units]
    %
    [/PARAMLITERAL]
    [PARAMLITERAL:type]
    simple
    [/PARAMLITERAL]
	[PARAMLITERAL:videoid]
	DTAW0i7NSoo
	[/PARAMLITERAL]
[/OBJECT]

## nDisplay 시스템 개요

모든 nDisplay 구성은 **마스터** 컴퓨터가 하나, 추가 컴퓨터는 몇 개든 있을 수 있습니다.

*   네트워크의 컴퓨터마다 프로젝트를 패키지로 만든 실행 파일 인스턴스를 하나 이상 실행합니다.

*   각 언리얼 엔진 인스턴스는 화면이나 프로젝터같은 디바이스 둘 이상으로의 렌더링을 처리합니다.

*   언리얼 엔진 인스턴스가 처리하는 디바이스 각각에 대해, 똑같은 3D 씬에 하나의 시점을 렌더링합니다. 이 시점의 3D 월드 위치가 현실의 화면이나 투영 표면의 물리적 위치에 일치하도록 시점을 구성하면, 보는 사람이 가상 세계에 있는 듯한 느낌을 줄 수 있습니다.

*   마스터 노드는 Virtual-Reality Peripheral Networks (가상현실 주변장치망, VRPN) 디바이스 연결을 통해 스페이셜 트래커와 컨트롤러의 입력을 받아 그 입력을 연결된 모든 컴퓨터에 리플리케이트하는 것도 담당합니다.

![nDisplay network overview](ndisplay-setup.png "nDisplay network overview")(w:800)

위 이미지는 가능한 nDisplay 네트워크를 보여줍니다. 모든 nDisplay 네트워크처럼, 그 PC 중 하나가 마스터 노드 역할을 합니다. 이 마스터 노드는 VRPN 서버에서 시스템으로 입력을 받으며, 이 서버는 공간 추적 디바이스에서 오는 신호를 다른 컨트롤러 디바이스에 중계합니다. 이 네트워크에는 언리얼 엔진 프로젝트 다른 인스턴스를 실행하는 다른 PC 도 포함되어 있습니다. 이 클러스터 노드 각각은 하나 이상의 디스플레이 프로젝터를 구동합니다.

|||
| --- | --- |
| ![One instance, one device](ndisplay-oneinstance-onedevice.png)(w:300) | [INCLUDE:#excerpt_1] |
| ![Multiple instances, multiple devices](ndisplay-multipleinstances-multipledevices-2.png)(w:300) | [INCLUDE:#excerpt_2] |
| ![One instance, multiple devices](ndisplay-oneinstance-multipledevices.png)(w:300) | [INCLUDE:#excerpt_3] |

[COMMENT:none]
[EXCERPT:excerpt_3]
**하나의 애플리케이션 인스턴스가 여러 디스플레이 디바이스로 렌더링합니다.**  
이 옵션을 사용하면, 컴퓨터에 실행되는 언리얼 엔진 애플리케이션 인스턴스는 하나지만, 씬의 3D 공간 별도의 사각형 다수를 커다란 창 안의 여러 영역에 렌더링할 수 있습니다. 그런 다음 [NVIDIA Mosaic](https://www.nvidia.com/en-us/design-visualization/solutions/nvidia-mosaic-technology/) 또는 [NVIDIA Surround](https://www.nvidia.com/object/3d-vision-surround-technology.html) 와 같은 기술로 하나의 커다란 창을 분할한 뒤, 다양한 디스플레이 디바이스에 별도의 영역 각각을 렌더링합니다.  
이 시나리오에서 nDisplay 를 Mosaic 또는 Surround 와 같이 사용하면 여러 모니터가 같은 평면 위에 놓여있지 않아도 물리적 배치가 정확한 뷰포트를 렌더링할 수 있습니다. 그러나 언리얼 엔진 동일 인스턴스가 모든 뷰포트를 렌더링하고 있으므로, 한 컴퓨터에 여러 그래픽 카드가 설치되어 있어도 혜택을 볼 수 없습니다.  
[/EXCERPT:excerpt_3]
[/COMMENT]

[COMMENT:none]
[EXCERPT:excerpt_2]
**여러 애플리케이션 인스턴스가 각각 하나의 디스플레이 디바이스로 렌더링합니다.**  
그래픽 카드가 여러 개 설치되어 다중 디스플레이 디바이스 구동을 처리할 수 있는 컴퓨터가 네트워크에 있는 경우, 그 컴퓨터에서 언리얼 엔진 인스턴스를 다수 실행할 수 있습니다. 언리얼 엔진 각 인스턴스가 3D 공간의 다른 사각형을 렌더링하고, 각각을 다른 그래픽 카드로 보내도록 지시할 수 있습니다.  
이 방법은 프로젝트의 CPU 및 메모리 요구 사항이 가벼워서 동일한 컴퓨터에 여러 인스턴스를 실행할 수 있는 경우 좋습니다.
[/EXCERPT:excerpt_2]
[/COMMENT]

[COMMENT:none]
[EXCERPT:excerpt_1]
**하나의 애플리케이션 인스턴스가 하나의 디스플레이 디바이스로 렌더링합니다.**  
nDisplay 호스트를 셋업하는 가장 간단한 방법입니다. 필요한 각 프로젝터 또는 디스플레이 디바이스에 대해 하나의 컴퓨터를 셋업하여 해당 디바이스에 대한 렌더링을 처리합니다. 해당 컴퓨터에서 언리얼 엔진의 인스턴스를 하나 실행합니다. 일반적으로 이 시나리오에서는 3D 공간의 단일 직사각형을 단일 뷰포트로 렌더링하도록 해당 애플리케이션 인스턴스를 셋업합니다.
[/EXCERPT:excerpt_1]
[/COMMENT]

### nDisplay 컴포넌트

nDisplay 는 일반적인 언리얼 시스템 아키텍처에 여러 컴포넌트를 추가합니다.

*   언리얼 엔진 내에서 작동하는 플러그인입니다. 클러스터를 이루는 모든 애플리케이션 인스턴스 사이 정보를 통신하고 동기화시켜, 모든 인스턴스가 동시에 같은 프레임을 렌더링하는지, 각 디스플레이 디바이스가 게임 월드의 올바른 프러스텀을 렌더링하는지 등을 확인합니다.
*   **nDisplayLauncher** 라는 네트워크 프로비저닝 및 관리 애플리케이션이 있습니다. 네트워크의 한 컴퓨터에서 이 애플리케이션을 실행하면 네트워크의 모든 컴퓨터에서 언리얼 엔진 애플리케이션 패키지를 자동 실행 및 종료할 수 있습니다.
*   **nDisplayListener** 라는 별도의 리스너 애플리케이션이 있으며, 각 컴퓨터에서 실행됩니다 이 애플리케이션은 nDisplayLauncher 에서 오는 요청을 기다리다가(리스닝) 로컬 컴퓨터에서 그 요청을 처리합니다.
*   공유 구성 파일에는 nDisplay 가 올바른 컴퓨터에서 올바른 수의 인스턴스를 실행, 각 게임의 3D 월드를 올바른 시점에서 렌더링하여 모든 디스플레이 화면 또는 프로젝터에 끊어진 부분이 없는 것처럼 보이게 만드는 데 필요한 모든 세팅이 들어있습니다.  아래 [nDisplay 구성 파일에 대하여](#ndisplay구성파일에대하여) 부분을 참고하세요.

## 시작하기

여기서는 nDisplay 를 처음 시작하는 방법을 설명합니다.

[REGION:note]
**전제조건:**

*   화면, 프로젝트 등과 같은 물리적 장비 셋업이 완료되어 정상 작동하는지 확인합니다.

*   마스터 컴퓨터에서 사용하려는 Windows 계정에 nDisplay 네트워크에서 사용할 **모든** 컴퓨터에 대한 관리 권한이 있는지 확인하세요.

*   nDisplay 네트워크에서 사용하려는 모든 컴퓨터가 41000, 41001, 41002, 41003 포트를 통해 TCP/IP 통신을 수신할 수 있는지 확인하세요. (다른 포트를 사용하는 방법은 아래 [통신 포트 변경](#통신포트변경) 부분을 참고하세요.)

[/REGION]

### 1 단계 - nDisplay 프로젝트 셋업

nDisplay 를 사용하는 프로젝트를 셋업하는 가장 쉬운 방법은, **nDisplay** 템플릿 프로젝트를 통해 만드는 것입니다.

![템플릿에서 nDisplay 프로젝트 생성](ndisplay-create-from-template.png "템플릿에서 nDisplay 프로젝트 생성")

그러면 자동으로 nDisplay 플러그인이 활성화되고 샘플 구성 파일이 프로젝트에 추가되어 이미 기본 세팅으로 구성된 기본 레벨이 제공됩니다.

기존 프로젝트에 nDisplay 를 사용하려는 경우, 수동으로 똑같이 구성할 수 있습니다. 아래 [기존 프로젝트에 nDisplay 추가](#기존프로젝트에ndisplay추가) 부분을 참고하세요.

### 2 단계 - 구성 파일 셋업

네트워크에서 사용하려는 다른 컴퓨터, 렌더링할 화면 또는 프로젝터의 크기와 해상도, 3D 공간에서 해당 화면 사이 공간적 관계 등 의 정보를 nDisplay 에 알려야 합니다. 그러기 위해서는 이 모든 정보를 일련의 세팅으로 표현하는 구성 파일을 만들어야 합니다.

이 구성 파일을 만드는 부분이 nDisplay 구성에서 가장 까다로운 부분일 수 있으니, 주의해서 접근해야 합니다. 자세한 내용은, 아래 [nDisplay 구성 파일에 대하여](#ndisplay구성파일에대하여) 부분을 참고하세요.

일반적으로 구성 파일 셋업이 끝나면, 네트워크의 토폴로지가 변경될 때만 구성 파일을 수정하면됩니다. 예를 들면 렌더링할 컴퓨터를 변경해야 하는 경우라던가, 현실에서 실제 화면과 디스플레이 배열을 변경한 경우입니다.

프로젝트의 콘텐츠 폴더 안에 구성 파일을 저장합니다. 다음 단계에 사용할 것입니다.  

### 3 단계 - 패키지 및 디플로이

프로젝트의 콘텐츠를 변경할 때마다 게임 패키지를 만들고 구성 파일에서 식별한 모든 컴퓨터에 디플로이해야 합니다.

1.  언리얼 에디터에서, 게임을 Windows 용으로 패키징합니다. 자세한 내용은 [빌드 작업: 쿠킹, 패키징, 디플로이, 실행](Engine/Deployment/BuildOperations) 문서를 참고하세요.

2.  언리얼 엔진 설치 폴더 아래 *Engine\\Binaries\\DotNET\\nDisplayListener.exe* 애플리케이션을 찾습니다. 이 애플리케이션을 게임 패키지를 만든 .exe 파일이 들어있는 폴더로 복사합니다.

3.  프로젝트와 **nDisplay Listener** 애플리케이션의 *.exe* 패키지 파일이 들어있는 폴더를 구성 파일에서 클러스터 노드로 식별한 각 컴퓨터로 복사합니다.  
    폴더 위치는 모든 컴퓨터에 정확히 똑같아야 합니다.

4.  각 컴퓨터에서 *nDisplayListener.exe* 파일을 실행합니다.

nDisplay 를 클러스터의 각 컴퓨터에 디플로이하는 데 필요한 모든 것이 갖춰졌습니다. 애플리케이션 패키지 버전, nDisplay 클러스터 구성을 정의하는 구성 파일, **nDisplay Launcher** 애플리케이션에서 오는 지시를 대기하는 **nDisplay Listener** 도 실행되고 있습니다. 다음에는 **nDisplay Launcher** 를 사용하여 각 리스너에게 별도의 클러스터 노드로 프로젝트를 실행하도록 지시하겠습니다.

### 4 단계 - 모든 클러스터 노드 실행

구성 파일에서 식별한 모든 컴퓨터에 프로젝트를 성공적으로 디플로이한 이후, **nDisplayLauncher** 애플리케이션을 사용하여 모든 컴퓨터에서 프로젝트를 동시에 시작할 수 있습니다.

1.  이미 **nDisplayLauncher** 애플리케이션이 실행중이지 않으면, 실행합니다.  
    [REGION:lightbox]
    [![nDisplay Launcher](ndisplay-launch.png "nDisplay Launcher")](ndisplay-launch.png)  
    *클릭하면 이미지 원본을 확인합니다.*
    [/REGION]
    
2.  프로젝트 .exe 파일을 **Applications** (애플리케이션) 리스트에 추가합니다.  
    **애플리케이션** 리스트 아래 **추가** 를 클릭한 뒤, 프로젝트의 패키지를 만든 .exe 파일을 선택합니다. nDisplay Launcher 가 리스트에 새 애플리케이션을 추가합니다. 이름을 클릭하면 선택합니다.

3.  구성 파일을 지정합니다.  
    **Config Files** (구성 파일) 컨트롤 오른쪽 **Add** (추가) 버튼을 클릭한 뒤, 구성 파일을 찾아 선택합니다.

4.  **Run** (실행)을 클릭합니다.

**nDisplay Launcher** 가 구성 파일의 각 클러스터 노드에 있는 **nDisplay Listener** 에 메시지를 보내 프로젝트 패키지 실행을 지시합니다. 각 **nDisplay Listener** 의 상태 창에 명령이 표시되는 것이 보일 것입니다.

![nDisplay Listener receiving the Run command](ndisplay-listener.png "nDisplay Listener receiving the Run command")

그런 다음, 각 호스트의 nDisplay Listener 는 언리얼 엔진 애플리케이션을 실행하고, 메인 창에 대해 구성한 뷰포트(들) 렌더링을 시작합니다.

작업이 왼료된 후, **Kill** (킬)을 클릭하면 모든 컴퓨터에서 모든 언리얼 엔진 인스턴스를 자동 종료합니다. 또는 마스터 컴퓨터에서 실행 중인 언리얼 엔진 인스턴스를 종료하면 됩니다.

## nDisplay 구성 파일에 대하여

[REGION:tip]
nDisplay 구성 파일을 이해하고 직접 만들어보기 가장 좋은 방법은, nDisplay 플러그인에 제공된 예제 구성으로 시작하는 것입니다. nDisplay 템플릿에서 프로젝트를 만든 경우, `Content/ConfigExamples` 폴더에서 찾을 수 있습니다. 아니라면 언리얼 엔진 설치 폴더 아래 `Templates/TP_nDisplayBP/Content/ConfigExamples` 에서 찾을 수 있습니다.
[/REGION]

nDisplay 구성 파일의 구조는 시각화 렌더링에 사용되는 여러 컴포넌트 유형에 직접 묶여 있습니다.

* 구성하는 각기 다른 컴포넌트 유형마다 파일에 고유의 줄이 있으며, 할당하는 문자열 ID 로 식별합니다. 한 구성 섹션이 다른 섹션을 참조해야 할 때 이 문자열 ID 를 사용합니다.

* 이 파일에 구성하는 컴포넌트 다수에는 가상 3D 공간의 위치가 (종종 회전도) 정의되어 있습니다. 각 오브젝트의 위치와 회전은 그 오브젝트의 부모에 상대적입니다. 기본적으로 모든 오브젝트의 부모는 VR 공간 원점으로, VR 공간의 시작으로 간주되는 3D 세계 공간의 임의의 점입니다. 3D 공간에 scene_nodes 라는 구체적인 이름의 트랜스폼을 구성하면, 하나 이상의 컴포넌트에 대한 부모 역할을 할 수 있습니다. 화면, 카메라, 다른 컴포넌트의 공간 레이아웃을 단순화하는 데 도움이 됩니다.  
    scene_nodes 를 사용해서 가상 공간의 동일 지점에서 한꺼번에 시작되는 3D 트랜스폼 계층구조를 만들려면, 아래 예제 부분을 참고하세요.

*   가상 3D 공간이나 현실 물리적 공간을 측정하는 모든 파라미터 단위 기대값은 별도로 지정하지 않은 경우 미터 또는 도 입니다. 여기에는 화면, 씬 노드, 카메라 등이 포함됩니다.

*   화면 공간을 측정하는 모든 파라미터 기대값은 픽셀 단위입니다. 여기에는 창과 뷰포트가 포함됩니다.

### 클러스터 노드 구성

nDisplay 네트워크에서 사용할 언리얼 엔진 애플리케이션의 각 인스턴스에 대해 **cluster_node** 구성을 정의해야 합니다. 각 cluster_node 구성에는 메인 애플리케이션 창의 프로퍼티를 정의하는 window 구성 섹션에 대한 레퍼런스가 있어야 합니다.

cluster_node 구성은 애플리케이션 인스턴스를 실행하는 컴퓨터의 호스트 이름 또는 IP 주소를 정의하기도 합니다. 각 cluster_node 구성에 대해 각기 다른 물리적 컴퓨터를 셋업해도 되고, 같은 호스트에 실행되는 cluster_node 구성이 여러개여도 됩니다.

#### 예제 구성

이 예제는 (네트워크당 하나의) 마스터 노드 구성입니다.

    [cluster_node] id=node_front addr=192.168.0.1 window=wnd_LT sound=true port_cs=41001 port_ss=41002 master=true

이 예제는 마스터가 아닌 클러스터 노드입니다.

    [cluster_node] id=node_left addr=192.168.0.2 window=wnd_large sound=false

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 클러스터 노드 구성의 고유한 이름입니다. |
| **addr** | 이 언리얼 엔진 인스턴스를 실행할 컴퓨터의 IP 주소입니다. IPv4 주소여야 합니다. IPv6 는 지원하지 않습니다. |
| **window** | 언리얼 엔진 애플리케이션 이 인스턴스에 대한 주 창의 크기와 위치를 정의하는 window 구성 이름입니다. |
| **sound** | 이 언리얼 엔진 인스턴스의 사운드 재생 여부입니다. 옵션이며, 기본값은 `false` 입니다. |
| **port\_cs port\_ss port\_ce** | port_ss	클러스터 동기화 포트입니다. 마스터 노드가 클러스터의 다른 노드와 통신할 때 사용합니다. 옵션으로, 기본값은 `14001`, `14002`, `14003` 입니다. |
| **master** | 이 언리얼 엔진 인스턴스가 클러스터의 마스터 노드인지 여부입니다. 하나의 **cluster_node** 섹션만 이 파라미터를 true 설정할 수 있습니다. 옵션으로, 기본값은 `false` 입니다. |
| ** eye_swap ** | 왼쪽 눈과 오른쪽 눈에 대해 생성된 이미지를 서로 바꿀지 여부입니다. 옵션으로, 기본값은 `false` 입니다. |

### 창 구성

각 **창** 구성은 언리얼 엔진 애플리케이션 인스턴스의 기본 창에 대한 프로퍼티 세트를 정의합니다. nDisplay가 애플리케이션을 시작할 때 창의 시작 크기와 배치, 그리고 창이 전체 화면을 차지할 지 여부와 같은 것을 구성하는 데 사용합니다.

또한 nDisplay가 씬의 렌더링으로 채울 메인 프로그램 창의 특정 영역을 식별하는 하나 이상의 뷰포트 구성을 제공합니다.

#### 예제 구성

이 예제에서는 단일 뷰포트가 포함 된 애플리케이션 창을 구성합니다.

    [window] id=wnd_one fullscreen=false WinX=0 WinY=0 ResX=640 ResY=480 viewports=vp_LT

이 예제는 개별 뷰포트가 4 개인 애플리케이션 창을 구성합니다.

    [window] id=wnd_four fullscreen=false WinX=0 WinY=0 ResX=640 ResY=480 viewports="vp_LT,vp_RB,vp_LB,vp_RT"

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 뷰포트 구성의 고유명입니다. |
| **fullscreen** | 이 창을 전체화면 모드로 실행할지 여부를 결정합니다. 이 값을 `false` 설정하면, 아래와 같은 **WinX**, **WinY**, **ResX**, **RexY** 세팅을 제공해야 합니다. |
| **Winx WinY** | 데스크톱의 애플리케이션 창 좌상단 구석 위치를 화면 공간 픽셀 단위로 지정합니다. |
| **ResX ResY**	| 애플리케이션 창의 크기를 화면 공간 픽셀 단위로 지정합니다. |
| **viewports** | [INCLUDE:#excerpt_7] |

<!--
[EXCERPT:excerpt_7]
nDisplay 가 씬의 렌더링된 뷰를 채우는 메인 애플리케이션 창의 영역을 정의하는 **viewport** 구성 섹션 하나 이상에 대한 레퍼런스입니다.  
뷰포트를 하나 이상 지정하는 경우, **viewport** 구성 섹션 이름을 따옴표로 묶은 쉼표로 구분된 목록을 사용해야 합니다. 위의 두 번째 예제를 참고하세요.  
목록의 순서는 시각적 순서 또는 뷰포트 배치에 영향을주지 않습니다. 상위 창의 뷰포트 배치는 명명된 **viewport** 구성에서 정의됩니다.  
사용하는 뷰포트 정의가 창의 크기를 초과하지 않는지 확인하세요.
[/EXCERPT:excerpt_7]
-->

### 뷰포트 구성

위에서 설명한 각 **창** 구성은 하나 이상의 **viewport** 구성을 나타내며, 각 구성은 nDisplay가 씬을 렌더링한 뷰로 채울 사각형의 게임 창 영역을 정의합니다.

보통 뷰포트는 애플리케이션 창 좌상단 구석에서 시작하며, 너비와 높이를 설정하여 부모 창을 채웁니다. 하지만 부모 애플리케이션 창 안에서 뷰포트에 오프셋을 줘야 하는 경우가 있습니다. 예를 들어, 두 개의 프로젝터가 부분적으로 겹치는 경우, 또는 하나의 애플리케이션 창의 여러 위치에 별도의 뷰포트를 다수 호스팅해야 하는 경우입니다.  

#### 예제 구성

    [viewport] id=vp_LT X=0 Y=0 width=300 height=220 screen=scr_LT

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 뷰포트 구성의 고유명입니다. |
| **X Y** | 메인 애플리케이션 창 화면 공간 내 뷰포트 좌상단 구석의 픽셀 단위 좌표입니다. 참고로 이 값의 기준은 애플리케이션 창의 좌상단이며, 화면 자체의 좌상단이 아닙니다. |
| **width height** | 렌더링한 프레임의 픽셀 단위 너비와 높이입니다. 이 뷰포트를 사용하는 **cluster_node** 구성의 크기 파라미터로 설정한 게임 창 크기보다 커서는 안됩니다. |
| **screen** | 이 언리얼 인스턴스가 렌더링을 담당할 프로젝션 화면을 정의하는 **screen** 구성 이름입니다. |

### 화면 구성

여러가지 출력 디스플레이 각각은 현재 카메라 위치에서 씬을 렌더링하며, 3D VR 공간 위치와 크기로 지정한 사각형으로 정의한 프러스텀을 사용합니다. 이 사각형 각각은 **screen** 구성으로 정의합니다. 보통 이 프로젝션 화면은 렌더링에 사용하는 물리적 화면과 같은 크기의 VR 공간을 차지합니다.  

화면의 피벗 포인트는 항상 정가운데 지점입니다.

#### 예제 구성

부모 바로 앞에 있는 3 미터 x 3 미터 화면에 대한 정의입니다. 화면의 피벗 포인트가 크기 파라미터에 정의된 사각형 중심에 있기 때문에, Z 축에 1.5 미터 오프셋을 더해 화면 높이의 절반만큼 위로 올립니다.

    [screen] id=screen_front loc="X=1.5.Y=0,Z=1.5" rot="P=0,Y=0,R=0" size="X=3,Y=3" parent=screens

보는 사람 왼쪽의 화면을 정의하기 위해, 위치를 왼쪽으로 (Y 축 음수값) 이동하고 로컬 Y 축으로 (요) 회전합니다. 

    [screen] id=screen_left loc="X=0,y=-1.5,Z=1.5" rot="P=0,Y=-90,R=0" size="X=3,Y=3" parent=screens

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 화면 구성의 고유 이름입니다. |
| **loc** | VR 공간에서 이 화면의 중심 위치로, 그 부모 기준입니다. |
| **rot** | 화면이 향하는 방향의 각도 단위 피치(P), 요(Y), 롤(R) 값입니다. |
| **size** | 화면 사각형의 로컬 X 및 Y 축 미터 단위 총 크기입니다. |
| **parent** | 이 오브젝트의 부모로 사용하려는 **scene_node** 구성 이름입니다. 이 파라미터는 옵션입니다. 부모를 지정하면, **loc** 과 **rot** 파라미터에 설정한 값은 그 부모 위치 기준이 됩니다. 부모를 생략하면, **loc** 과 **rot** 파라미터에 설정한 값은 VR 루트 기준이 됩니다. |

### 카메라 구성

nDisplay 클러스터의 모든 인스턴스는 가상 세계의 동일한 위치에서 씬을 렌더링합니다. 잠재적 시점 각각은 **camera** 구성 줄로 정의합니다.  

실행시간에 그 시점 사이를 전환할 수 있습니다. 각 시점은 트래킹 디바이스로도 구동할 수 있습니다.

#### 예제 구성

    [camera] id=camera_static loc="X=0.Y=0,Z=1.7" tracker_id=VRPNTracking tracker_ch=0

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 카메라 구성의 고유 이름입니다. |
| **loc** | 이 카메라의 VR 공간 위치로, 그 부모 기준입니다. |
| **tracker_id** | 시간에 따른 카메라의 위치를 구동하고자 하는 VR 디바이스를 정의하는 **input** 구성 이름입니다. 옵션입니다. 이 파라미터를 생략하면, 카메라의 위치가 VR 공간에서 고정됩니다. |
| **tracker_ch** | **tracker_id** 를 입력하면, 이 파라미터는 nDisplay 가 데이터를 읽어오는 디바이스 채널을 지정합니다. |
| **parent** | 이 오브젝트의 부모로 사용하려는 **scene_node** 구성 이름입니다. 이 파라미터는 옵션입니다. 부모를 지정하면, loc 파라미터에 설정한 값은 그 부모 위치 기준입니다. 부모를 생략하면 loc 파라미터에 설정한 값은 VR 루트 기준입니다. |

### 씬 노드 구성

구성 파일에서는 씬 노드의 계층구조를 정의할 수 있으며, 그 각각은 3D 공간의 트랜스폼을 나타냅니다. 카메라나 프로젝션 화면처럼 구성 파일에 셋업한 것 중 3D 공간의 위치와 회전이 필요한 것은 무엇이든 이 *scene_node* 구성 중 하나를 부모로 사용할 수 있습니다. 그러면 시각화 시스템의 다른 모든 컴포넌트 사이 전체의 공간적 관계를 정의하는 데 도움이 됩니다.

카메라처럼, 씬 노드 역시 VR 트래킹 디바이스로 구동할 수 있습니다.

#### 예제 구성

다음 줄은 두 노드의 계층구조를 정의하며, 자손 노드에 부모 앞 2 미터의 오프셋이 있습니다.

    [scene_node] id=vr_space_root loc="X=0.Y=0,Z=0" rot="P=0,Y=0,R=0"
    [scene_node] id=walls_front_group loc="X=2.Y=0,Z=0" rot="P=0,Y=0,R=0" parent= vr_space_root

다음 줄은 VR 트래킹 디바이스로 구동하도록 구성한 씬 노드를 표시합니다.

    [scene_node] id=cave_wand loc="X=0, Y=0,Z=1" tracker_id=CaveTracking tracker_ch=1

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 씬 노드 구성의 고유명입니다. |
| **loc** | 이 씬 노드의 VR 공간 위치로, 부모 기준입니다. |
| **rot** | 씬 노드가 향하는 방향의 각도 단위 피치(P), 요(Y), 롤(R) 값입니다. |
| **parent** | 이 씬 노드의 부모로 사용하려는 **scene_node** 구성 이름입니다. 이 파라미터는 옵션입니다. 부모를 지정하면, **loc** 과 **rot** 파라미터에 설정한 값은 그 부모 위치 기준이 됩니다. 부모를 생략하면, **loc** 과 **rot** 파라미터에 설정한 값은 VR 루트 기준이 됩니다.|
| **tracker_id** | 시간에 따른 씬 노드의 위치를 구동하고자 하는 VR 디바이스를 정의하는 **input** 구성 이름입니다. 옵션입니다. 이 파라미터를 생략하면, 씬 노드의 위치와 회전은 VR 공간에 고정됩니다. |
| **tracker_ch** | **tracker_id** 를 입력하면, 이 파라미터는 nDisplay 가 데이터를 읽어오는 디바이스 채널을 지정합니다. |


### 입력 구성

nDisplay 시스템에 입력을 제공해야 하는 각 디바이스에 대한 **input** 섹션을 정의합니다. 각 **camera** 및 각 **scene_node** 는 **input** 섹션에 셋업하고 **camera** 또는 **scene_node** 구성에 참조한 VR 트래킹 디바이스를 통해 선택적으로 구동할 수 있습니다. 또는 트래커, 컨트롤러, 키보드를 셋업하여 일반 입력 이벤트를 언리얼 엔진 입력 시스템에 보내거나, 이벤트 및 입력 값을 프로젝트의 게임 플레이 스크립트에서 응답할 수있는 일반 nDisplay 블루프린트 노드에 바인딩할 수 있습니다.

**input_setup** 섹션을 사용하여 이러한 입력 디바이스의 특정 채널, 버튼 또는 키가 언리얼 엔진 내 특정 유형의 입력 이벤트 및 값에 바인딩되는 방식을 제어 할 수도 있습니다.

nDisplay 입력으로 무엇을 할 수 있는지에 대한 개요는 [VRPN 입력 사용](#vrpn입력사용) 부분을 참고하세요.  

#### 예제 구성

이 구성은 nDisplay 가 VRPN 위치 추적 디바이스에서 입력을 받도록 셋업합니다. 통상적으로 이러한 종류의 디바이스는 카메라 또는 시청자의 머리에 장착되거나, 시청자가 들고 있습니다. 카메라 또는 씬 노드의 위치를 트래커에서 자동 구동하는 방법은, 이 **input** 구성을 **camera** 또는 **scene_node** 구성에 참조하면 됩니다. 또는 프로젝트의 블루프린트 코드에서 이 트래커 값을 가져올 수도 있습니다.

    [input] id=CaveTracking type=tracker addr=Tracker0@192.168.0.1 loc="X=-1.5,Y=0,Z=3.4" rot="P-0,Y=0,R=0" front=X right=Y up=-Z

이 구성은 nDisplay 가 VRPN 디바이스로 셋업된 키보드에서 키보드 입력을 읽어, 그 입력을 내장 언리얼 엔진 키보드 입력을 경유시킵니다.

    [input] id=ControlKeyboard type=keyboard addr=Keyboard0@192.168.0.1 reflect=ue4

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | 이 씬 노드 구성의 고유명입니다. |
| **type** | [INCLUDE:#excerpt_11] |
| **addr** | [INCLUDE:#excerpt_12] |

[COMMENT:none]
[EXCERPT:excerpt_12]
이 특정 디바이스를 처리하는 VRPN 서버 주소입니다. 값은 다음 형식에 맞아야 합니다.  
`DEVICENAME@SERVER_ADDRESS:SERVER_PORT`  
여기서:  

*   `DEVICENAME` 은 이 디바이스의 VRPN 이름입니다.
*   `SERVER_ADDRESS` 는 VRPN 서버의 IPv4 주소입니다.
*   `:SERVER_PORT` 는 VRPN 서버가 들어오는 연결을 수신 대기하는 포트입니다.
    이 포트는 선택사항입니다. 제공하지 않으면 기본 포트는 `3883` 입니다.
[/EXCERPT:excerpt_12]
[/COMMENT]

[COMMENT:none]
[EXCERPT:excerpt_11]
이 VRPN 입력 디바이스의 유형은 다음과 같습니다.  

*   `tracker` 는 트래킹 디바이스입니다.
*   `analog` 는 축 데이터를 생성하는 디바이스입니다.
*   `button` 은 부울 버튼 데이터를 생성하는 디바이스입니다.
*   `keyboard` 는 표준 컴퓨터 키보드입니다.

[/EXCERPT:excerpt_11]
[/COMMENT]

`type=tracker` 인 디바이스는 다음과 같은 파라미터를 받을 수도 있습니다.

| 파라미터 | 설명 |
| --- | --- |
| **loc rot** | 다른 구성 섹션과 비슷하게, **loc** 과 **rot** 파라미터는 이 입력 디바이스의 로컬 공간에서 위치와 회전 오프셋을 지정합니다. 하지만 입력 디바이스의 경우, 일반적으로 이러한 오프셋으로 디바이스의 VR 공간 루트 위치가 씬 노드 계층서의 예상 위치에 맞도록 조정합니다. |
| **front right up** | [INCLUDE:#excerpt_14] |

[COMMENT:none]
[EXCERPT:excerpt_14]
이 파라미터는 언리얼의 트래커 로컬 축 (앞, 오른, 위) 각각을 트래커의 좌표계 해당 축에 일치시킵니다. 언리얼은 오른손잡이 Z 가 위인 좌표계를 사용합니다. 트래커가 다른 좌표계를 사용하는 경우, 이 파라미터를 사용하여 트래커의 좌표계를 언리얼에 매핑하면 됩니다.  
예를 들어 다음 선은 트래커의 Y 축을 언리얼의 앞(X) 축에, 트래커의 X 축을 언리얼의 오른(Y) 축에, 트래커의 Z 축을 언리얼의 위(Z) 축에 매핑합니다.  
`front=Y right=X up=-Z`
[/EXCERPT:excerpt_14]
[/COMMENT]

`type=keyboard` 인 디바이스는 다음과 같은 파라미터도 받습니다.

| 파라미터 | 설명 |
| --- | --- |
| **reflect** | [INCLUDE:#excerpt_15] |

[COMMENT:none]
[EXCERPT:excerpt_15]
이 키보드의 입력을 언리얼 엔진에 전달하고, 그 이벤트에 반응하는 방법을 정의합니다.  
이 세팅이 받는 값은 다음 중 하나입니다.  

*   **nDisplay**
*   **ue4**
*   **both**
*   **none**

자세한 정보는 [키보드 이벤트 반영](#키보드이벤트반영) 부분을 참고하세요.  

[/EXCERPT:excerpt_15]
[/COMMENT]

### 입력 셋업 구성

각 **input_setup** (입력 셋업) 구성은 지정된 **input]** 디바이스에 대한 추가 구성 파라미터를 제공하며, 일반적으로 그 디바이스에서 범용 nDisplay 블루프린트 입력 노드로 채널 또는 키를 바인딩합니다.

#### 예제 구성

이 구성은 ID 컨트롤러로 입력 디바이스를 셋업해서 버튼이 눌리면 채널 0 에 이벤트를 생성하도록, 블루프린트의 **Input > **N Display Events > **nDisplay Button 0** 노드에서 이벤트가 생성되도록 합니다.

    [input_setup] id=controller ch=0 bind="nDisplay Button 0"

이 구성은 위와 비슷하지만, 차이점은 (일반적으로 컨트롤러의 축과 같은) 아날로그 값을 nDisplay 아날로그 값으로 바인딩한다는 점입니다. 블루프린트의 **Input > N Display Events > nDisplay Analog 0** 노드를 사용하여 컨트롤러 축 사용 시점을 감지하거나, **Input > N Display Values > nDisplay Analog 0** 로 현재 프레임에 대한 값을 가져올 수 있습니다.

    [input_setup] id=test_axes ch=0 bind="nDisplay Analog 0"

키보드 디바이스를 사용하는 경우, 그 키 각각을 구체적으로 바인딩할 필요가 없습니다. 대신, **input** (입력) 섹션의 **reflect** (반영) 세팅만 사용해도 키 이벤트 라우팅을 내장 언리얼 엔진 키보드 이벤트로 할지, nDisplay 키보드 이벤트로 할지 결정할 수 있습니다. 그러나 원한다면 바인딩 변경이 추가도 가능합니다. 예를 들어, 이 섹션은 스페이스 바로 **Input > N Display Events > nDisplay Button 3** 이벤트를 트리거합니다.

    [input_setup] id=keyboard0 key=Space bind="nDisplay Button 3"

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **id** | [INCLUDE:#excerpt_16] |
| **ch** | **bind** 세팅에 설정한 이벤트에 바인딩되는 지정 입력 디바이스의 채널을 결정합니다. |
| **key** | **ch** 와 비슷하지만, type=keyboard 인 입력 디바이스에 대해서만 사용됩니다. |
| **bind** | [INCLUDE:#excerpt_17] |

[COMMENT:none]
[EXCERPT:excerpt_17]
언리얼 엔진에서 위에 지정한 채널 또는 키를 바인딩할 이벤트를 결정합니다. 이 값은 **Input** 카테고리에서 볼 수 있는 **F1**, **nDisplay F1**, **nDisplay Button 0**, **Gamepad Left Thumbstick X-Axis**, **Gamepad Face Button Top** 등과 같은 블루프린트 노드 이름이 될 수 있습니다.  
이름에 공백이 있으면 큰 따옴표로 묶어야 합니다.
[/EXCERPT:excerpt_17]
[/COMMENT]

[COMMENT:none]
[EXCERPT:excerpt_16]
이 **input_setup** 섹션에서 구성하는 **input** 구성의 ID를 나타냅니다.  
nDisplay 구성 파일의 대부분의 다른 섹션과 달리 이 **id** 값은 이를 포함하는 **input_setup** 섹션에 대한 ID를 제공하지 않습니다. 대신 파일의 다른 곳에서 정의 된 **input** 섹션의 ID를 나타냅니다.
[/EXCERPT:excerpt_16]
[/COMMENT]

[REGION:tip]
입력 모듈 API의 노드를 사용하여 프로젝트의 블루프린트 코드에서 이러한 채널 및 키 바인딩을 셋업할 수도 있습니다. 자세한 내용은 [디바이스 채널을 UE4 입력에 바인딩](#디바이스채널을UE4입력에바인딩) 부분을 참고하세요.
[/REGION]

### 일반 구성

**general** 구성줄에는 nDisplay 클러스터의 전반적인 작동을 제어하는 파라미터가 들어있습니다.

#### 예제 구성

    [general] swap_sync_policy=1

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **swap\_sync\_policy** | [INCLUDE:#excerpt_18] |

[COMMENT:none]
[EXCERPT:excerpt_18]
네트워크를 통한 출력 동기화 방식을 결정합니다.  

*   0: 동기화가 없습니다.
*   1: 소프트웨어 스왑 동기화입니다.
*   2: NV 스왑 잠금입니다 (OpenGL 렌더링하는 NVIDIA 카드 전용입니다).

[/EXCERPT:excerpt_18]
[/COMMENT]

### 스테레오 구성

**stereo** 구성줄은 스테레오스코픽 렌더링을 위한 옵션 글로벌 파라미터를 설정합니다.

#### 예제 구성

    [stereo] eye_dist=0.064

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| ** eye_dist ** | 왼쪽 눈과 오른쪽 눈에 대해 생성된 이미지의 오프셋으로 사용할 눈 사이 거리 (미터)입니다. |

### 네트워크 구성

**network** 구성 섹션에는 nDisplay 클러스터 노드 사이 타임아웃 및 네트워크 통신 관련 다른 세팅을 제어할 때 사용할 수 있는 세팅이 제공됩니다.

nDisplay 구성 파일의 **network** 섹션은 없거나 있어도 하나입니다.

#### 예제 구성

    [network] cln_conn_tries_amount=10 cln_conn_retry_delay=1000 game_start_timeout=30000 barrier_wait_timeout=5000

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **cln\_conn\_tries_amount** | [INCLUDE:#excerpt_tries] |
| **cln\_conn\_retry_delay** | [INCLUDE:#excerpt_delay] |
| **game\_start\_timeout** | [INCLUDE:#excerpt_starttimeout] |
| **barrier\_wait\_timeout** | [INCLUDE:#excerpt_barriertimeout] |
 
<!--
[EXCERPT:excerpt_tries]
마스터가 아닌 클러스터 노드가 시작할 때, 노드가 마스터로 연결을 재시도하는 횟수를 결정합니다.  
옵션이며, 기본값은 10 입니다.
[/EXCERPT:excerpt_tries]
-->
<!--
[EXCERPT:excerpt_delay]
마스터가 아닌 클러스터 노드가 시작할 때, 노드가 마스터로의 연결 재시도 성공 사이 간격을 결정하는 밀리초 단위 시간입니다.  
옵션이며, 기본값은 1000 입니다.
[/EXCERPT:excerpt_delay]
-->
<!--
[EXCERPT:excerpt_starttimeout]
각 클러스터 노드에서 각 언리얼 엔진 애플리케이션이 게임 루프 첫 프레임을 시작한 후 메인 창 렌더링을 시작할 때까지 기다리는 간격을 밀리초 단위로 설정합니다. 모든 클러스터 노드가 렌더링을 시작하기 전 마스터에 연결할 수 있는 기회를 줍니다. 이 기간 동안 메인 창은 검정이 됩니다. 이 기간이 끝나고도 연결된 노드가 없으면, 클러스터의 모든 인스턴스가 종료됩니다.  
옵션이며, 기본값은 30000 입니다. 클러스터 초기화에 시간이 비정상적으로 오래 걸린다면 이 값을 높여야 할 것입니다.
[/EXCERPT:excerpt_starttimeout]
-->
<!--
[EXCERPT:excerpt_barriertimeout]
게임 및 렌더 스레드의 바리어 타임아웃을 밀리초 단위로 설정합니다. 클러스터 노드 사이 게임 및 렌더 스레드 양쪽의 동기화를 위한 바리어 타임아웃입니다. 다른 말로, 런타임에 이 값을 사용하여 노드에 도달할 수 없는 상황을 감지합니다. 그런 상황이 발생하면, 클러스터 상태를 유효하지 않은 것으로 결정하고, 모든 노드를 자체적으로 중단시킵니다.  
옵션이며, 기본값은 5000 입니다.
[/EXCERPT:excerpt_barriertimeout]
-->

**cln\_conn\_tries_amount** 및 **cln\_conn\_retry_delay** 두 가지 세팅으로 클러스터 노드 시작 시 마스터 노드에 연결을 시도할 최대 기간을 결정합니다. 예를 들어, **cln\_conn\_tries_amount** 는 10 이고 **cln\_conn\_retry_delay** 는 1000 밀리초로 설정되었다 칩시다. 시작 시, 각 노드는 마스터에 연결 시도합니다. 그 연결이 실패하면, 1000 밀리초 기다렸다 재시도합니다. 그 재시도도 실패하면, 다시 한 번 1000 밀리초 기다립니다. 그렇게 10 번 연속 실패하면, 클러스터 노드는 자동 종료됩니다. 클러스터 노드가 마스터 노드에 연결되자마자, 카운트를 멈춥니다.

### 정보 구성

**info** 구성줄은 이 구성 파일이 호환되는 것으로 알려진 nDisplay 및 언리얼 엔진 최신 버전에 대한 선택적 정보가 포함됩니다.

#### 예제 구성

    [info] version=22

#### 파라미터

| 파라미터 | 설명 |
| --- | --- |
| **version** | [INCLUDE:#excerpt_21] |

[COMMENT:none]
[EXCERPT:excerpt_21]
이 구성 파일이 호환되는 것으로 알려진 nDisplay 및 언리얼 엔진 최신 버전입니다.  
이 숫자는 `4.` 뒤의 버전으로 이해해야 합니다. 예를 들어 값이 22 면 nDisplay 및 언리얼 엔진 4.22 버전과 호환됨을 의미합니다.
[REGION:note]
이 값은 직접 설정하지 마세요. **nDisplay Launcher** 가 자동 설정합니다. 버전이 없는 구성 파일을 사용하거나 파일의 버전이 사용중인 nDisplay 및 언리얼 엔진 버전보다 낮은 경우에는 **nDisplay Launcher** 가 자동으로 구성 파일을 업데이트하여 최신 버전에서 작동하도록 합니다. 성공하면 업데이트된 구성을 새 파일에 저장하고 이 값을 최신 버전으로 업데이트합니다.
[/REGION]
[/EXCERPT:excerpt_21]
[/COMMENT]

### 예제 구성

구체적인 예제로 *wall_flat_3x2.cfg* 샘플 파일을 엽니다. 이 파일은 6 개의 프로젝션 화면을 정의하며, 각각은 별도의 물리적 컴퓨터로 렌더링합니다.

여러 개의 scene_node 도 정의하는데, 모여서 다음과 같은 계층구조를 만듭니다.

![nDisplay example scene hierarchy](ndisplay-scene-hierarchy.png "nDisplay example scene hierarchy")

이 계층의 상대 위치와 회전은 VR 공간에서 카메라와 1 미터 거리에 6 개의 프로젝션 화면이 나란히 오도록 레이아웃을 정합니다. 

[REGION:lightbox]
[![nDisplay example layout](ndisplay-example-layout.png "nDisplay example layout")](ndisplay-example-layout.png)  
*클릭하면 이미지 원본을 확인합니다.*
[/REGION]

참고로 위 구성은 인접한 프로젝션 화면 사이에 씬을 렌더링하는 모니터의 테두리 부분을 고려한 작은 공간이 있음을 암시합니다.

## 블루프린트 API

블루프린트 API를 사용하여 게임의 런타임 로직에서 nDisplay 시스템의 동작을 제어 할 수 있습니다.

이 API 에 노출된 함수를 얻으려면:

1.  클러스터 관리, 입력 디바이스 쿼리, nDisplay 렌더링 등과 관련된 대부분의 nDisplay 블루프린트 함수는 블루프린트에 **N Display > Get DisplayCluster Module API** 노드를 새로 만듭니다.  
    VRPN 입력 디바이스와 언리얼 엔진 입력 이벤트 사이 바인딩과 반영을 셋업하는 함수의 경우, **N Display > Get DisplayClusterInput Module API** 노드를 블루프린트에 새로 생성합니다. [디바이스 채널을 UE4 입력에 바인딩](#디바이스채널을UE4입력에바인딩) 부분을 참고하세요.
2.  노드의 **Out API** 핀을 끌어 놓고, **Display Cluster** 또는 **Display Cluster Input** 카테고리 아래를 보면 됩니다.
    [REGION:lightbox]
    [![](bp_apis.png "bp_apis.png")](bp_apis.png)  
    *클릭하면 이미지 원본을 확인합니다.*
    [/REGION]
    

## 액터 리플리케이션

nDisplay 시스템의 모든 입력은 마스터 노드만 처리합니다. 리플리케이션이 없으면, 마스터 노드만 씬의 변화를 볼 수 있습니다. 따라서 마스터 노드는 변경 사항을 nDisplay 네트워크의 다른 모든 부분에 리플리케이트할 수 있어야 합니다.

그러기 위해, nDisplay 는 액터에 붙일 수 있는 두 가지 유형의 컴포넌트를 제공합니다.

*   **DisplayClusterSceneComponentSyncParent** 컴포넌트는 부모 컴포넌트의 3D 트랜스폼 변화를 트래킹한 뒤, 네트워크의 다른 클러스터 노드에 푸시합니다.  
    nDisplay 시스템이 사용하는 기본 DisplayClusterPawn 은 이 컴포넌트를 사용합니다.  
    
*   **DisplayClusterSceneComponentSyncParent** 컴포넌트는 자손 컴포넌트의 3D 트랜스폼 변화를 트래킹한 뒤, 네트워크의 다른 클러스터 노드에 푸시합니다.

예를 들어 아래 표시된 액터에서, **DisplayClusterSceneComponentSyncParent_DefaultSceneRoot** 컴포넌트는 액터가 레벨을 이동함에 따라 부모 액터의 3D 트랜스폼 변화를 트래킹하여 리플리케이트합니다. **DisplayClusterSceneComponentSyncThis** 컴포넌트는 씬 그래프 루트를 기준으로 움직이면서 자손 큐브 컴포넌트의 움직임을 트래킹하고 동기화합니다.

![DisplayClusterSceneComponentSyncParent ](ndisplay-actor-replication.png "DisplayClusterSceneComponentSyncParent ")

씬에 게임플레이 도중 영향을 받을 수 있는 다른 액터가 있는 경우, 위의 두 컴포넌트 중 하나를 사용해서 변화를 모든 노드에 리플리케이트해야 합니다. 그 방법은 다음과 같습니다.

1.  레벨 뷰포트 또는 **월드 아웃라이너** 패널에서 리플리케이트하려는 액터를 선택합니다.
2.  **디테일** 패널에서 **\+ 컴포넌트 추가** 를 클릭합니다. **DisplayClusterSceneComponentSyncParent** 또는  **DisplayClusterSceneComponentSyncThis** 를 검색한 뒤 목록에서 선택합니다.  
    ![nDisplay 동기화 컴포넌트 추가](ndisplay-actor-replication-selection.png "nDisplay 동기화 컴포넌트 추가")

[REGION:note]
이 컴포넌트는 전체 리플리케이션을 하지 않습니다. 부모 액터의 또는 자손 컴포넌트의 트랜스폼만 클러스터로 전송합니다.
[/REGION]

## VRPN 입력 사용

nDisplay 에 [VRPN](https://en.wikipedia.org/wiki/VRPN) 입력 디바이스를 사용하는 방법은 다음과 같습니다.

1.  네트워크에 VRPN 서버를 설치합니다.  
    nDisplay 이 버전은 VRPN **버전 7.33** 이 필요합니다.
2.  서버의 실행파일 옆에서 찾을 수 있는 *vrpn.cfg* 파일에서, 입력 디바이스를 활성화하고 이름을 짓습니다.
3.  nDisplay 구성 파일에 **input** 항목을 추가하여 VRPN 입력 디바이스를 구성합니다.

설정해야 하는 입력 디바이스의 종류와 해당 디바이스의 입력을 언리얼 엔진 프로젝트에 적용하는 방법에 따라 입력 구성에 다른 세팅을 사용하고 몇 가지 추가 단계를 수행해야 할 수 있습니다. 가능한 모든 옵션에 대한 자세한 내용은 다음 섹션을 참고하세요.

### VRPN 트래커를 nDisplay 카메라 또는 씬 노드에 바인딩

VRPN 트래커 디바이스가 있는 경우, 그 현재 위치를 nDisplay 구성 파일에 셋업한 nDisplay 카메라 또는 씬 노드에 바로 매핑할 수 있습니다. 현실 공간에서 트래커를 움직이면서, 그 카메라 또는 씬 노드의 위치가 가상 공간에서 자동으로 업데이트되어 추적됩니다.

그 방법은 nDisplay 구성 파일에서 **input** 및 **camera** 섹션을 셋업하면 됩니다.

다음 예는 ART DTrack 트래킹 시스템을 셋업하는 한 가지 방법을 보여줍니다.

*   VRPN 서버 exe 옆의 Vrpn.cfg 에 다음 줄을 추가합니다.
    
        vrpn_Tracker_DTrack DTrack  5000
    
    그러면 VRPN 이 5000 포트에서 DTrack 입력을 받아 DTrack 이라는 이름의 VRPN 디바이스에 매핑합니다. (DTrack 이 5000 포트의 데이터를 트래킹하도록 구성했는지 확인하세요.)
*   nDisplay 구성 파일에 다음 줄을 추가합니다.
    
        [input] id=CaveTracking type=tracker addr=DTrack@127.0.0.1 loc="X=1.32,Y=0,Z=0.93735" rot="P=0,Y=0,R=0" front=Z right=-X up=Y
        [camera] id=camera_dynamic loc="X=0,Y=0,Z=0" tracker_id=CaveTracking tracker_ch=0
    
    첫 줄은 **CaveTracking** 라는 이름으로 nDisplay 입력 디바이스를 생성합니다. VRPN 주소 **DTrack@127.0.0.1** 에서 데이터를 가져 옵니다. 트래킹 시스템과 오프셋에 맞게 좌표계를 조정해야 합니다. 두 번째 줄 카메라 구성은 nDisplay 에게 **0** 채널의 **CaveTracking** 입력에서 카메라 위치를 가져오도록 합니다.

### 키보드 이벤트 반영

VRPN 서버에 대한 키보드 디바이스를 구성해 둔 경우, 그 키보드의 (키 눌림과 뗌과 같은) 이벤트가 언리얼 엔진 프로젝트에 반영되는 방식을 제어할 수 있습니다. 키보드 키가 표준 UE4 키보드 입력 시스템을 트리거하도록 만들거나, 키 트리거를 nDisplay 에 제공된 새 키보드 입력으로 돌리거나, 그 둘 다 하거나, 아무것도 안할 수도 있습니다.

그 셋업 방법은 둘 중 하나입니다.

*   nDisplay 구성 파일에서 키보드 디바이스를 정의하는 **input** 섹션에 **reflect** 옵션을 설정하면 됩니다.
    
        [input] id=ControlKeyboard type=keyboard addr=Keyboard0@192.168.0.1 reflect=ue4
    
*   또는 프로젝트의 블루프린트 코드에서 **Set VRPN Keyboard Reflection** 함수를 호출해도 됩니다.  
    ![Keyboard reflection in Blueprint](keyboard-reflection-bp.png "Keyboard reflection in Blueprint")

반영 세팅이 받는 값은 다음 중 하나입니다.

| \[input\] 세팅 | 블루프린트 옵션 | 설명 |
| --- | --- | --- |
| **nDisplay** | **nDisplay 버튼 전용** | 키보드 이벤트가 nDisplay 에 생성된 새로운 키보드 입력 이벤트로 라우팅됩니다. 블루프린트 스크립트에서 이 이벤트에 대한 반응은 **Input > N Display Keyboard Events** 카테고리의 노드를 사용하면 됩니다. |
| **ue4** | **네이티브 UE4 키보드 이벤트** | 키보드 이벤트가 언리얼 엔진 내장 입력 시스템을 통해 라우팅됩니다. 이 이벤트에 대한 반응은 애플리케이션에서 사용하는 **InputController** 클래스에서, 또는 블루프린트 스크립트의 **Input > Keyboard Events** 카테고리 노드에서 할 수도 있습니다. |
| **both** | **nDisplay 및 UE4 네이티브 둘 다** | 키보드 이벤트가 nDisplay 키보드 처리 시스템과 언리얼 엔진 내장 입력 시스템 둘 다에 라우팅됩니다. 앞서 설명한 메서드 중 하나를 사용해서 각자의 이벤트에 반응하도록 할 수 있습니다. |
| **none** | **반영 없음** | [INCLUDE:#excerpt_23] |

<!--
[EXCERPT:excerpt_23]
키보드 이벤트가 nDisplay 키보드 처리 시스템 또는 내장 입력 시스템 어디로도 라우팅되지 않습니다.  
이 옵션을 사용하면, 다음 중 한 가지 작업을 해야 합니다:  

*   nDisplay 블루프린트 API 에서 블루프린트 노드를 사용하여 특정 이벤트에 대한 쿼리를 해야 합니다. 예: **Display Cluster > Input > Was VRPN Button Pressed** 또는 **Display Cluster > Input > Was VRPN Button Released**. [디바이스 입력 쿼리](#디바이스입력쿼리) 부분을 참고하세요.
*   개별 키를 UE4 의 다른 입력 이벤트로 바인딩합니다. 자세한 내용은 [디바이스 채널을 UE4 입력에 바인딩](#디바이스채널을UE4입력에바인딩) 부분을 참고하세요.

[/EXCERPT:excerpt_23]
-->

키보드 디바이스에 대한 반영을 셋업할 때, 그 세팅은 해당 디바이스의 모든 키에 적용됩니다. 그러나 여전히 UE4 의 다른 입력 이벤트에 개별 키를 다시 바인딩할 수도 있습니다. 자세한 내용은 [디바이스 채널을 UE4 입력에 바인딩](#디바이스채널을UE4입력에바인딩) 부분을 참고하세요.

### 디바이스 채널을 UE4 입력에 바인딩

VRPN 디바이스의 특정 채널을 언리얼 엔진 이벤트와 모션 소스에 바인딩하면 프로젝트가 VRPN 입력에 반응하도록 만들 수 있습니다. 이러한 바인딩을 만드는 방법은 다음 둘 중 하나입니다.

*   nDisplay 구성 파일의 **input_setup** 섹션을 모션 소스 또는 이벤트를 바인딩하려는 채널 각각에 대해 셋업합니다.
*   nDisplay 입력 모듈 API 에 사용할 수 있는 함수를 사용합니다.  
    ![Bind VRPN device channel](input-module-api.png "Bind VRPN device channel")

#### 예: 트래킹 디바이스를 모션 소스에 바인딩

VRPN 모션 트래킹 디바이스는 언리얼 엔진의 기존 모션 소스에 바인딩할 수 있습니다. 그런 다음 그 모션 소스를 사용하여 레벨의 액터에 할당한 MotionControllerComponent 를 구동합니다.

셋업 방법은 다음과 같습니다.

1.  nDisplay 구성 파일에 트래커를 정의하는 **input** 섹션이 있어야 합니다. 예:
    
        [input] id=TestTrack type=tracker addr=Tracker0@127.0.0.1 loc="X=0,Y=0,Z=0" rot="P=0,Y=0,R=0" front=X right=Y up=Z
    
2.  또한 트래킹하려는 디바이스와 채널을 입력을 받고자 하는 모션 소스에 바인딩해야 합니다.  
    그 방법은 구성 파일에 **input_source** 섹션을 추가하면 됩니다.  
    
        [input_setup] id=TestTrack ch=0 bind="Special_1"
    
    프로젝트의 블루프린트 코드에서 **Bind VRPN Tracker** 함수를 호출하고 같은 값을 설정해도 됩니다.  
    ![Bind VRPN Tracker](input-bind-tracker.png "Bind VRPN Tracker")

#### 예: 아날로그 디바이스에 바인딩

아날로그 VRPN 디바이스는 0-1 범위 입력 값이 나오며, 언리얼 엔진의 마우스 또는 섬스틱 입력과 비슷합니다.

nDisplay 에는 아날로그 VRPN 디바이스를 바인딩할 수 있는 20 개의 범용 아날로그 입력 세트가 포함되어 있습니다. 찾을 수 있는 위치는 **Input > N Display Events** and **Input > N Display Values** 카테고리입니다.

![nDisplay generic analog events and values](input-bind-analog-events.png "nDisplay generic analog events and values")

이 nDisplay 아날로그 입력을 사용할 필요 없이, VRPN 디바이스를 다른 UE4 입력에 바인딩해도 됩니다. 다음 예제에서 둘 다 확인할 수 있습니다.  

셋업 방법은 다음과 같습니다.

1.  nDisplay 구성 파일에 아날로그 장configuration file to have an **input** section that defines the analog device. 예:
    
        [input] id=TestAxes type=analog addr=Mouse0@127.0.0.1
    
2.  입력을 받으려는 아날로그 입력을 트래킹할 디바이스와 채널도 바인딩해야 합니다. 흔히 아날로그 디바이스에는 X 축 입력에 하나, Y 축에 하나, 두 개의 채널이 있습니다. 이 경우 일반적으로 두 축을 다른 nDisplay 아날로그 입력에 개별적으로 바인딩해야 합니다.  
    구성 파일에 **input_source** 섹션을 둘 추가하면 됩니다.  
    
        [input_setup] id=TestAxes ch=0 bind="nDisplay Analog 0"
        [input_setup] id=TestAxes ch=1 bind="Gamepad Left Thumbstick Y-Axis".
    
    또는 프로젝트의 블루프린트 코드에서 **Bind VRPN Channel** 함수를 호출하고 값을 똑같이 설정해도 됩니다.  
    ![Bind VRPN Channel for analog device](input-bind-analog.png "Bind VRPN Channel for analog device")
3.  입력 이벤트가 발생했는지 감지하거나, 입력 축의 실제 값을 가져와야 할 때, VRPN 축 채널을 바인딩한 입력 이벤트를 사용하세요.  
    예를 들어 이 경우 다음을 사용합니다.
    *   첫 번째 축에 대해, **Input > N Display Events > nDisplay Analog 0** 으로 입력 이벤트에 응답하고, **Input > N Display Values >  nDisplay Analog 0** 으로 현재 축 값을 얻습니다.
    *   두 번째 축에 대해, **Input > Gamepad Events > Gamepad Left Thumbstick Y-Axis** 로 입력 이벤트에 응답하고, **Input > Gamepad Values > Gamepad Left Thumbstick Y-Axis** 로 현재 축 값을 얻습니다.

#### 예: 버튼 디바이스 바인딩

버튼 VRPN 디바이스는 버튼을 누르고 뗄 때마다 주어진 채널에 이벤트를 발동시킵니다.

nDisplay 에는 버튼 디바이스를 바인딩할 수 있는 20 개의 일반 버튼 이벤트 입력 세트가 포함되어 있습니다. 찾을 수 있는 위치는 **Input > N Display Events** 카테고리입니다.

![nDisplay generic button events](input-bind-button-events.png "nDisplay generic button events")

이 nDisplay 버튼 입력을 사용할 필요는 없으며, VRPN 디바이스를 다른 UE4 입력에 바인딩할 수도 있습니다. 다음 예제에서는 이 두 가지를 보여줍니다.  

셋업 방법은 다음과 같습니다.

1.  nDisplay 구성 파일에 버튼 디바이스를 정의하는 **input** 섹션이 있어야 합니다. 예:
    
        [input] id=TestBtn type=buttons addr=Mouse0@127.0.0.1
    
2.  입력을 받으려는 버튼 입력을 트래킹할 디바이스와 채널도 바인딩해야 합니다.  
    그 방법은 구성 파일에 **input_source** 섹션을 추가하면 됩니다.  
    
        [input_source] id=TestBtn ch=0 bind="nDisplay Button 0"
        [input_source] id=TestBtn ch=2 bind="Gamepad Face Button Top"
    
    또는 프로젝트의 블루프린트 코드에서 **Bind VRPN Channel** 함수를 호출하고 값을 똑같이 설정하면 됩니다.  
    ![Bind VRPN Channel for button device](input-bind-buttons.png "Bind VRPN Channel for button device")
3.  입력 이벤트가 발생했는지 감지하려면, VRPN 버튼 채널을 바인딩한 입력 이벤트를 사용하세요.  
    예를 들어, 이 경우 **Events > N Display Events > nDisplay Button 0** 및 **Events > Gamepad Events > Gamepad Face Button Top** 노드를 사용합니다.

#### 예: 키보드 디바이스 바인딩

위의 [키보드 이벤트 반영](#키보드이벤트반영) 부분의 설명대로, VRPN 키보드를 내장 언리얼 엔진 키보드 입력에 바인딩할 수도, 새로운 nDisplay 키보드 입력에 바인딩할 수도, 둘 다 할 수도, 아무 것도 안할 수도 있습니다. 어떤 유형 반영이든 상관없이, 키보드의 개별 키를 다른 언리얼 엔진 또는 nDisplay 입력 이벤트에 바인딩할 수도 있습니다.

셋업 방법은 다음과 같습니다.

1.  nDisplay 구성 파일에 키보드 디바이스를 정의하는 **input** 섹션이 있어야 합니다. 예:
    
        [input] id=TestKb type=keyboard addr=Keyboard0@127.0.0.1
    
2.  그 키가 트리거할 언리얼 엔진 입력 이벤트로 트래킹하려는 디바이스와 키도 바인딩해야 합니다.  
    그 방법은 구성 파일에 **input_source** 섹션을 추가하면 됩니다.  
    
        [input_source] id=TestBtn key="Space Bar" bind="Gamepad Left Trigger"
    
    프로젝트의 블루프린트 코드에서 **Bind VRPN Keyboard ** 함수를 호출하고 같은 값을 설정해도 됩니다.  
    ![Bind VRPN Keyboard](input-bind-keyboard.png "Bind VRPN Keyboard")
3.  입력 이벤트가 발생했는지 감지하려면, VRPN 버튼 채널을 바인딩한 입력 이벤트를 사용하세요.  
    예를 들어, 이 경우 **Event > Gamepad Events > Gamepad Left Trigger** 노드를 사용합니다.

### 디바이스 입력 쿼리

입력 이벤트 바인딩에 의존하는 대신 VRPN 디바이스를 직접 쿼리하여 현재 상태를 확인할 수 있습니다.

*   C++ 에서 `IDisplayClusterInputManager` 클래스를 사용합니다.
*   블루프린트에서, nDisplay API 의 **DisplayCluster > Input** 아래 함수를 사용합니다. 그 노드의 **Device Id** 및 **Device Channel** 에 제공한 입력 값이 nDisplay 구성 파일의 **input** 섹션에 설정한 디바이스 값에 일치하는지 확인해야 합니다.  
    예:
    [REGION:lightbox]
    [![](query-input-devices.png "query-input-devices.png")](query-input-devices.png)  
    *클릭하면 이미지 원본을 확인합니다.*
    [/REGION]
    

#### 키보드 버튼 및 디바이스 채널

VRPN 키보드 입력은 기본적으로 특수한 유형의 버튼 디바이스입니다. 지정한 키보드 버튼이 눌렸는지 알아야 하면, **Was VRPN Button Pressed** 함수를 사용하세요.

![Detecting whether a VRPN button was pressed](vrpn_keyboard_button_pressed.png "Detecting whether a VRPN button was pressed")

이 기능을 사용하려면 VRPN 이 할당한 숫자 ID 로의 **Device Channel** 입력을 테스트하려는 버튼으로 설정해야 합니다.

키보드에서 테스트하려는 버튼에 해당하는 **Device Channel** 숫자 ID 를 알아내려면, VRPN 배포에 제공된 `vrpn_print_devices.exe` 애플리케이션을 실행하면 됩니다. 이 툴이 실행되는 동안, 누른 키보드 버튼의 숫자 ID 를 콘솔에 출력합니다.

예를 들어, 스페이스 바는 57 번 키입니다.

![Find the numeric ID of a keyboard button](vrpn_keyboard_console.png "Find the numeric ID of a keyboard button")

## 클러스터 이벤트 사용

클러스터 이벤트는 nDisplay 클러스터의 모든 노드가 이벤트에 동시 반응하도록 만들 수 있습니다.

1.  클러스터 이벤트는 클러스터의 노드에서 아니면 외부 애플리케이션에서 마스터 노드로 전송하여 생성할 수 있습니다. [블루프린트에서 클러스터 이벤트 방출](#블루프린트에서클러스터이벤트방출) 또는 [외부 애플리케이션에서 클러스터 이벤트 방출](#외부애플리케이션에서클러스터이벤트방출) 부분을 확인하세요.  
    nDisplay 클러스터를 가동하여 실행중인 경우, **nDisplay Launcher** 애플리케이션을 사용해도 클러스터 노드가 반응할 새로운 클러스터 이벤트를 전송할 수 있습니다. [nDisplay Launcher에서 클러스터 이벤트 방출](#nDisplayLauncher에서클러스터이벤트방출) 부분을 참고하세요.  
    
2.  클러스터의 마스터 노드가 클러스터 이벤트를 받으면, 클러스터의 각 노드에 전파하여 똑같은 프레임에 각 노드에 이벤트가 발생하도록 합니다.
3.  언리얼 엔진 애플리케이션의 블루프린트 또는 C++ 로직에서 리스너를 셋업하여 이러한 클러스터 이벤트를 감지하고 프로젝트에 필요한 게임플레이 로직에 응답할 수 있습니다. [블루프린트에서 클러스터 이벤트에 응답](#블루프린트에서클러스터이벤트에응답) 부분을 참고하세요.

### 클러스터 이벤트 구조체

각 nDisplay 클러스터 이벤트에는 여러가지 프로퍼티가 포함됩니다.

| 세팅 | 유형 |
| --- | --- |
| **Name** | string |
| **Type** | string |
| **Category** | string |
| **Parameters** | 키-값 짝에 대한 옵션 매핑으로, 키와 값 둘 다 string 입니다. |

프로젝트의 각 프로퍼티에서 보낼 데이터와 리스너가 데이터를 해석하는 방법을 결정하는 것은 사용자의 몫입니다.

블루프린트에서 클러스터 이벤트와 상호작용할 때, **Make DisplayClusterClusterEvent** 및 **Break DisplayClusterClusterEvent** 노드를 사용하여 클러스터 이벤트를 구성 및 분해할 수 있습니다. 예:  

![A Cluster Event in Blueprint](cluster-event-bp.png "A Cluster Event in Blueprint")

C++ 에서, 또는 자신의 애플리케이션에서 클러스터 이벤트를 방출할 때, JSON 을 사용하여 같은 구조체를 표현하면 됩니다. 예를 들어, 위 클러스터 이벤트에 해당하는 JSON 은 다음과 같습니다.

    {"Name":"activate","Type":"command","Category":"particles","Parameters":{"rate":"200","speed":"3"}}

### 블루프린트에서 클러스터 이벤트 방출

프로젝트의 블루프린트 클래스에서 클러스터 이벤트를 방출하려면:

1.  **DisplayCluster Module API** 를 가져와서 ([블루프린트 API](#블루프린트api) 참고) **Cluster >** **Emits cluster event** 함수를 호출합니다. 이 노드는 클러스터 이벤트를 마스터 노드로 보내고, 다시 클러스터의 모든 노드로 전파합니다.  
    ![Emits cluster event](clusterevent-emit-bp-emitnode.png "Emits cluster event")
2.  기본적으로 게임 플레이 로직에서 블루프린트 노드를 평가하는 언리얼 엔진 애플리케이션의 모든 인스턴스가 이 클러스터 이벤트를 발동합니다. 이 블루프린트 그래프가 클러스터의 여러 노드에서 평가되면 이벤트의 여러 사본이 발생할 수 있습니다.  
    클러스터 이벤트의 여러 사본을 트리거하지 않으려면, **Emits cluster event** 노드에서 **Master Only** 부울 값을 설정하면 됩니다. 이 값이 **true** 설정되면, 마스터 노드만 이 Cluster Event 를 발동합니다. 다른 마스터 이외 클러스터 노드가 똑같은 블루프린트 그래프를 평가하는 경우, 그 노드는 이벤트를 방출하지 않습니다.  
    ![Master Only](clusterevent-emit-bp-masteronly.png "Master Only")
3.  **Emits cluster event** 노드의 **Event** 포트에서 왼쪽으로 드래그하고, **Make DisplayClusterClusterEvent** 를 선택합니다.  
    ![Make DisplayClusterClusterEvent](clusterevent-emit-bp-makeevent.png "Make DisplayClusterClusterEvent")
4.  **Make DisplayClusterClusterEvent** 노드의 세팅을 사용해서 Cluster Event 의 **Name**, **Type**, **Category** 값을 설정합니다. 클러스터 이벤트와 함께 임의의 키-값 데이터를 전달해야 하는 경우, 그 키-값 맵을   **Parameters** 입력에 전달해도 됩니다.  
    ![Creating and emitting a Cluster Event](clusterevent-emit-bp-graph.png "Creating and emitting a Cluster Event")
5.  블루프린트를 **컴파일**, **저장** 합니다.

다음 번 프로젝트를 다시 패키지하고 nDisplay 클러스터를 실행할 때, 이 블루프린트 코드가 셋업한 클러스터 이벤트를 발동합니다. 블루프린트 코드 다른 데서 이 이벤트에 응답하도록 하려면, [블루프린트에서 클러스터 이벤트에 응답](#블루프린트에서클러스터이벤트에응답) 부분을 참고하세요.

### 외부 애플리케이션에서 클러스터 이벤트 방출

nDisplay 클러스터를 시작하면, 마스터 노드가 특정 로컬 포트에서 들어오는 클러스터 이벤트 수신을 시작합니다. 네트워크의 다른 컴퓨터에서 실행중인 다른 애플리케이션에서 nDisplay 시스템에 새로운 클러스터를 방출하려면, 그 포트에 접속해서 메시지를 전송하면 됩니다.  

방출하려는 각 클러스터 노드에 대해, 다음과 같은 규칙을 따라야 합니다.

*   처음 두 바이트는 나머지 메시지의 전체 길이여야 합니다.
*   메시지 나머지는 클러스터 이벤트의 내용이어야 하며, JSON 오브젝트로 표현합니다.

예를 들어, 이름이 "quit" 이고 유형이 "command" 인 커스텀 이벤트를 방출하는 방법은 다음과 같습니다.

1.  클러스터 노드에 대한 값이 들어있는 JSON 스트링을 구성합니다. 이 경우:
    
        {"Name":"quit","Type":"command","Category":"","Parameters":{}}
    
    [REGION:tip]
    **Name**, **Type**, **Category** 필드는 필수이지만, Parameters 필드는 생략할 수 있습니다.
    [/REGION]
    
2.  JSON 스트링 길이를 가져와서 (이 경우 62자) 그 길이를 nDisplay 마스터 노드로 전송합니다.
3.  JSON 스트링 자체를 nDisplay 마스터 노드로 전송합니다.

마스터 노드가 메시지를 수신하여 처리할 수 있는 경우, 같은 규칙에 따라 애플리케이션에 응답을 다시 전송합니다.

*   처음 두 바이트는 나머지 응답 메시지의 바이트 길이입니다.
*   나머지 메시지는 JSON 오브젝트로 보통 `Error` 필드가 하나 들어있습니다. 이 필드 값은 메시지 처리가 잘 되었는지 나타내는 오류 코드입니다.
    
    | 코드 | 의미 |
    | --- | --- |
    | 0 | 오류가 발생하지 않았습니다. 메시지 처리에 성공했습니다. |
    | 2 | 전송한 클러스터 이벤트에 필수 필드 하나 이상이 누락되었습니다. 값이 비어 있더라도 **Name**, **Category**, **Type** 필드가 있는지 확인하세요. |
    | 255 | 인식할 수 없는 오류가 발생했습니다. |  

[REGION:tip]
기본적으로 마스터 노드는 14003 번 포트에 클러스터 이벤트를 수신 대기합니다. 이 기본값은 nDisplay 구성 파일에서 변경할 수 있습니다. [통신 포트 변경](#통신포트변경) 부분을 참고하세요.
[/REGION]

프로젝트의 블루프린트 코드에서 이 클러스터 이벤트에 응답하려면, [블루프린트에서 클러스터 이벤트에 응답](#블루프린트에서클러스터이벤트에응답) 부분을 참고하세요.

### nDisplay Launcher 에서 클러스터 이벤트 방출

nDisplay 클러스터 실행 도중, **nDisplayLauncher** 애플리케이션을 사용하여 언제든 마스터 노드에 클러스터 이벤트를 전송할 수 있습니다.  

1.  평소처럼 nDisplay 클러스터를 시작합니다.
2.  **Cluster events** (클러스터 이벤트) 탭으로 전환합니다. 이 탭에서 클러스터 이벤트를 셋업하고 필요할 때 클러스터로 보냅니다.
3.  **New** (신규) 버튼을 클릭하여 이 탭의 목록에 새 클러스터 이벤트를 추가합니다.  
    ![Cluster events tab](clusterevent-emit-launcher.png "Cluster events tab")
4.  **Cluster event editor** (클러스터 이벤트 에디터) 창에서 클러스터 이벤트에 대한 **Name**, **Type**, **Category** 값을 셋업합니다.  
    ![Settings in the Cluster event editor](clusterevent-emit-launcher-settings.png "Settings in the Cluster event editor")
5.  클러스터 이벤트의 목록 또는 파라미터에 키-값 짝을 추가할 수도 있습니다. **Argument** 필드에 키를, **Value** 필드에 값을 설정하고 **+** 버튼을 클릭합니다.  
    ![Parameters in the Cluster event editor](clusterevent-emit-launcher-params.png "Parameters in the Cluster event editor")
    [REGION:tip]
    파라미터를 생성한 뒤 수정하려면, 오른쪽 목록에서 선택하고 **-** 를 클릭하여 지웁니다. 그런 다음 새 파라미터를 다시 만들어 설정합니다.
    [/REGION]
    
6.  **Apply** (적용)을 클릭하여 새 클러트러 이벤트를 저장합니다.
7.  **클러스터 이벤트** 탭으로 돌아와, 목록의 클러스터 이벤트를 선택하고 **Send** (전송)을 클릭합니다.  
    ![Send the Cluster Event](clusterevent-emit-launcher-send.png "Send the Cluster Event")
    [REGION:tip]
    **Modify** (수정)을 클릭해서 선택한 클러스터 이벤트를 다시 열고 값을 편집할 수 있습니다.
    [/REGION]
    
8.  마스터 노드의 응답을 보려면 nDisplayLauncher 하단 로그 출력 패널을 확인하세요.  
    ![](clusterevent-emit-launcher-response.png "clusterevent-emit-launcher-response.png")

프로젝트의 블루프린트 코드에서 이 클러스터 이벤트에 응답하려면, [블루프린트에서 클러스터 이벤트에 응답](#블루프린트에서클러스터이벤트에응답) 부분을 참고하세요.  

### 블루프린트에서 클러스터 이벤트에 응답

위에서 설명한 방법 중 하나를 설정하여 클러스터 이벤트를 nDisplay 네트워크에 전송하면 블루프린트 (또는 C ++) 게임 플레이 로직을 만들어 해당 클러스터 이벤트를 감지하고 어떤 방식으로든 응답할 수 있습니다. 그 방법은 **DisplayClusterClusterEventListener** 인터페이스 구현 클래스인 리스너를 만들고 등록해야합니다. 리스너를 등록하려면 **Add Cluster Event Listener** 함수를 nDisplay API에서 호출한 다음 **Event on Cluster Event** 노드를 사용하면 클러스터 이벤트를 감지하고 응답할 수 있습니다.

예를 들어, 새로운 블루프린트 클래스를 생성하여 리스너로 등록하는 방법은 다음과 같습니다.

1.  **콘텐츠 브라우저** 에서 우클릭하고 **기본 애셋 생성 > 블루프린트 클래스** 를 선택합니다.  
    ![Create Blueprint Class](clusterevent-respond-newclass.png "Create Blueprint Class")

2.  부모 클래스로 **Actor** 를 선택합니다.  
    ![Actor](clusterevent-respond-parentactor.png "Actor")

3.  **콘텐츠 브라우저** 에 새 리스너 클래스의 이름을 입력합니다.  
    ![Rename the class](clusterevent-respond-rename.png "Rename the class")

4.  클래스를 끌어 레벨 뷰보트에 놓습니다.  
    ![Drag and drop the Blueprint into the Level](clusterevent-respond-spawn.png "Drag and drop the Blueprint into the Level")

5.  새 블루프린트 클래스를 더블클릭하여 편집합니다.
6.  툴바에서 **클래스 세팅** 을 클릭합니다.  
    ![Class Settings](clusterevent-respond-settings.png "Class Settings")

7.  **디테일** 패널에서 **Interfaces > Implemented Interfaces** 세팅을 찾아 **Add** (추가)를 클릭합니다.  
    ![Add interface](clusterevent-respond-addinterface.png "Add interface")

8.  목록에서 **DisplayClusterClusterEventListener** 인터페이스를 찾아 선택합니다.  
    ![DisplayClusterClusterEventListener](clusterevent-respond-clusterinterface.png "DisplayClusterClusterEventListener")
9.  툴바의 **컴파일** 버튼을 클릭하여 클래스를 컴파일합니다.

10.  **컨스트럭션 스크립트** 탭에서 그래프를 다음과 같이 만들어 리스너를 등록합니다.
    [REGION:lightbox]
    [![Construction Script](clusterevent-respond-construction.png "Construction Script")](clusterevent-respond-construction.png)  
	*클릭하면 이미지 원본을 확인합니다.*
    [/REGION]
    셋업 방법은 다음과 같습니다.  
    1.  **컨스트럭션 스크립트** 노드의 출력을 오른쪽으로 드래그하여 **N Display > Get DisplayCluster Module API** 를 선택합니다.
    2.  그 노드의 **Out API** 포트를 오른쪽으로 드래그하고 **Display Cluster > Cluster > Add cluster event listener** 를 선택합니다.
    3.  마지막으로 **Add cluster event listener** 노드의 **Listener** 포트를 왼쪽으로 드래그하고, **Variables > Get a reference to self** 를 선택합니다.

11.  이벤트 그래프 탭으로 전환하고, **Add Event > N Display > Event On Cluster Event** 노드를 추가합니다. nDisplay 클러스터에서 클러스터 이벤트가 발생할 때마다, 이 이벤트가 트리거됩니다.  
    이 이벤트에 할당된 세팅 및 파라미터를 읽고, 이를 사용하여 블루프린트에서 취해야 할 조치를 결정할 수 있습니다. 그 방법은 **On Cluster Event** 노드의 **Event** 포드를 오른쪽으로 드래그하고 **Break DisplayClusterClusterEvent** 를 선택합니다.  
    예를 들어, 이 그래프는 단순히 각 클러스터 이벤트의 Name 값을 화면에 인쇄합니다.
    [REGION:lightbox]
    [![Respond to the Cluster Event](clusterevent-respond-event.png "Respond to the Cluster Event")](clusterevent-respond-event.png)  
    *클릭하면 이미지 원본을 확인합니다.*
    [/REGION]
    
12.  블루프린트 클래스를 **컴파일**, **저장** 합니다.

다음 번 클러스터에서 클러스터 이벤트가 방출될 때, 그 클러스터 이벤트의 이름이 화면에 인쇄됩니다.

## 통신 포트 변경

nDisplay 시스템은 호스트 사이 통신에 세 개의 TCP/IP 포트(14000, 14001, 14002)를 사용합니다. 모든 컴퓨터에 위 포트를 열어 놓아야 합니다.

포트 번호를 직접 변경할 수 있는 곳은 다음과 같습니다.

*   **런타임 동기화 포트** - 마스터 노드는 두 포트를 사용하여 클러스터의 다른 노드와 데이터를 동기화합니다. 이 두 개의 포트를 설정하려면, 구성 파일에서 마스터 노드를 정의하는 **cluster_node** 줄에 **port_cs** 및 **port_ss** 구성 파라미터를 포함시킵니다. 예:
    
        [cluster_node] id=node_front addr=192.168.0.1 screen=screen_front viewport=vp_front port_cs=42001 port_ss=42002 master=true
    
*   **클러스터 이벤트 포트** - 마스터 노드는 항상 같은 포트를 사용하여 접속된 클라이언트와 클러스터 이벤트를 교환합니다. 여기에는 nDisplay 클러스터의 다른 노드도, 클러스터 이벤트를 주고 받기 위해 만든 외부 애플리케이션도 포함됩니다. 이 포트를 설정하려면, 구성 파일에 **port_ce** 구성 파라미터를 포함시켜 cluster_node 줄에 마스터 노드를 정의합니다. 예:
    
        [cluster_node] id=node_front addr=192.168.0.1 screen=screen_front viewport=vp_front port_ce=42003 master=true
    
*   **nDisplay Launcher 및 nDisplay 리스너 포트** - nDisplay Launcher 및 nDisplay Listener 둘 다 같은 통신 포트를 사용하도록 구성해야 합니다. 이 애플리케이션을 실행할 때 명령줄에 지정할 수 있습니다.  
    nDisplay Launcher를 실행할 때, `listener_port` 인수를 사용합니다. 예:
    
        nDisplayLauncher.exe listener_port=15003
    
    추가로, 각 호스트에서 nDisplayListener 애플리케이션에 `port` 인수를 붙여 직접 실행해야 합니다. 예:
    
        nDisplayListener.exe port=15003
    

## 기존 프로젝트에 nDisplay 추가

기존 프로젝트가 nDisplay 를 사용하도록 셋업하는 방법은 다음과 같습니다.

1.  nDisplay 플러그인을 활성화합니다.  
    언리얼 에디터에서 **편집 > 플러그인** 메뉴를 선택합니다. nDisplay 를 검색하고 **Enabled** (활성화) 박스를 체크합니다.  
	[REGION:lightbox]
	[![Enable the nDisplay Plugin](ndisplay-enable-plugin.png "Enable the nDisplay Plugin")](ndisplay-enable-plugin.png)  
    *클릭하면 이미지 원본을 확인합니다.*
	[/REGION]

2.  프로젝트에 nDisplay 를 활성화합니다.  
    메인 메뉴의 **편집 > 프로젝트 세팅** 을 선택하고 **플러그인 > nDisplay** 섹션을 찾습니다. **Enabled** (활성화) 박스를 체크합니다.  
	[REGION:lightbox]
	[![nDisplay Project Settings](ndisplay-project-settings.png "nDisplay Project Settings")](ndisplay-project-settings.png)  
    *클릭하면 이미지 원본을 확인합니다.*
	[/REGION]

3.  아직 **프로젝트 세팅** 창에서 **프로젝트 > Description** (설명) 섹션의 **Settings > Use Borderless Window** (세팅 > 테두리 없는 창 사용) 박스를 체크합니다.  
	[REGION:lightbox]
	[![Use Borderless Window](ndisplay-project-settings-borderless.png "Use Borderless Window")](ndisplay-project-settings-borderless.png)  
    *클릭하면 이미지 원본을 확인합니다.*
	[/REGION]

4.  언리얼 에디터를 재시작하고, 프로젝트를 다시 연 뒤, 프로젝트의 기본 레벨을 엽니다.

5.  **월드 세팅** 패널에서 **Game Mode > GameMode Override** (게임 모드 > 게임 모드 오버라이드) 세팅을 **DisplayClusterGameModeDefault** 으로 설정합니다.  
	[REGION:lightbox]
	[![nDisplay World Settings](ndisplay-world-settings.png "nDisplay World Settings")](ndisplay-world-settings.png)  
    *클릭하면 이미지 원본을 확인합니다.*
	[/REGION]  
    
6.  레벨에 **DisplayClusterSettings** 액터를 새로 추가합니다.  
    **모드** 패널의 **모든 클래스** 목록에서 이 액터를 찾을 수 있습니다.

7.  위 [시작하기](#시작하기) 섹션 아래 나머지 셋업 안내를 따릅니다.

## nDisplay Launcher UI 레퍼런스

여기서는 nDisplay Launcher의 유저 인터페이스에서 사용할 수 있는 세팅과 옵션을 전부 설명합니다.

### 런처 탭

[REGION:lightbox]
[![Launcher tab](launcher-tab.png "Launcher tab")](launcher-tab.png)  
*클릭하면 이미지 원본을 확인합니다.*
[/REGION]

| 컨트롤 | 설명 |
| --- | --- |
| **Render API** | 다음 번 **실행** 을 클릭했을 때 사용할 렌더링 API 를 지정합니다. |
| **Render mode** | [INCLUDE:#excerpt_25] |
| **Use All Available Cores** | [INCLUDE:#excerpt_26] |
| **No Texture Streaming** | [INCLUDE:#excerpt_27] |
| **Custom command line arguments** | 여기 입력한 인수는 nDisplay Launcher가 각 언리얼 인스턴스 실행에 사용하는 명령줄에 추가 전달합니다. 자세한 내용은 [](Programming/Basics/CommandLineArguments) 문서를 참고하세요. |
| **Custom ExecCmds** | **nDisplay Launcher** 가 언리얼 엔진에 시작할 때 실행할 콘솔 명령을 전달하려면, 여기 입력합니다. The nDisplay Launcher 는 `-ExecCmds` 명령줄 파라미터를 사용해서 언리얼 엔진 애플리케이션의 각 인스턴스에 이 명령을 전달합니다. |
| **Applications** | nDisplay Launcher로 실행할 수 있는 모든 언리얼 애플리케이션 패키지를 나열합니다. 패널 아래 **Add** (추가) 및 **Delete** (삭제) 버튼으로 목록을 편집합니다. 자세한 내용은 패키지 및 디플로이 부분을 참고하세요. |
| **Config Files** | nDisplay Launcher용으로 셋업한 모든 구성 파일을 나열합니다. 드롭다운 오른쪽의 **Add** 및 **Delete** 버튼으로 목록을 편집하세요. 자세한 내용은 패키지 및 디플로이 부분을 참고하세요. |
| **Run** | **Config Files** 목록에 선택한 파일에 구성된 모든 클러스터 노드에 접속을 시도하고, **nDisplay Listener** 애플리케이션에 **Applications** 목록에 선택된 언리얼 엔진 애플리케이션 패키지를 실행하도록 합니다.  |
| **Kill** | **Config Files** 목록에 선택한 파일에 구성된 모든 클러스터 노드에 접속을 시도하고, **nDisplay Listener** 애플리케이션에 **Applications** 목록에 선택된 언리얼 엔진 애플리케이션 패키지를 종료하도록 합니다. |

[COMMENT:none]
[EXCERPT:excerpt_27]
각 언리얼 인스턴스의 텍스처 스트리밍을 비활성화합니다. 최고 퀄리티 텍스처는 항상 로드합니다.  
이 옵션을 선택하면, nDisplay Launcher는 각 인스턴스 실행에 사용하는 명령줄에 NOTEXTURESTREAMING 옵션을 추가합니다.  
[/EXCERPT:excerpt_27]
[/COMMENT]

[COMMENT:none]
[EXCERPT:excerpt_26]
각 언리얼 엔진 인스턴스가 호스트에서 가능한 모든 프로세서를 강제 사용하도록 합니다.  
이 옵션을 선택하면, nDisplay Launcher는 각 인스턴스 실행에 사용하는 명령줄에 USEALLAVAILABLECORES 옵션을 추가합니다.
[/EXCERPT:excerpt_26]
[/COMMENT]

[COMMENT:none]
[EXCERPT:excerpt_25]
nDisplay 가 모든 클러스터 노드에서 생성하는 출력 유형을 지정합니다.   

*   **Mono** 모노 - 카메라 시점에서 본 씬에 대한 단일 모노스코픽 렌더링입니다.
*  **Frame sequential** 프레임 순차 - 액티브 쿼드 버퍼 스테레오입니다.
*   **Side-by-side** 나란히 - 패시브 수평 정렬 스테레오입니다.
*   **Top-bottom** 위아래 - 패시브 수직 정렬 스테레오입니다.

모노는 별도의 하드웨어 기능이 필요하지 않지만 프레임 순차는 필요합니다. 디스플레이 디바이스, GPU, 드라이버 세팅이 선택한 렌더 모드에 호환되는지 확인하세요.
[/EXCERPT:excerpt_25]
[/COMMENT]

### 클러스터 이벤트 탭

**Cluster events** (클러스터 이벤트) 탭에서 새 클러스터 이벤트를 만들어 nDisplay 클러스터로 전송할 수 있습니다. [nDisplay Launcher 에서 클러스터 이벤트 방출](#ndisplaylauncher에서클러스터이벤트방출) 부분도 참고하세요.

[REGION:lightbox]
[![Cluster events tab](clusterevents-tab.png "Cluster events tab")](clusterevents-tab.png)  
*클릭하면 이미지 원본을 확인합니다.*
[/REGION]

| 컨트롤 | 설명 |
| --- | --- |
| **New** | [INCLUDE:#excerpt_33] |
| **Modify** | 리스트 뷰에 선택된 클러스터 이벤트가 있으면, **Modify** 를 클릭해서 그 클러스터 이벤트를 **클러스터 이벤트 에디터** 에서 열어 값을 편집할 수 있습니다. |
| **Delete** | 리스트 뷰에 선택된 클러스터 이벤트가 있으면, **Delete** 를 클릭해서 그 클러스터 이벤트를 목록에서 제거할 수 있습니다. |
| **Send** | 리스트 뷰에 선택된 클러스터 이벤트가 있고, 현재 nDisplay 클러스터가 실행중이라면, **Send** 를 클릭해서 선택된 클러스터 노드를 nDisplay 클러스터에 방출할 수 있습니다. 출력 로그 패널에서 마스터 노드의 응답을 확인할 수 있습니다. |

[COMMENT:none]
[EXCERPT:excerpt_33]
클릭하면 **클러스터 이벤트 에디터** 에서 새 클러스터 이벤트를 만들어 리스트 뷰에 추가합니다.  
![Cluster event editor](cluster-event-editor.png "Cluster event editor")  
[nDisplay Launcher에서 클러스터 이벤트 방출](#nDisplayLauncher에서클러스터이벤트방출) 부분을 참고하세요.
[/EXCERPT:excerpt_33]
[/COMMENT]

### 로그 탭

기본적으로, nDisplay 는 다양한 소스의 로그 메시지를 애플리케이션 패키지 옆 **Saved/Logs** 폴더에 저장합니다. **Logs** 탭에서 각기 다른 소스에 대한 nDisplay 의 정보 로그 레벨을 구성할 수 있습니다.

[REGION:lightbox]
[![Logs tab](logs-tab.png "Logs tab")](logs-tab.png)  
*클릭하면 이미지 원본을 확인합니다.*
[/REGION]

| 컨트롤 | 설명 |
| --- | --- |
| **Use custom log settings** | 체크하면, nDisplay 는 왼쪽에 나열된 각기 다른 소스에 대해 이 페이지에서 설정한 로그 레벨을 사용합니다. |
| **For each** | 여기 있는 버튼을 클릭하면 왼쪽에 있는 모든 소스에 대해 선택한 심각도 이상의 메시지를 기록합니다. |

### 로그 출력 패널

로그 출력 패널에는 **nDisplay Launcher** 에서 수행하는 모든 명령의 결과가 나열됩니다.

[REGION:lightbox]
[![The log output panel](log-output.png "The log output panel")](log-output.png)  
*클릭하면 이미지 원본을 확인합니다.*
[/REGION]

| 컨트롤 | 설명 |
| --- | --- |
| **Copy** | 복사 - 왼쪽 로그 창에 나열된 모든 메시지를 클립 보드로 복사합니다. |
| **Clean** | 지우기 - 왼쪽 로그 창의 모든 메시지를 지웁니다. |

