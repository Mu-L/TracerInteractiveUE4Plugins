INTSourceChangelist:4476116
Availability: Public
Crumbs: 
Title: 데이터스미스 임포트 프로세스에 대하여
Description: 데이터스미스로 언리얼 엔진에 씬을 임포트하는 방식의 구체적인 이슈 관련 자세한 내용, 그렇게 임포트한 애셋을 언리얼에서 작업하는 방법을 다룹니다.
Type: 
Version: 4.20
Parent: Enterprise/Datasmith/Overview
Order: 2
Tags: Datasmith
Tags: Guides
Tags: importing
topic-image:datasmith-about-import-topic.png


여기서는 데이터스미스가 씬을 변환하는 도중 발생하는 이슈 관련 자세한 내용을 다룹니다. 그 이슈를 이해하면 데이터스미스가 생성한 결과를 이해하고 언리얼 에디터에서도 콘텐츠 작업을 쉽게 할 수 있습니다.

## 단위와 척도

언리얼 엔진에서 모든 거리 측정 단위는 항상 센티미터입니다. 하지만 다른 3D 디자인 앱은 대개 측정 단위를 선택할 수 있습니다. 소스 앱에서 다른 측정 단위를 사용하면, 데이터스미스가 씬의 스케일을 자동 처리하여 언리얼 엔진에서도 실제 크기와 똑같은 크기로 올바른 3D 위치에 나타나도록 합니다. 소스 앱에서 작업하는 방식은 아무것도 바꿀 필요 없습니다.  

예를 들어 소스 앱에서 인치를 측정 단위로 사용하는 경우 원래 씬에서 길이가 10 인치인 오브젝트는 언리얼 엔진에서 길이가 25.4 월드 유닛이 됩니다.

![](datasmith-units-1.png)

![](datasmith-units-2.png)

## 이름과 라벨

데이터스미스는 소스 앱의 지오메트리 관련 이름 정보를 감지한 뒤, 그 정보를 최대한 재사용하여 애셋과 액터를 만듭니다. 정확한 프로세스는 앱마다 파일 포맷마다 약간씩 다르고 언리얼 엔진에서의 결과도 소스 앱과 살짝 다를 수 있지만, 최종 목적은 콘텐츠를 임포트한 후에도 찾아 관리할 수 있도록 하는 것입니다.

스태틱 메시의 경우, 콘텐츠 브라우저의 애셋 이름과, 디스크의 애셋 파일명과, 레벨의 액터 이름이 다른 경우가 종종 있습니다.

*   **콘텐츠 브라우저 라벨** - 데이터스미스는 소스 파일에서 찾은 명명 규칙 정보가 있으면 그에 따라 콘텐츠 브라우저의 스태틱 메시 애셋 각각에 대한 라벨을 생성합니다.  
    지원하는 앱과 파일 포맷이 여럿이라 이름이 같은 오브젝트도 여럿 있을 수 있습니다. 씬에 그러한 상황이 발생하면, 콘텐츠 브라우저에 라벨이 같은 애셋이 다수 생길 수 있습니다.
*   **파일명** - 하지만 디스크의 각 애셋 이름은 고유해야 합니다. 그래서 데이터스미스는 소스 앱에서 추출한 고유 식별자로 각 애셋 파일 이름을 붙입니다.
*   **액터 이름** - 데이터스미스가 레벨에 액터를 배치할 때마다 소스 파일에 그에 해당하는 오브젝트가 있으면 똑같은 이름을 붙입니다.  
    고유한 이름을 찾을 수 없으면, 콘텐츠 브라우저에서 같은 라벨을 재사용하여 액터 이름을 붙입니다. 레벨에 그 이름의 액터가 이미 존재하면, 데이터스미스는 접미사 숫자를 증가시켜 고유한 액터 이름으로 만듭니다.

예를 들어 아래 이미지에서 소스 씬의 이름 그대로 언리얼로 가져온 것이 보이며, 다수의 오브젝트가 이름이 같으면 예외입니다.

[REGION:lightbox]
[![](datasmith-naming-before.png)](datasmith-naming-before.png)
[/REGION]

소스 파일의 계층구조

[REGION:lightbox]
[![](datasmith-naming-after.png)](datasmith-naming-after.png)
[/REGION]

언리얼의 계층구조

[REGION:note]
참고로 콘텐츠 브라우저의 스태틱 메시 애셋 *라벨* 과 데이터스미스가 디스크 상의 그 애셋에 대해 생성하는 파일 *이름* 은 차이가 있습니다. 대부분의 경우 에디터에서 작업할 때는 괜찮습니다. 하지만 블루프린트나 Python 을 사용해서 애셋 또는 데이터스미스 씬 작업을 할 때는, 그 차이를 알아야 할 수 있습니다.
[/REGION]

## 트라이앵글이 향하는 방향

런타임에 최상의 퍼포먼스를 얻기 위해 언리얼 엔진은 보이지 않을 것으로 예상되는 트라이앵글을 컬링하여 렌더링에 드는 GPU 사이클 소모를 방지합니다. 특히 엔진은 모든 오브젝트에 두께가 있다 가정합니다. 카메라를 보지 않는 트라이앵글은 그 오브젝트의 뒷면이라 가정하여 오브젝트 정면 뷰에서는 숨깁니다. 이를 *back-face culling* (뒷면 컬링)이라 하며, 3D 렌더링에 광범위하게 사용되는 최적화 기법입니다.

하지만 표면을 위와 같이 앞뒤 구분하지 않고 어느 쪽에서 보든 상관없이 렌더링하는 디자인 앱도 있습니다. 디자인 툴에서 작업할 때는, 어떤 표면이 보는 방향을 알지 못할 수 있습니다. 그러면 표면의 노멀(법선, 표면과 수직 방향)이 안쪽, 즉 표면을 보는 방향 반대쪽을 향할 수 있습니다. 또는 두께가 전혀 없는 평면형 단일 벽 지오메트리가 만들어질 수 있습니다.

그렇게 되면 언리얼 엔진에 씬을 임포트한 후 특정 각도에서 봤을 때 일부분이 보이지 않게 될 수 있습니다. 심지어 모델 그 부분이 임포트 안된 것으로 보일 수도 있습니다. 하지만 단지 표면 노멀이 씬 뷰에 사용하는 카메라 반대 방향을 향하기 때문일 수 있습니다. 그런 경우 모델을 회전해 보면 표면이 갑자기 나타납니다.

예를 들어 다음 씬( 왼쪽)에서 지오메트리를 제대로 임포트했음에도 천장과 파이프 끝이 누락된 것처럼 보입니다. 머티리얼의 Two Sided (양면) 옵션을 켜면 표면이 나타납니다 (자세한 내용은 아래 참고).

[OBJECT:ComparisonSlider]
[PARAM:before]
![단면](datasmith-two-sided-off.png) 
[/PARAM]
[PARAM:after]
![양면](datasmith-two-sided-on.png) 
[/PARAM]
[/OBJECT]

이러한 상황에 대한 가장 좋은 해법은 소스 앱에서 처리하는 것입니다.  

*   모든 방향에서 보이는 오브젝트는 전부 모델링할 때 두께를 주고, 노멀이 바깥쪽을 향하도록 합니다.
*   한쪽 방향에서만 보이는 것으로 알고 있는 오브젝트의 메시가 누락된 경우, 소스 앱에서 표면 노멀을 뒤집고(flip) 씬을 다시 임포트하여 고칩니다. 이렇게 하면 표면은 단면으로 유지하고 표면이 향하는 방향만 뒤집어 언리얼 엔진에서 의도한 방향에서 봤을 때 올바르게 보입니다.

하지만 소스 씬으로 돌아가지 않고 언리얼 에디터에서 문제를 고치기 위해 다음과 같은 옵션을 고려할 수도 있습니다.

*   스태틱 메시 에디터에서 트라이앵글 방향을 뒤집어 반대 방향을 보도록 하면 됩니다. [](Enterprise/Datasmith/HowTo/ModifyStaticMeshGeometry) 문서를 참고하세요.  
    하지만 그 트라이앵글이 반대쪽에서도 보인다면, 같은 문제가 여전히 남아있습니다. 즉 천장처럼 안에서만 보이는 것에는 좋은 해법이지만, 양쪽에서 보이는 내벽에는 좋지 않습니다.  
    유의할 점은 소스 씬에서 이 지오메트리 조각을 수정하고 데이터스미스 씬 애셋을 리임포트하면, 스태틱 메시 에디터에서 한 변경 작업은 잃게 됩니다. 즉 다른 이유로 돌아가서 지오메트리를 수정해야 한다면, SketchUp 에서 면의 방향도 동시에 수정해야 합니다.
*   머티리얼 에디터에서 머티리얼을 양면으로 만들면 됩니다. 그러면 그 표면은 어느 쪽에서 봐도 엔진이 렌더합니다. 얼핏 들었을 때 좋은 해법같지만, 스태틱 또는 스테이셔너리 라이팅에서 시각적인 부작용이 생기는 경향이 있습니다. 표면의 양쪽 면이 라이트맵 텍스처에 똑같은 공간을 사용하기 때문입니다.  
    머티리얼이 머티리얼 인스턴스인 경우, 머티리얼 에디터에서 디테일 패널의 **General > Material Property Overrides > Two Sided** 부분을 확인합니다.  
    ![Two Sided Material Property Override](material-instance-two-sided.png "Two Sided Material Property Override")  
    그 외의 경우, 머티리얼 에디터의 **디테일** 패널에서 **Material > Two Sided** 부분을 확인합니다.  
    ![Two Sided Material Property](material-details-two-sided.png "Two Sided Material Property")
*   표면 자체의 가시성 관련 문제가 아니라 빛이 오브젝트를 통과해 나오는 것만 문제인 경우, 즉 천장이 위쪽의 디렉셔널 라이트의 빛을 제대로 차단하지 못하는 경우, 스태틱 메시 액터가 양쪽면에서 그림자를 드리우도록 설정하면 됩니다.  
    **디테일** 패널에서 **Lighting > Shadow Two Sided** 세팅을 살펴보세요.  
    ![Shadow Two Sided](staticmeshactor-shadowtwosided.png "Shadow Two Sided")

## 라이트맵 UV

언리얼 엔진은 씬의 라이팅 방법을 여러가지 제공합니다. 런타임 퍼포먼스가 가장 뛰어나면서 보통 간접광이 퍼지는 모습을 가장 부드럽고 현실적으로 표현하는 방법은 *baked* (구운) 라이팅입니다. 이 방법에는 Lightmass (라이트매스)라는 툴을 사용하여 언리얼 에디터에서 라이팅을 빌드합니다. 씬의 스태틱 및 스테이셔너리 라이트에서 나온 빛이 각 오브젝트에 닿는 것을 계산하여 *lightmap* (라이트맵)이라는 특별한 종류의 텍스처에 저장합니다. 런타임에 각 오브젝트의 라이트맵 텍스처에 있는 그 라이팅 정보를 오브젝트의 표면에 적용합니다.

이 시스템이 작동하려면 스태틱 메시의 모든 버텍스를 그 라이트맵 텍스처의 2D 곤간 고유 좌표에 매핑해야 합니다. 이 매핑을 UV 세트 또는 UV 채널이라 합니다. 또한 이 2D 좌표 공간을 배치할 때 메시의 트라이앵글이 2D 텍스처 공간에 서로 겹치지 않도록 해야 합니다. 메시의 두 트라이앵글을 2D 텍스처 같은 공간에 매핑하면, 라이트매스는 그 두 트라이앵글 각각에 대한 빛과 그림자 고유 패턴을 저장할 수 없습니다. 그러면 런타임에 이상한 라이팅 부작용이 생깁니다.

모든 스태틱 메시가 스태틱 라이팅을 제대로 받을 수 있도록 준비하기 위해, 데이터스미스는 임포트하는 스태틱 메시마다 언리얼 에디터의 자동 UV 언래핑 시스템을 자동으로 호출합니다. 이 프로세스는 각 스태틱 메시에 두 개의 새로운 UV 세트를 추가합니다.

*   하나는 메시를 이루는 트라이앵글을 2D 공간에 평면에 단순히 펼쳐 표현하는 것입니다. 메시를 다수의 작은 "island" (아일랜드)로 나누며, 각 아일랜드는 메시 표면의 연결 섹션을 나타냅니다.
*   그런 다음 첫 라이트맵의 아일랜드를 재배치하고 크기를 조절해서 겹침이 없는 레이아웃으로 만들어 아일랜드 주변 낭비 공간을 최소화합니다. 그러면 레벨의 라이팅을 빌드할 때 오브젝트의 라이트맵에 사용되는 최종 레아이웃이 됩니다.

그런 다음 데이터스미스는 라이트맵 저장 및 적용을 위해 2차 생성 UV 를 사용하도록 스태틱 메시 애셋을 설정합니다.

[REGION:note]
3ds Max 를 사용하고 라이트맵에 사용하려는 UV 채널을 이미 설정해 둔 경우, [](Enterprise/Datasmith/SoftwareInteropGuides/3dsMax) 문서를 참고하세요.
[/REGION]

## 콜리전 및 피직스

기본적으로 데이터스미스는 생성할 스태틱 메시 애셋에 대해 피직스 설정을 하지 않습니다. 임포트 후 언리얼 에디터에서 스태틱 메시에 피직스 설정을 할 수 있는데, 자세한 내용은 [](Engine/Content/Types/StaticMeshes/HowTo/SettingCollision), [](Engine/Editor/ScriptingAndAutomation/HowTos/CreatingLODs) 문서를 참고하세요.

3ds Max 로 작업하는 경우 3ds Max 로 커스텀 지오메트리를 모델링하고 데이터스미스 임포터가 생성할 스태틱 메시 애셋에 그 지오메트리를 자동 할당하도록 할 수 있습니다. 자세한 내용은 [](Enterprise/Datasmith/SoftwareInteropGuides/3dsMax) 문서를 참고하세요.

## 머티리얼

[](Enterprise/Datasmith/Overview) 문서의 설명대로 데이터스미스 임포트 프로세스는 임포트한 씬에서 인식한 지오메트리 표면 프로퍼티의 여러 세트 각각을 표현하기 위해 언리얼 엔진 프로젝트에 머티리얼 애셋을 새로 만듭니다. 씬 변환의 목표는 표면 프로퍼티를 최상의 퀄리티로 넘기는 것이지만, 그래도 임포트 후 머티리얼 미세 조정은 해야 합니다.

*    일부 소스 머티리얼 중 데이터스미스가 이해하고 조정할 수 있는 그래프 기반, 특히 3ds Max 에서 온 머티리얼이면 언리얼 엔진으로 작업할 수 있습니다. 이 경우 데이터스미스가 생성하는 각 머티리얼 애셋은 소스 머티리얼의 이펙트를 언리얼의 물리 기반 렌더러에서 재현하도록 설계된 별도의 내부 셰이더 그래프를 만듭니다.  
    이 머티리얼 애셋 중 하나를 더블클릭하여 편집하면 셰이더 그래프에 바로 액세스할 수 있습니다.  
    ![데이터스미스가 변환한 머티리얼](datasmith-material-translated.png "Material translated by Datasmith")  
    이 방법이 좋은 이유는, 머티리얼이 텍스처와 세팅을 해석하는 방법을 완벽 제어하여 물리 기반 렌더러용 최종 표면 셰이딩 파라미터를 만들수 있기 때문입니다. 반면 시작이 더 복잡할 수 있으며, 무언가 변경하면 보통 셰이더를 다시 컴파일해야 합니다.  
    자세한 정보는 이 문서의 주제 관련해서 [](Engine/Rendering/Materials) 문서를, 참고로 [](Engine/Rendering/Materials/Editor) 문서를 확인하세요.
*   다른 경우 데이터스미스가 만드는 각 머티리얼은 데이터스미스 플러그인에 딸려온 기존 부모 머티리얼의 인스턴스입니다. 즉 이 머티리얼 중 하나를 편집할 때, 인스턴스드 머티리얼 각각에 노출되어 있는 미리 정의된 세팅 세트를 자유롭게 수정할 수 있습니다.  
    ![데이터스미스가 만든 머티리얼 인스턴스](datasmith-material-instance.png "Material Instance created by Datasmith")  
    하지만 머티리얼이 사용하는 그래프를 변경하여 그 프로퍼티 기반 표면 셰이딩을 결정할 수는 없습니다. 그러기 위해서는 데이터스미스에 내장된 부모 머티리얼을 파헤쳐야 합니다.  
    이러한 종류의 머티리얼 작업 관련 자세한 정보는 [](Engine/Rendering/Materials/MaterialInstances), [](Engine/Rendering/Materials/MaterialInstances/Editor) 문서를 참고하세요.  
    [REGION:note]
    콘텐츠 브라우저에서 위 부모 머티리얼을 확인하려면 **뷰 옵션** 메뉴의 **Show Plugin Content** (플러그인 콘텐츠 표시)를 체크해야 합니다. 이 부모 머티리얼의 그래프를 수정하려면 먼저 부모 머티러얼을 별도의 프로젝트 콘텐츠 폴더에 복제한 뒤, 그 복제본을 수정해야 합니다.
    [/REGION]

또다른 옵션으로, 데이터스미스가 만든 머티리얼 작업을 하는 대신, 항상 그 머티리얼을 다른 물리 기반 머티리얼로 완전 대체하는 것입니다. 언리얼 에디터에서, 아니면 타사 프로그램으로 직접 만든 머티리얼일 수 있습니다.

[REGION:tip]
언리얼 스튜디오에 가입하면 Allegorithmic 의 물리 기반 섭스턴스 머티리얼 100 종 라이브러리에 액세스할 수 있습니다. 시작은 [여기를(영문)](https://www.allegorithmic.com/substance-ue4) 참고하세요.
[/REGION]

### 데이터스미스 컬러 머티리얼

많은 CAD 앱은 지오메트리 셰이더에 단순한 표면 색을 사용합니다. 데이터스미스가 이런 표면을 언리얼로 가져올 때 보통 **Datasmith_Color** 머티리얼의 인스턴스로 가져옵니다.

![Datasmith_Color Material Instance](datasmith-color-material.png "Datasmith_Color Material Instance")

*   이 머티리얼의 색은 보통 미리 설정하여 소스 씬의 색과 똑같이 맞춥니다.  
    언리얼 엔진에서 이 머티리얼을 사용할 때, 색 값의 밝기에 특히 주의하세요. 디자인 툴에서는 가끔, 심지어 흰색 단색에도 매우 밝은 표면 색을 허용하는데, 현실에서 그런 경우는 별로 없습니다. 라이팅을 사실적으로 보이게 하려면 이 값을 크게 낮춰야 할 수도 있습니다.
*   데이터스미스는 보통 소스 머티리얼의 오파시티를 따릅니다. 소스 씬의 표면 색이 유리 패널과 같은 반투명(semi-transparent)으로 설정된 경우 데이터스미스는 오파시티를 Color 세팅의 **Alpha** 채널에 가져옵니다.  
    Alpha 채널을 사용하여 기존에 투명하지 않은 머티리얼이 언리얼 에디터에서 반투명이 되게 하려면, 머티리얼의 블렌딩 모드도 변경해야 할 것입니다. **General** (일반) 섹션에서 **Material Property Overrides** (머티리얼 프로퍼티 오버라이드) 그룹을 펼치고, **Blend Mode** (블렌드 모드) 옵션을 체크한 뒤 값을 **Translucent** (반투명)으로 설정합니다. 
*   Datasmith_Color 부모 머티리얼에서는 세 가지 다른 종류의 텍스처 맵을 사용할 수도 있습니다. 디퓨즈 맵으로 (Color 세팅을 무시하고) 표면의 바탕색을, 노멀 맵으로 미세한 표면 디테일을, 반투명(transparency) 맵으로 같은 표면의 다른 부분에 다른 오파시티 값을 갖도록 할 수 있습니다.  
    데이터스미스는 소스 앱에서 그런 텍스처 맵 유형을 익스포트할 수 있는 경우 이 텍스처 맵 세팅을 사용할 수 있습니다. 단조로운 색의 Datasmith_Color 인스턴스가 있고, 이런 텍스처 맵을 사용하여 표면의 사실감을 높이고 싶다면, 이 세팅을 활성화하고 텍스처 애셋을 할당하는 것이 좋습니다.  
    맵 세팅 중 하나를 활성화하면, Texture Parameter Values (텍스처 파라미터 값) 아래 새로운 세팅이 생겨 사용하고자 하는 텍스처를 설정할 수 있습니다.  
    ![텍스처 맵이 있는 Datasmith_Color 인스턴스](datasmith-color-map-active.png "Datasmith_Color Instance with a texture map")  
    하지만 처음부터 머티리얼을 직접 만드는 법을 배우는 편이 더 나을 수 있습니다. 그래야 Datasmith_Color 부모 머티리얼에 노출되지 않는 언리얼 엔진 렌더러의 다른 물리 기반 프로퍼티, 예를 들면 러프니스나 메탈릭 같은 것을 활용할 수 있습니다. [](Engine/Rendering/Materials/PhysicallyBased) 문서를 참고하세요.

## 레이어

소스 앱에서 콘텐츠를 체계적으로 분류하는 레이어 기능이나 비슷한 콘텐츠를 사용할 수 있는 경우, 데이터스미스는 언리얼 엔진에서 그 체계를 보존합니다. **레이어** 창에서 (**창 > 레이어**) 레이어를 표시하고 숨기거나, 레이어의 모든 오브젝트를 빠르게 찾아 선택할 수 있습니다.

![데이터스미스가 임포트한 레이어](datasmith_overview_layers.png "Layers imported by Datasmith")

하지만 언리얼 에디터는 *중첩* 레이어를 지원하지 않습니다. 소스 씬에서 중첩 레이어를 사용하는 경우, 데이터스미스는 자동으로 레이어의 계층구조를 단일 목록으로 평평하게 만듭니다.

언리얼 에디터에서 레이어 작업 방법 관련 자세한 정보는 [](Engine/UI/LevelEditor/Layers) 문서를 참고하세요.

## 메타데이터

일부 소스 파일 포맷의 경우 데이터스미스는 소스 앱에서 설정한 씬의 지오메트리 오브젝트 관련 메타데이터를 임포트합니다. 언리얼 에디터에서 블루프린트와 Python 스크립트를 사용하여 이 메타데이터에 액세스할 수 있습니다. 이 시스템 관련 자세한 내용은 [](Enterprise/Datasmith/Overview/UsingDatasmithMetadata) 문서를 참고하세요.