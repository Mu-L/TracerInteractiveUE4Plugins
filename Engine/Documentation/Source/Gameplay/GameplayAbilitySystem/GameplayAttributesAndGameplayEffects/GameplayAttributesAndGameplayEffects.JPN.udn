INTSourceChangelist:4376712
Availability: Public
Crumbs: 
Title: ゲームプレイ アトリビュートとゲームプレイ エフェクト
Description: ゲームプレイ アビリティ システム内のアトリビュートとエフェクトの概要
Type: 
Version: 4.20
Parent: Gameplay/GameplayAbilitySystem
Order: 1
Tags: Gameplay Ability System
Tags:Gameplay Attributes
Tags: Gameplay Effects


ゲームプレイ アビリティ システムとインタラクションするアクタは一般的に、システムがゲーム ロジックに影響したりゲーム内で起こっていることを記録するためにアクセスする、変更可能な数値プロパティを必要とします。これらのプロパティは **ゲームプレイアトリビュート** (または短縮して「アトリビュート」) と呼ばれるもので **ゲームプレイ エフェクト** により (一時的または恒久的に) 変更されます。

[REGION:note]
UE4 プロジェクトでのセットアップ方法については、Action RPG ドキュメントの[](Resources/SampleGames/ARPG/GameplayAbilitiesinActionRPG/AttributesandEffects)をご確認ください。
[/REGION]

## ゲームプレイ アトリビュート

**ゲームプレイ アトリビュート** には、体力、筋力、移動速度、魔法への耐性など単精度浮動小数点数値で記述可能なアクタの現在の状態の数値測定があります。アトリビュートはアトリビュートを持ちアトリビュートの変更を管理する **アトリビュートセット** 内の `FGameplayAttribute` 型の UProperties として宣言されます。

[REGION:note]
アトリビュートとアトリビュートセットはネイティブ コードで作成する必要があります。ブループリントで作成することはできません。
[/REGION]

### アトリビュートセットの作成

アトリビュートセットを作成するには `UAttributeSet` から継承して`UPROPERTY` にタグ付けしたゲームプレイ アトリビュート データのメンバーを追加します。たとえば、「health」アトリビュート のみを持つアトリビュートセットは以下のようになります。


	UCLASS()
	class USimpleAttributeSet :public UAttributeSet
	{
		GENERATED_BODY()
	public:
		/** デフォルト値をセットたとえば、Health に正の値をセットします*/
		USimpleAttributeSet();
		/**死ぬ前に耐えられるダメージの量を評価します*/
		UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Attributes")
		FGameplayAttributeData Health;
	};


*1 つのアトリビュートを持つ最小のアトリビュートセット*

アトリビュートセットを作成したらアビリティ システム コンポーネントとともに登録する必要があります。これを実行するにはアトリビュートセットをアビリティ システム コンポーネントが所有するアクタのサブオブジェクトとして追加するか、アビリティ システム コンポーネントの `GetOrCreateAttributeSubobject` 関数に渡します。

## ゲームプレイ エフェクト

ゲームプレイ エフェクトはゲームプレイ アビリティ システムがアトリビュートを変更する手段です。以下のようなものがあります。

* アトリビュートのベース値への直接変更。ダメージを受けたアクタから体力ポイントを奪うなど。
* 一時変更 (「バフ」または「デバフ」とよく呼ばれるもの)。数秒間動作スピードをブーストするなど。
* 時間経過とともに適用される持続的変更。数秒間 (または無期限で) 1 秒毎に再生されるマジック ポイントなど。

ゲームプレイ エフェクトは アビリティ システム コンポーネント とインタラクティブな (基本クラス `UGameplayEffect` の) データのみのブループリントとして実装され、適切であればアクティブな間アビリティ システム コンポーネントに保持されます。

### 主なプロパティ

ゲームプレイ アビリティ システムのほとんどの他のパーツとは異なり、ゲーム エフェクトはネイティブコードでもブループリントコードでも基本クラス `UGameplayEffect` を通常オーバーライドしません。そのかわり、ゲームプレイ エフェクトは完全に変数を経由して設定するように設計されています。以下に、調節可能なゲームプレイ エフェクトのいくつかの主要なプロパティを紹介します。

*   **Duration:** ゲームプレイ エフェクトは即時適用 (攻撃されたらすぐに体力が減るなど) または、限定された時間の適用 (数秒持続する動作スピードのブーストなど) または、無期限の適用 （マジック ポイントを時間経過とともに自動的に再生するキャラクターなど） が可能です。加えて、デュレーションが即時ではないエフェクトを様々なインターバルで適用することも可能です。デュレーションはエフェクトの動作の仕方をゲームプレイの観点から変更するのに役立つのみならず、反復するオーディオやビジュアルエフェクトのタイミングを設定するのにも役立ちます。
*   **Modifiers と Executions:** モディファイアはゲームプレイ エフェクトとアトリビュートがどのようにインタラクションするか決定します。これにはエフェクトを実行するゲームプレイ タグによる要求だけではなく、鎧のレートを 5 パーセント増加させるような、アトリビュート同士の数学的インタラクションも含まれます。ゲームプレイ エフェクトで、モディファイアのサポートを超えることをしたい場合は、エグゼキューションが役立ちます。エグゼキューションは `UGameplayEffectExecutionCalculation` を使用してゲームプレイ エフェクト実行時のカスタムの振舞いを定義します。とりわけモディファイアでは適切に処理されないような複雑な方程式を定義する際に有用です。
*   **Application Requirements:** アプリケーション リクワイアメントには、ゲームプレイ エフェクトを適用するために要求された (または禁止された) ゲームプレイ タグのセットと、ゲームプレイ エフェクトの確率での適用が含まれます。これらのリクワイアメントがゲームで必要とされていることを満たさなければ、`UGameplayEffectCustomApplicationRequirement` 基本クラスからデータ オブジェクトを派生させてネイティブ コードを書いて任意のアプリケーション ルールを定義してください。
*   **Granted Abilities:** ゲームプレイ エフェクトの適用時にゲームプレイ タグだけではなくアビリティを与えることができます。エグゼキューションと併用すれば、高度に特化したゲームプレイの組合わせに使用することができます。たとえば、オイルで濡れたアクタを意味するゲームプレイ タグまたはアトリビュートを持っている火系のゲームプレイ エフェクトを受けているアクタが10 秒間、近くのアクタに受動的ダメージを与え、パーティクルと動的ライトのビジュアル エフェクトを持った「 On Fire 」アビリティを作ることができます。
*   **Stacking:** 「スタッキング」は、バフやデバフ (この場合はゲームプレイ エフェクト) をすでに保持している対象に適用したり、新しいゲームプレイ エフェクトを元々のゲームプレイ エフェクト (オーバフローしてはじめて継続ダメージを与えるポイズンとなる上昇するポイズン メーターなど) ですでに完全に飽和している対象に適用するオーバフローと呼ばれる状況を処理するポリシーに関するものです。システムは、様々なスタッキングの振る舞いを処理します。たとえば、閾値を超えるまで増加させたり、新しいアプリケーションごとに最大値まで「スタック カウント」を維持したり、一定時間のエフェクトの時間をリセットしたり追加したり、あるいは単に個々の独立したタイマーを持つエフェクトの複数インスタンスを適用するといったようなことができます。
*   **Gameplay Cue Display: ** **ゲームプレイ キュー** はゲームプレイ アビリティ システムで制御可能なパーティクルやサウンドのような装飾的なエフェクトをネットワーク的に効率よくマネージする方法です。ゲームプレイ アトリビュートとゲームプレイ エフェクトはゲームプレイ キューのトリガーが可能でネイティブコードやブループリントコードでオーバライド可能な次の 4 関数を介して動作します。On Active 、 While Active 、 Removed 、および Executed (ゲームプレイ エフェクトのみで使用)。ゲームプレイ キューはすべて「 GameplayCue 」で始まるゲームプレイ タグに関連付けてください。例 「 GameplayCue.ElectricalSparks 」、「 GameplayCue.WaterSplash.Big 」
    [REGION:note]
    **Gameplay Cue Manager** がゲームプレイ キューを実行します。アクタは、`IGameplayCueInterface` を実装してゲームプレイ キューのタグにマッチする名前の関数があれば、ゲームプレイ キューに応答できます。スタンドアロンの **Gameplay Cue Notify** ブループリントもゲームプレイ キューに反応可能です。
    [/REGION]

## エフェクトとアトリビュートのインタラクションをプログラミングする

ゲームプレイ エフェクトがアトリビュートを変更するときに、アトリビュートセットがアトリビュートの応答や処理をオーバーライドする関数がいくつかあります。例として、サンプル `USimpleAttributeSet` の「health」アトリビュートは浮動小数点値を保持し、その値はゲームプレイ アビリティ システムがアクセスしたり変更可能ですが、この値がゼロになるだけでは実際には何も起こらず、ゼロ以下になるのを防ぐこともありません。「health」アトリビュートを期待通りに動作させるために、アトリビュートへの変更の試行を処理する仮想関数をいくつかオーバライドして、アトリビュート セット自体から介入することが可能です。アトリビュートセットは一般的に以下の関数をオーバライドします。

| 関数名 | 目的 |
| --- | --- |
| `PreAttributeChange / PreAttributeBaseChange` |これらの関数はアトリビュートを変更する直前に呼び出されます。「体力」は 0 と「 MaxHealth 」の間でなければならないというというようなアトリビュート値に関するルールを強制しつつ、アトリビュート変更についてのゲーム内の反応をトリガーしないことを目的とします。|
| `PreGameplayEffectExecute` |この関数はアトリビュート値を変更する直前に提案された変更を拒否したり変更することができます。|
| `PostGameplayEffectExecute`|アトリビュート値を変更した直後に、その変化に反応可能な関数です。アトリビュートの最終値をクランプしたり、新しい値に対するゲーム内の反応をトリガーするために使用されます。例えば「体力」アトリビュートがゼロになったら死ぬ、といった使用が可能です。|

