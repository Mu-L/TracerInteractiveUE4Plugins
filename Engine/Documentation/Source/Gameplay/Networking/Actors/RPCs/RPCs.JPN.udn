INTSourceChangelist:2916552
Availability:Public
Title:RPC について
Crumbs:Gameplay, Gameplay/Networking, Gameplay/Networking/Actors
Description:ネットワーク上で関数のレプリケーションを指定する
Related:Gameplay/Networking/Actors/OwningConnections
Related:Gameplay/Networking/Actors/Components

[TOC (start:2 end:3)]

**RPCs** (**Remote Procedure Calls**) は、ローカルで呼び出される関数ですが、別のマシンでリモートで実行されます (呼び出し側のマシンとは別)。 

RPC 関数は非常に便利で、クライアントまたはサーバーがネットワーク接続で互いにメッセージを送信できます。

こうした機能の主な用途は、実質上、一時的または表面的な変わりやすいゲームプレイ イベントを行うことです。こうしたものとしては、サウンド再生、パーティクルのスポーンや 
アクタの機能には必須ではない他の一時的なエフェクトがあります。以前は、こうしたタイプのイベントは、多くの場合、Actor のプロパティでレプリケートされていました。 

RPC を使用する場合は、ほとんどの RPC の実行先を定義することになる [オーナーシップの機能について](Gameplay/Networking/Actors/OwningConnections) を理解しておくことも重要です。

## RPC を使用する 
関数を RPC として宣言するには、単に `UFUNCTION` 宣言で `Server`、`Client`、または `NetMulticast` などのキーワードを追加します。 

例えば、サーバーで呼び出されるが、クライアントで実行される RPC として関数を宣言するには、以下のようにします。

	UFUNCTION( Client )
	void ClientRPCFunction();

例えば、クライアントで呼び出されるが、サーバーで実行される RPC として関数を宣言するには、上記と非常に類似していますが、以下のように `Server` のキーワードを使用します。

	UFUNCTION( Server )
	void ServerRPCFunction();

Multicast と呼ばれる RPC 関数型の特殊型がもうひとつあります。Multicast RPC はサーバーから呼び出されるように設計されていますが、サーバーおよび現在接続しているすべてのクライアントでも実行されます。 
Multicast 関数を宣言するには、以下のように `NetMulticast` キーワードを使用するだけです。

	UFUNCTION( NetMulticast )
	void MulticastRPCFunction();

Multicast RPC は、クライアントからも呼び出し可能ですが、この場合はローカルでのみ実行します。

## クイックヒント

関数の先頭に付いている `Client`、`Server`、`Multicast` に注目してください。これは、それぞれクライアント、サーバー、全クライアントで呼び出されるということを 
この関数を使用するプログラマに示すために内部で決めた合意規則です。

マルチプレイヤー セッション中に、どのマシンから関数が呼び出されるかが一見してわかるので非常に役立ちます。

## 必要条件および注意事項
RPC が完全に機能するには、以下の満たすべき要件があります。
1.	必ずアクタから呼び出されること。
1.	必ずアクタがレプリケートすること。
1.	クライアントで実行するために、RPC がサーバーから呼び出されると、実際にそのアクタを所有するクライアントだけが関数を実行します。
1.	サーバーで実行するために RPC がクライアントで呼び出されている場合、クライアントは、RPC が呼び出されているアクタを所有していなければなりません。
1.	Multicast RPC は以下のように例外です。
	* Multicast RPC がサーバーから呼び出されている場合、サーバーはそれらをローカルで実行するとともに、現在接続されている全クライアントで実行します。
	* Multicast RPC がクライアントから呼び出されている場合、それらはローカルでのみ実行し、サーバーでは実行しません。
	* 現時点では、マルチキャスト イベントに対して単純なスロットリング メカニズムがあります。すなわち、任意のアクタのネットワークで 2 回以上レプリケートしないというものです。長期的には、これを改善し、クロスチャンネル トラフィック管理とスロットリングのサポートを向上する予定です。

オーナーシップである呼び出し側アクタ (左の行) によって、RPC の所定のタイプが実行先を以下の表にまとめました。

### サーバーから RPC を呼び出す

| アクタの所有者			| Not replicated	| `NetMulticast`				| `Server`	| `Client`				|
| ---------------------		| --------------	| ---------					| ---------	| ---------------------	|
| **クライアント所有のアクタ**	| サーバー上で実行			| サーバーとすべてのクライアント上で実行	| サーバー上で実行	| アクタが所有するクライアント上で実行	|
| **サーバー所有のアクタ**	| サーバー上で実行			| サーバーとすべてのクライアント上で実行	| サーバー上で実行	| サーバー上で実行				|
| **所有されていないアクタ**			| サーバー上で実行			| サーバーとすべてのクライアント上で実行	| サーバー上で実行	| サーバー上で実行				|

### クライアントから RPC を呼び出す

| アクタの所有者						| Not replicated	| `NetMulticast`		| `Server`	| `Client`			|
| -------------------------------------	| --------------	| ---------			| ---------	| -----------------	|
| **呼び出し側クライアント所有のアクタ**	| 呼び出し側クライアント上で実行	| 呼び出し側クライアント上で実行	| サーバー上で実行	| 呼び出し側クライアント上で実行	|
| **別のクライアント所有のアクタ**	| 呼び出し側クライアント上で実行	| 呼び出し側クライアント上で実行	| ドロップ	| 呼び出し側クライアント上で実行	|
| **サーバー所有のアクタ**				| 呼び出し側クライアント上で実行	| 呼び出し側クライアント上で実行	| ドロップ	| 呼び出し側クライアント上で実行	|
| **所有されていないアクタ**						| 呼び出し側クライアント上で実行	| 呼び出し側クライアント上で実行	| ドロップ	| 呼び出し側クライアント上で実行	|


## 信頼性

デフォルトで RPC は不安定です。RPC 呼び出しがリモート マシンで確実に実行されるようにするために、`Reliable` キーワードを指定できます。

	UFUNCTION( Client, Reliable )
	void ClientRPCFunction();

## ブループリント

RPC とマーク付けされている関数もブループリントから呼び出されるとレプリケートします。この場合、C++ から呼び出されているかのように同じ規則に従います。今回は、 
ブループリントから関数に RPC として動的にマーク付けできません。

しかし、カスタム イベントはブループリント エディタ内からレプリケートとしてマーク付けされます。

この機能を使用するには、イベントグラフで新規カスタム イベントを作成します。カスタム イベントをクリックして、詳細ビューでレプリケーション設定を編集します。

![](RPC_BP.png)

## バリデーション

最近、バリデーション関数を RPC に付加する機能が追加されました。これは問題のあるデータや入力を検知するチェックポイントとしての役割を果たします。考え方としては、RPC のバリデーション関数が問題のあるパラメータを検知すると、 
システムに通知し、その RPC 呼び出しを開始したクライアント/サーバーの接続を解除します。

RPC のバリデーション関数を宣言するには、単に `UFUNCTION` 宣言文に `WithValidation` キーワードを追加します。

	UFUNCTION( Server, WithValidation )
	void SomeRPCFunction( int32 AddHealth );

次に以下のように実装関数の隣に、Validate 関数を入れます。

	bool SomeRPCFunction_Validate( int32 AddHealth )
	{
		if ( AddHealth > MAX_ADD_HEALTH )
		{
			return false;                       // This will disconnect the caller
		}
		return true;                              // This will allow the RPC to be called
	}

	void SomeRPCFunction_Implementation( int32 AddHealth )
	{
		Health += AddHealth;
	}

最近、UHT に変更が加えられ、 クライアント-> サーバー RPC が _Validate 関数を持つことを必要としています。これは、安全なサーバー RPC 関数を促すためであり、可能な限り簡単にコードを追加、チェックし、 
すべてのパラメータが既知の入力の制約に対して有効になるようにしました。
