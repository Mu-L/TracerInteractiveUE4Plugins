INTSourceChangelist:3108692
Availability:Public
Title: 액터 롤 및 리모트 롤
Crumbs:%ROOT%, Gameplay, Gameplay/Networking, Gameplay/Networking/Actors
Description:액터 오브젝트 리플리케이션의 여러가지 부분에 대한 것입니다.
Related: Gameplay/Networking/Actors
Related: Gameplay/Networking/Server
Version: 4.9

[TOC (start:2 end:3)]



리플리케이션 관련해서 액터에 중요한 프로퍼티가 두 가지 있습니다. `Role` (롤)과 `Remote Role` (리모트 롤)입니다.

두 가지 프로퍼티를 통해 알 수 있는 바는 다음과 같습니다:
* 액터에 대한 오소리티 소유자
* 액터의 리플리케이션 여부
* 리플리케이션 모드

알아내야할 가장 중요한 것 한 가지는, 특정 액터에 대한 오소리티를 누가 갖고 있느냐 입니다. 현재 실행중인 엔진 인스턴스가 오소리티를 갖고 있는지 알아내기 위해서는, Role 프로퍼티가 `ROLE_Authority` 인지 검사합니다. 그렇다면 현재 실행중인 엔진 인스턴스가 (리플리케이션 여부와 무관하게) 이 액터를 담당합니다.

Role 이 `ROLE_Authority` 이고, RemoteRole 은 `ROLE_SimulatedProxy` 또는 `ROLE_AutonomousProxy` (롤이 오소리티고, 리모트 롤은 시뮬레이션 또는 자율 프록시)인 경우, 이 엔진 인스턴스는 이 액터를 원격 접속으로 다시 리플리케이트하는 것을 담당합니다.

[REGION:note]
현재, 서버만 액터를 접속된 클라이언트로 리플리케이트합니다 (클라이언트는 절대 액터를 서버에 리플리케이트하지 않습니다). 이 점을 염두에 두면, *오직* 서버만 `Role == ROLE_Authority` 이고 `RemoteRole == ROLE_SimulatedProxy` 또는 `ROLE_AutonomousProxy` 로 보일 것입니다.
[/REGION]

## 롤/리모트 롤 반전

롤과 리모트 롤은 이 값을 누가 조사하는가에 따라 반대가 될 수 있습니다. 예를 들어 서버에서 환경설정이 이렇게 되어있다면:
* `Role == ROLE_Authority`
* `RemoteRole == ROLE_SimulatedProxy`

클라이언트에서는 이렇게 보일 것입니다:
* `Role == ROLE_SimulatedProxy`
* `RemoteRole == ROLE_Authority`

이는 정상인데, 액터를 담당하는 것은 서버이며, 이 액터를 클라이언트에 리플리케이트하기 때문입니다. 클라이언트는 그저 업데이트를 받아 그 업데이트 사이 액터에 시뮬레이션을 적용할 뿐입니다.

## 리플리케이션 모드

서버는 업데이트마다 액터를 리플리케이트하지 않습니다. 그러면 대역폭과 CPU 리소스를 너무 많이 잡아먹을 것입니다. 그래서 서버는 `AActor::NetUpdateFrequency` 프로퍼티에 정의된 빈도로 액터를 리플리케이트합니다.

클라이언트에서 액터 업데이트 사이에 약간의 시간이 흐른다는 뜻입니다. 이때문에 액터의 동작이 간헐적으로 끊어져 보일 수가 있습니다. 그에 대한 보정을 위해, 클라이언트는 업데이트 사이에 액터 시뮬레이션을 적용합니다.

현재 발생하는 시뮬레이션 유형은 두 가지입니다.

### `ROLE_SimulatedProxy`
시뮬레이티드 프록시는 표준 시뮬레이션 방법이며, 일반적으로 마지막 알려진 속도에 따라 움직임을 외삽하는 것을 기반으로 합니다. 서버가 특정 액터에 대한 업데이트를 전송할 때, 클라이언트는 그 위치를 새로운 위치쪽으로 조정한 다음, 업데이트 사이마다 클라이언트는 서버에서 전송된 최근 속도에 따라 액터를 계속해서 움직입니다.

마지막 알려진 속도를 사용한 시뮬레이션은 일반적인 시뮬레이션 작동방식의 한 예제일 뿐입니다. 얼마든지 서버 업데이트 사이에 다른 정보를 사용한 외삽법 커스텀 코드를 작성해도 됩니다.

### `ROLE_AutonomousProxy`
자율 프록시는 보통 플레이어 컨트롤러에 빙의된 액터에만 사용됩니다. 이 액터는 사람 컨트롤러에서 입력을 받으므로, 외삽을 할 때 약간의 정보가 더 있으며, (마지막 알려진 속도를 기반으로 외삽하기 보다는) 실제 사람 입력을 사용하여 빠진 정보를 채울 수 있다는 뜻입니다.

