INTSourceChangelist:3108692
Availability:Public
Title:レプリケーションのサンプル
Crumbs:%ROOT%, Gameplay, Gameplay/Framework
Description:マルチプレイヤーに対応するネットワークゲームの設定
Related:Gameplay/Networking/Blueprints
Related:Gameplay/Networking/Actors
version:4.9

具体的な例をみるために、ネットワーク ゲームのクライアント側になったと考えてみましょう。敵 2 人が自分に向かって走ってきて、自分めがけて発砲し、発砲音が聞こえました。すべてのゲーム ステートは端末ではなくサーバー上で管理されているのに、 
なぜこれらの事象を見たり聞いたりすることができるのでしょうか？

敵がクライアントに関係あるとサーバーが認識し、サーバーがクライアントに対してアクタをレプリケートしているため、敵を見ることができます。こうして、自分 (クライアント) を追いかけまわす 2 つのプレイヤー アクタのローカル コピーが 
クライアント側にできあがります。自分を追いかける敵が見える理由は、 
サーバーが敵の Location プロパティと Velocity プロパティをクライアント側にレプリケートしているからです。サーバーから位置が更新されている間は、クライアントは敵の移動をローカルでシミュレーションします。銃声が聞こえる理由は、サーバーがクライアント側に ClientHearSound 関数を 
レプリケートしているからです。PlayerPawn に音が聞こえたとサーバーが判断すると、 ClientHearSound 関数が呼び出されます。

ここまでで、アンリアル マルチプレイヤー ゲームを実行するローレベル メカニズムが明確になりましたでしょうか。サーバーはゲーム ステートを更新し、重要なゲーム判断をすべて行います。サーバー側は 
クライアント側にアクタをレプリケートします。サーバー側はクライアント側に変数をレプリケートします。また、サーバー側はクライアント側に関数をレプリケートします。

全てのアクタをレプリケートする必要があるわけではない、ということも明確です。例えば、アクタがレベルの半分まで行って見えなくなったら、 
その更新を送信する帯域は無駄にしなくて済みます。また、全ての変数を更新する必要もありません。例えば、 AI の判断をするためにサーバーが使用する変数は、クライアント側に送信する必要はありません。 
クライアントが知る必要があるのは、表示変数、アニメーション変数、物理変数だけです。さらに、サーバーで実行されるほとんどの関数はレプリケートできません。クライアント側で何かを見たり聞いたりした場合の関数コールのみ、 
レプリケートする必要があります。従って、すべてのサーバーには膨大な量のデータが含まれ、
プレイヤーが見たり聞いたり感じたりしてクライアントに関わるデータは、そのほんの一部です。

では「アンリアル エンジンはどうやってレプリケートする必要のあるアクタ、変数、関数コールが分かるのだろうか」という疑問が出てくると思います。

答えは、コードの記述またはクラス用にブループリントを設定する人が、レプリケートする必要のある変数と関数を判断しているのです。
