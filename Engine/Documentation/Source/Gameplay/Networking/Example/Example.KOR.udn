INTSourceChangelist:3108692
Availability:Public
Title: 리플리케이션 예제
Crumbs:%ROOT%, Gameplay, Gameplay/Framework
Description:멀티플레이어용 네트워크 게임 구성하기 입니다.
Related: Gameplay/Networking/Blueprints
Related: Gameplay/Networking/Actors
version: 4.9

구체적인 예제로, 네트워크 게임에서 클라이언트인 상황을 생각해 봅시다. 적 두 마리가 총을 쏘며 달려오고 있고, 그 총소리가 들립니다. 모든 게임 스테이트는 
로컬 머신이 아닌 서버에 유지되고있는데, 그러한 것들이 벌어지는 것을 어떻게 보고 들을 수 있는 걸까요?

적을 볼 수 있는 이유는, 서버가 그 적이 연관성이 있다고 (보인다고) 인식해서, 서버가 현재 그 액터를 리플리케이트 해주고 있기 때문입니다. 그러므로 클라이언트에는 
추적해 오는 두 플레이어 액터의 로컬 사본을 갖고 있습니다. 적이 달려오고 있다고 확인할 수 있는 이유는, 서버가 그 위치와 속도 프로퍼티를 리플리케이트시켜주고 있기 때문입니다.
서버에서 위치가 업데이트되는 사이, 클라이언트에서는 내부적으로 적의 움직임을 시뮬레이션합니다. 총소리를 들을 수 있는 이유는, 서버가 ClientHearSound 함수를 리플리케이트하고 있기 때문입니다.
ClientHearSound 함수는 서버에서 플레이어 폰이 소리를 들었다고 결정할 때마다 호출됩니다.

즉 이쯤에서 언리얼 멀티플레이어 게임이 운영되는 로우 레벨 메커니즘이 명확해집니다. 서버에서 게임 스테이트를 업데이트하고 모든 중대 게임 결정사항을 내립니다. 서버는 
몇 가지 액터를 클라이언트에 리플리케이트합니다. 몇 가지 변수도 클라이언트에 리플리케이트합니다. 그리고 서버는 몇 가지 함수 호출도 클라이언트에 리플리케이트합니다.

모든 액터를 리플리케이트시킬 필요가 없다는 것도 명확합니다. 예를 들어 레벨 반대편에 액터가 있는데 시야를 벗어나 있는 경우, 그에 대한 업데이트 정보를 보내느라 대역폭을 낭비할 필요가 없습니다.
또한 모든 변수를 업데이트할 필요도 업습니다. 예를 들어 서버에서 AI 의사결정을 위해 사용하는 변수는 클라이언트에 전송할 필요가 없으며, 클라이언트는 표시, 애니메이션, 물리 관련 변수에 
대해서만 알면 됩니다. 또한 서버에서 실행되는 대부분의 함수도 리플리케이트하지 않습니다. 클라이언트에서 무언가 보이거나 들리게 되는 함수 호출만 리플리케이트해 주면 됩니다.
즉 서버에는 엄청난 양의 데이터가 있으나, 그 중 플레이어가 보고 듣고 느낄 수 있는 것에 영향을 끼치는 것들만 
클라이언트에 중요합니다.

그러므로 논리적으로 생각해 보면, "어떤 액터, 변수, 함수 호출을 리플리케이트해야 하는지는 언리얼 엔진이 어떻게 알까요?" 하는 질문이 들겠지요?

답은, 클래스에 대한 코드나 블루프린트를 작성하는 사람이 변수나 함수의 리플리케이션 여부를 결정할 책임이 있습니다.