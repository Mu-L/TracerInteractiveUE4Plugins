INTSourceChangelist:3692796
Availability:Public
Title:コンポーネント
Crumbs:%ROOT%, Programming
Description:コンポーネントと利用可能な各種タイプの説明
Version:4.9

[TOC (start:2 end:3)]


[EXCERPT:Overview]
**コンポーネント** は、**アクタ** 内のサブオブジェクトとして使用するように設計された特殊な **オブジェクト** です。コンポーネントは、所有するアクタの特定の動作や機能を変更するために、 
簡単に取り替えられる部分が必要な状況で一般的に使用されます。例えば、車の制御や動きは飛行機とは異なり、飛行機の制御や動きは船とは異なります。 
しかし、これらはすべて他に共通点を持つ乗り物です。コンポーネントを使って制御や動きを処理することにより、 
いずれかの特定タイプと同様の動作をする乗り物を簡単に作成できます。
[/EXCERPT:Overview]

一般的にサブオブジェクトのデフォルトの挙動とは逆に、アクタ内でサブオブジェクトとして作成されたコンポーネントはインスタンス化されます。 
つまり、各アクタの特定クラスのインスタンスは、コンポーネントの独自の固有インスタンスを取得します。上述の乗り物の例で思い描くとわかりやすいでしょう。**Car** クラスは、車輪の表現にコンポーネントを使用するかもしれません。クラスのデフォルトプロパティにはサブオブジェクトとして 4 つの **Wheel** コンポーネントが作成され、 
`Wheels[]` 配列へ割り当てられます。新規の Car インスタンスが作成されると、 
Wheel コンポーネントの新しいインスタンスは前述の Car 専用に作成されます。これが該当しない場合、ワールドにある一台の Car が動くと、全ての Car の車輪が回転します。これは明らかに望まれる動作ではありません。デフォルトのコンポーネントのインスタンス化は、 
アクタへ固有のサブオブジェクトを迅速に追加するプロセスを簡素化します。 

[REGION:note]
コンポーネントをインスタンス化しないと、全てのコンポーネント変数は [Instanced](Programming\UnrealArchitecture\Reference\Properties\Specifiers) プロパティ指定子を使用して宣言する必要があります。
[/REGION]

## Actor コンポーネント

**Actor コンポーネント** は、様々なタイプのアクタに追加できる再利用可能な動作を定義するコンポーネントの基本クラスです。通常は、コリジョン ジオメトリやレンダリングされたメッシュという形でジオメトリとアクタの関連付けに使用します。 
アクタがワールドを移動する際の制御や、アクタに関係したサウンドの再生、 
アクタに光や影をワールドへ放つ機能をもたらします。事実、ゲームをプレイ中にワールド内でプレイヤーが目にするものや相互作用するもの全ては、実際に何らかのタイプの **Actor コンポーネント** が作用したものです。 
Actor コンポーネントで、トランスフォームを持つものは **Scene コンポーネント** であり、レンダリング可能なものは **Primitive コンポーネント** です。

### コンポーネントの登録

Actor コンポーネントを各フレームで更新してシーンへ反映させるには、コンポーネントをシーンに **登録** しなくてはいけません。登録は以下を呼び出して行います。 `UActorComponent::RegisterComponent()`. 

	void UActorComponent::RegisterComponent()

この関数は、Actor コンポーネントが所有アクタの `Components[]` 配列に格納されていること、シーンと関連付けること、 
Actorr コンポーネント用に [レンダープロキシ](#シーンプロキシ) と [物理ステート](#物理ステート) を作成することを確認するために、`UActorComponent::RegisterComponentWithScene()` を呼び出します。 

Actor コンポーネントは、所有アクタがスポーンされると自動的に登録されます。 
サブオブジェクトとして作成され、アクタのデフォルトプロパティの `Components[]` 配列へ追加された場合も自動登録されます。再生中のどの時点においても `UActorComponent::RegisterComponent()` を呼ぶことによって登録することができます。 
ただし、コンポーネントの登録は若干負荷がかかる操作なので、本当に必要な場合だけ実行してください。

#### 登録イベント

コンポーネントが登録されると以下のイベントが発行されます。

| 関数 | 説明 |
| -------- | ----------- |
| UActorComponent::OnRegister() | 必要であれば、コンポーネントの登録時に追加の初期化を可能にするイベントです。 |
| UActorComponent::CreateRenderState() | コンポーネントのレンダリング ステートを初期化します。 |
| UActorComponent::OnCreatePhysicsState() | コンポーネントの物理ステートを初期化します。 |


### コンポーネントの登録を取り消す

Actor コンポーネントは、更新、シミュレーション、またはレンダリングを回避するために登録を取り消すこともできます。コンポーネントの登録の取り消しは、以下を呼び出すと実行されます。`UActorComponent::UnregisterComponent()`  

	void UActorComponent::UnregisterComponent()

#### イベントの登録を取り消す

コンポーネントの登録が取り消されると以下のイベントが発行されます。

| 関数 | 説明 |
| -------- | ----------- |
| UActorComponent::OnUnRegister() | 必要であれば、コンポーネントの登録を取り消す際に追加の動作を可能にするイベントです。 |
| UActorComponent::DestroyRenderState() | コンポーネントのレンダリング ステートを初期化前の状態に戻します。 |
| UActorComponent::DestroyPhysicsState() | コンポーネントの物理ステートを初期化前の状態に戻します。 |


###更新

Actor コンポーネントは、`TickComponent()` 関数を用いて各フレームで更新することができます。これにより、コンポーネントは特定タイプやフレーム単位で実行が可能となります。例えば、 
**SkeletalMesh コンポーネント** はアニメーションとスケルタル コントローラーを更新する際に `TickComponent()` を使用します。 
一方、**ParticleSystem コンポーネント** は `TickComponent()` をシステムのエミッタの更新や処理するパーティクル イベントのチェックに使用します。

コンポーネントが更新されるためには、コンポーネントが登録済みで、ティックするように設定し (`bComponentNeverTicks=false`)、そのティック関数が設定されるようにしなくてはいけません。 

###レンダリングステート

Actor コンポーネントをレンダリングするには、レンダリング ステートを作成しなくてはいけません。Actor コンポーネントのレンダリング ステートは、 
レンダリング データの更新を必要とする変更がコンポーネントにあったかどうかをエンジンへ伝達します。変更があった場合、レンダリング ステートはダーティとマークされます。そして現在のフレームの終了時に、全てのダーティ コンポーネントはレンダリング データを更新します。

### 物理ステート

物理エンジンを使用したシミュレーションを行うには、Actor コンポーネントに物理ステートを作成しなくてはいけません。レンダリング ステートとは異なり、変更があると直ちに更新がされる物理ステートは、 
決してダーティとマークされることはありません。フレーム遅れによるアーティファクトが生じるなどの問題を防ぐため大変重要です。

## Scene コンポーネント

Scene コンポーネントは、例えば、位置、回転、スケーリングなどのトランスフォームを持つ Actor コンポーネントの拡張です。トランスフォームが加わるということは Scene コンポーネントもまた相互にアタッチできること 
を意味します。

###アタッチメント

アンリアル エンジン 4 の全てのアタッチはコンポーネント レベルで処理され、Sceneコンポーネントのみを相互にアタッチすることができます。Scene コンポーネントには、 
それ自体がアタッチするコンポーネントをポイントする `AttachParent` プロパティがあります。これは主に、アクタに複数のコンポーネントが含まれていて、その全てのアタッチを維持するために使用します (アタッチすることが望ましい場合)。ただし、別のアクタに属するコンポーネントを指定し、 
あるアクタのコンポーネントを別のアクタのコンポーネントにアタッチする場合にも使用できます。

つまり、アクタを互いにアタッチするには、関連する各アクタが最低 1 つの Scene コンポーネントを持っている必要があります。これらが実際にアタッチされるコンポーネントであり、 
アタッチされているアクタの Scene コンポーネントはルート コンポーネントでなければならないからです。理由は明確です。各コンポーネントは 1 つの親しか持てないため、アタッチされたコンポーネントはアタッチしているアクタのルート コンポーネントでない場合、 
コンポーネントとその子コンポーネントのみがアタッチされます。ルートコンポーネントはアタッチされず影響を受けないままです。 
同様に アクタ全体もルートコンポーネントとそのトランスフォームに依存するため、アタッチされず影響を受けないままです。

### コンポーネントの変換

`FTransform` 構造体には `Translation` ベクター、`Rotation` クォータニオン、`Scale3D` ベクターが含まれます。各 Scene コンポーネントは、独自の `FTransform` があります。 
通常は内部使用のためで、ワールドに相対する位置、回転、そしてスケーリングを表現します。追加の `RelativeLocation` ベクター、`RelativeRotation` ローテータ、そして `RelativeScale3D` ベクターも使用します。 
親コンポーネント、もしくはワールドに相対して機能します。これらはコンポーネントのトランスフォームを取得または設定する際に一般的に使用します。

デフォルト設定で、`RelativeLocation`、 `RelativeRotation`、 そして `RelativeScale3D` は `AttachParent` に対して相対的です。これらの値は `bAbsoluteLocation`、`bAbsoluteRotation`、および `bAbsoluteScale` のプロパティを使用して強制的にワールドと相対的にすることができます。いずれかの値を `true` に設定すると、対応するプロパティがワールドに相対的になります。

親に相対的なトランスフォーム値を使用している時でも、以下のメソッドでワールドの絶対値を使用して、平行移動や回転を設定することができます。


| 関数 | 説明 |
| -------- | ----------- |
| SceneComponent::SetWorldLocation() | ワールド空間で与えられた位置に配置するためこのコンポーネントに相対的な平行移動を設定します。 |
| SceneComponent::SetWorldRotation() | ワールド空間で与えられた向きに配置するためこのコンポーネントに相対的な回転を設定します。 |

## Primitive コンポーネント

**Primitive コンポーネント** はある種のジオメトリを格納または生成する Scene コンポーネントで、通常はレンダリングされるかコリジョン データとして使用されます。様々なタイプのジオメトリに対していくつかのサブクラスがありますが、 
非常に一般的なものは **Capsule コンポーネント**、**StaticMesh コンポーネント**、そして **SkeletalMesh コンポーネント** です。Capsule コンポーネントはコリジョン検知に使用するジオメトリを生成しますが、レンダリングはされません。 
StaticMesh コンポーネントと SkeletalMesh コンポーネントはレンダリングされるビルド済みのジオメトリを格納しますが、コリジョン検知にも使用されます。

### シーンプロキシ

Primitive コンポーネントの `SceneProxy` は、シーンデータをカプセル化する `FPrimitiveSceneProxy` インスタンスです。シーンデータは、Primitive コンポーネントとゲームスレッドを並列してレンダリングするためにミラーリングされています。 
`FPrimitiveSceneProxy` のサブクラスは、各プリミティブタイプに対し作成され、そのタイプのプリミティブをレンダリングするために必要な特定のレンダリングデータを保持します。

プリミティブとジオメトリのレンダリングに関する詳細は、[レンダリングシステムの概要] (Programming/Rendering) を参照してください。

