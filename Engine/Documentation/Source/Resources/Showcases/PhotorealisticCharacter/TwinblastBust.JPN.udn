INTSourceChangelist:4309183
Availability:Public
Title:フォトリアルなキャラクター
Crumbs:%ROOT%, Resources
Description:フォトリアルなキャラクターの胸像のショーケースの概要
Related:Engine/Rendering/Materials
Related:Engine/Rendering/Materials/PhysicallyBased
Related:Engine/Rendering/Materials/LayeredMaterials
Version:4.15
topic-image:PhotorealHead.png
social-image:PhotorealHead.png


[TOC(start:2 end:3)]
[REGION:note]フォトリアルなキャラクターのサンプルは **Epic Games Launcher** の **ラーニング** タブに含まれる **デジタルヒューマン** プロジェクトサンプルに同梱されるようになりました。[/REGION]
[OBJECT:EmbeddedVideo]
	[PARAMLITERAL:videoid]
	K-VyoqRB5_g
	[/PARAMLITERAL]
	[PARAMLITERAL:width]
	100
	[/PARAMLITERAL]
	[PARAMLITERAL:height]
	56.25
	[/PARAMLITERAL]
	[PARAMLITERAL:units]
	%
	[/PARAMLITERAL]
	[PARAMLITERAL:type]
	simple
	[/PARAMLITERAL]
[/OBJECT]

このショーケースの目的は、エピックの MOBA ゲーム、Paragon のキャラクターで使用されたのと同様の高品質なキャラクター シェーダー技術についてデモすることです。このショーケースを観るには、このプロジェクトを開いて [Play In Editor] を押して、シネマティックスのパン アラウンドを見ます。 

このキャラクターを生成するために使った技術の詳しい情報は、[Unreal Engine Livestream - Tech & Techniques Behind Creating the Characters for Paragon](https://www.youtube.com/watch?v=toLJh5nnJA8) をご覧ください。

## スキンシェーディング

キャラクターの皮膚は、UE4 の [サブサーフェス プロファイルのシェーディング モデル](Engine/Rendering/Materials/LightingModels/SubSurfaceProfile/) を使って作成されています。 


![](Skin.png)(w:700 convert:false)

皮膚のマテリアルのベースをセットアップするには、 [マテリアル関数](Engine/Rendering/Materials/Functions/) の使用に注意してください。これは、Paragon のマテリアルを作成する再利用可能なオーサリング アプローチとして行われます。このやり方を用いて、アーティストはひとつの関数に対する基本的な変更が、その関数を使用する全インスタンスを更新することを理解したうえで、一部のタイプのサーフェスを生成するアプローチを標準化することができます。 

### スキン シェーダーのテクスチャ 

キャラクターの皮膚で使われているテクスチャーは、すべて 4K の解像度であり、もともと人の顔をスキャンして作られています。テクスチャはエピックのアーティストがクリーンアップして微調整しています。この皮膚のセットアップでは、ディフューズ、ラフネス、スペキュラリティ、散乱、法線の合計 5 種類の テクスチャ マップを利用しています。

| テクスチャ | 名前 | 説明 |
|---------|------|-------------|
|![](SkinDiffuse.png)(w:200 convert:false)|**Diffuse**|ディフューズ マップは、マテリアルの基本色を与えます。4K で、サーフェスのすぐ下に毛細血管があるのがわかります。しわが黒くなると、法線マップによって与えられるテクスチャが強調されます (*UE4_Demo_Head_D*)。|
|![](SkinRough.png)(w:200 convert:false)|**Roughness**|ラフネス マップは、ディフューズ テクスチャのアルファ チャンネル内に保存されます。これは使用するテクスチャ量を最小限に抑えるために使われる一般的なテクニックです。毛穴としわの中でラフネスが増していることがわかります。これにより、こうしたエリアの光沢を減らして、ディフューズと法線マップによる深度の見た目を強調します。頭部の髪のテクスチャは完全にラフ (1.0) になっており、頭皮からのスペキュラ ハイライトの迷光を防ぎます。これにより、髪の深度がよりはっきりと感じられるようになります (*UE4_Demo_Head_D*)|
|![](SkinSpec.png)(w:200 convert:false)|**Specular**|スペキュラ マップは皮膚のサーフェスで可視のスペキュラ ハイライトの量をスケーリングします。スペキュラリティ (鏡面反射性) のデフォルト値は、0.5 であることが重要です。このマップは、皮膚が少しタイトにストレッチされうる場所でスペキュラリティを増して、毛穴の中央や、しわの中など反射させたくない場所で抑えます。(*CH2_exp04_merged_spec_f_FC_FINAL*)|
|![](SkinScatter.png)(w:200 convert:false)|**Scatter**|散乱マップは、皮膚のサーフェスを通してどの程度光が散乱するかを制御します。頬など暗くなっている場所の散乱はごくわずかですが、鼻や耳などの明るめの場所では認識される散乱量は増えます。散乱の色は、 [Subsurface Profile アセット](Engine/Rendering/Materials/LightingModels/SubSurfaceProfile/) (*UE4_Demo_Head_BackScatter*) によって管理されます。|
|![](SkinNormal.png)(w:200 convert:false)|**Normal**|法線マップはピクセルの法線に凹凸を与えることでサーフェスを立体的なテクスチャにし、通常のマテリアルのセットアップで期待通りに機能します。このサンプルのセットアップでは、特に変わったものはありません。 (*UE4_Demo_Head__normals*)|


## ヘアシェーディング

ヘアシェーディングは、UE4 のヘア シェーダー モデルによって処理されます。このシェーダーは [Eugene d'Eon 氏、Steve Marschner 氏、および Johannes Hanika 氏](http://www.eugenedeon.com/project/importance-sampling-for-physically-based-hair-fiber-models/) によるリサーチに基づいた物理ベースのシェーディング モデルです。現在は、[Weta Digital](http://www.wetafx.co.nz/research) によって使用されています。シェーダーはアニソトロピック (異方性) スペキュラリティとそれを通る屈折と複数の髪の毛への散乱を用いてヘアのサーフェスからの光の反射を近似します。 

UE4 のヘア シェーダーを利用するには、マテリアルの **Shading Model** プロパティを **Hair** に設定します。


![](HairSM.png)

### 髪とスペキュラリティ

現実世界では、髪は複数のスペキュラ ハイライトを持ちます。光の色を表すもの、および髪の色と光の色を混ぜ合わせたものもあります。このドキュメントでは、これらをプライマリ スペキュラ ハイライトとセカンダリ スペキュラ ハイライトと呼びます。ヘア シェーダーは、同じエフェクトを非常にリアルな結果に近づけます。

![](TwinblastHair_Specs_Diagram.png)(w:700 convert:false)
[REGION:caption]1. 淡い色の髪はプライマリ スペキュラ ハイライトです。2. 濃い赤い色のヘアは、セカンダリ スペキュラ ハイライトです。[/REGION]

UE4 のヘア シェーダーで使われる近似アルゴリズムは、現実世界と同じようなやりかたでこうしたエフェクトを作成します。ライトが毛包 (毛が作られる場所で、その中で皮膚表面から見える部分が毛穴) の表面にあたり、単純にバウンスしません。髪は透過であるため、一部の光は髪の中を通過し、その中でバウンスして、出ていきます。以下のアニメートされた GIF の図のようにヘア シェーダーは、光が髪に作用する場合に、これを光が伝搬する 3 つの考えうる経路で近似します。

![](HairDiagram.gif)(w:700 convert:false)
[REGION:caption]一本の髪の毛包の断面を見ると、3 つの主な光の通り道があり、光との相互作用でヘア シェーダーがどのように近似するかがわかります。プロセスの各部分の説明については、以下の表をご覧ください。[/REGION] 

| 番号 | 説明 |
|--------|-------------|
|0. |毛包の成長方向 (毛根から先端)。 |
|1. |光が髪の表面でバウンスする反射のみの経路。これはプライマリ スペキュラ ハイライトを生成します。|
|2. |光が毛包に入りもう一方の側から戻る透過から透過の経路。髪の中で光が散乱する様子を表しています。|
|3. |光が毛包に入り、表面の境界内から反射し、出ていく透過、反射、透過の経路。これはセカンダリ スペキュラ ハイライトを生成します。|

上図のように髪の束は完全なシリンダー状、チューブ状ではありません。実際に髪は円錐状のものが重なった状態に似ています。つまり、髪の表面で跳ね返る光は、髪が完璧に滑らかな場合に比べて、散乱の様子が異なります。さらに髪の一本一本は一般的に別の方向を向いています。スペキュラのハイライトは統一されませんが、髪が向いている方向に応じて個別に配置されます。これは、アニソトロピック (異方性) スペキュラリティと呼ばれ、UE4 のヘア シェーダーでもサポートされています。

### 髪と透過処理

ヘア シェーダーでは半透明の代わりにマスクしたブレンド モードを使用します。ただし、マスクした透過処理では二値の結果が得られます。サーフェスは完全に不透明か完全に透明になります。ノイズのディザ パターンが絶えずサーフェス上を移動し、よりソリッドになる必要がある箇所では密度が高くなります。ディザはマスクした透過処理をブレンドする方法として使われますが、TemporalAA がアクティブな場合に限り機能します。 

[OBJECT:ComparisonSlider]
[PARAM:before]
![Without TemporalAA](Hair_AAOff.png)(w:700 convert:false)
[/PARAM]
[PARAM:after]
![With TemporalAA](Hair_AAOn.png)(w:700 convert:false)
[/PARAM]
[/OBJECT]

[REGION:note]アニメートされたディザを TemporalAA と合わせて使用すると、このブレンドをリゾルブするためにいくつかのフレームが必要です。これにより動作中に髪にアーティファクトが生じることがありますが、これは、この技術で起こる予測範囲内の影響です。[/REGION]

#### エッジのマスキング

![](EdgeMaskGraph.png)(w:700 convert:false)

シェーダーの一部ではありませんが、サンプル キャラクターの髪で使われているマテリアルおよび 『Paragon』 の他のキャラクターでは、いわゆる「エッジ マスク」を使ってカメラに対して真横になるにつれて髪をフェードさせます。髪は一連の平面としてレンダリングされるため、 (以下の [髪のジオメトリ](#髪のジオメトリ) を参照) 一定のカメラ アングルからは、各シートのエッジが見えて、ヘアのエフェクトが壊れます。

この問題を軽減するために、マテリアルは頂点法線に対してカメラのベクターを計算し、サーフェスがカメラから垂直に遠ざかるにつれて、完全に透過にフェードしていくようにします。このアプローチの他の面としては、そうすることでヘア シェーダーが頭皮を多く見せる可能性があります。これは髪の量が多いキャラクターでは多くの場合、以下の画像のように頭皮にヘア テクスチャがペイントされている理由でもあります。

![](HairPaint.png)(w:700 convert:false)


[REGION:tip]このエフェクトは、Quality Switch ノードに結び付いていて、性能が低いプラットフォームでは一部のシェーダー パフォーマンスと引き換えに簡単にオフにすることができます。常にターゲット プラットフォームでテストを実施すると良いでしょう。[/REGION]





###髪のオーサリング

このショーケースで示した技術を使って髪を作成するには、エピックがこのキャラクターの髪をどのように作成したかについて少々理解する必要があります。

#### 髪のジオメトリ

UE4 のヘア シェーダーを使ったヘア ジオメトリは一般的に、一連の平面でないシート サーフェスを使って構築されます。これは、多くのリアルタイム ヘア ソリューションで一般的なアプローチです。これは、お好きな DCC アプリケーションでオーサリングできます。

[REGION:note]ヘア ジオメトリの詳細について厳格なルールがあるわけではありませんが、このキャラクターは約 800 の個別のヘア シートを使用し、合計で約 18,000 のトライアングルを使っています。メイン マテリアル ノードのプロパティではヘア マテリアルは両面を使うように設定されていることにも注意してください。[/REGION]

![](HairSheets.png)(w:700 convert:false)


#### ヘア テクスチャ

UE4 のヘア シェーダーでこれを使用すると、最終結果は以下の 5 つの主要テクスチャによって操作されます。すなわち、*Diffuse*、 *Alpha*、 *Root*、*Depth*、および髪一本毎に固有の *ID* の 5 つです。エピックでは、こうしたテクスチャは通常 3ds Max の Hair システムを使って生成しています。シミュレートしたヘアの結果をジオメトリのピースに投影しています。ただし、同じような結果を得るために利用できるオプションは他にもあります。 


| テクスチャ | 名前 | 説明 |
|---------|------|-------------|
|![](Diffuse.png)(w:200 convert:false)|**Diffuse**|ディフューズ テクスチャは、髪そのものの色のプライマリ ディフューズすなわちベースとなります。このテクスチャの色は無しにして、色をパラメータで操作するのが望ましい場合があります。特にキャラクターの髪が多様な色になる場合にこれが該当します。(*UE4_Demo_Hair_D*)|
|![](Alpha.png)(w:200 convert:false)|**Alpha**|Alpha テクスチャは、髪のオパシティのエリアを指定し、髪の束の外側のジオメトリを隠します。 (*UE4_Demo_Hair_A*)|
|![](Root.png)(w:200 convert:false)|**Root**|Root テクスチャは、毛根から先端までの色を変更するマスクを提供します。長さ方向に沿って髪の色を明るくしたり、暗くするのに便利です。 (*UE4_Demo_Hair_Roots*)|
|![](Depth.png)(w:200 convert:false)|**Depth**|Depth テクスチャは、Pixel Depth のオフセットによって使用され、髪全体の奥深くに髪があるかのような錯覚を与えます。髪が頭皮に向かうと全体的なスペキュラリティを減らすなど色やシェーディングの値を変更する基本として使用することもできます。 (*UE4_Demo_Hair_Depth*)|
|![](ID.png)(w:200 convert:false)|**Unique ID**| Unique ID テクスチャは、ヘア ジオメトリの任意の部分の髪一本ずつに 0 から 1 (黒から白) の固有の値を与えます。これは髪そのものに微妙な変化を与えるために使用します。(*UE4_Demo_Hair_ID*)|



### ヘア シェーダーのプロパティ

ヘア シェーダーを使用すると、メインのマテリアル ノードで一部の新しいプロパティ、**Scatter**、 **Tangent**、 および **Backlit** を利用できるようになります。

![](HairProperties.png)

[REGION:warning]このドキュメントの作成時点 (4.13) では、Backlit プロパティは、シェーダーの早期バージョンの一部としてのみ存在します。ヘア シェーダー内部では、これに接続しないため、このプロパティは無視することができます。[/REGION]

#### 散乱

ヘア シェーダーをシミュレーションではなく、近似であると言及する主な理由は、実際には個々の髪をシミュレーションせず、完全に正確なライティングの挙動をシミュレーションするわけではないからです。現実世界では、光が、毛包をバウンスし、その中を透過すると、多くの場合、他の髪の束があり、同じプロセスを何回も連続して繰り返すことになります。現時点で、こうしたシミュレーションのエフェクトをリアルタイムで正確に生成する機能を持つコンピューティング システムはありません。

しかし、髪の中で光がどのように散乱するかは、現実世界と同じようにゲーム内で髪をリアルに見せるために重要です。これを制御するためにヘア シェーダーには、Scatter プロパティがあります。これはプライマリ シェーダー ノードの Metallic に代わるものであり、0.0 と 1.0 の間の値に制限されます。Scatter は、キャラクターの髪全体を単一のサーフェスであるかのように、どれくらいの光が通過するかを制御します。 

Scatter について重要な点は、明るい色の髪では高くなり、暗い色の髪では暗くなります。これは自然界の物理のルールに従います。髪の色が暗いほど、より多くの光を吸収します。実際の問題として、ブロンドの髪のキャラクターを作ろうとしているなら、ディフューズ テクスチャまたは色を変えるだけでは不十分です。Scatter 値も増やさなければなりません。


[OBJECT:ComparisonSlider]
[PARAM:before]
![Scatter value of 0.0](Scatter_0.png)(w:700 convert:false)
[/PARAM]
[PARAM:after]
![Scatter value of 1.0](Scatter_1.png)(w:700 convert:false)
[/PARAM]
[/OBJECT]
[REGION:caption]このサンプルでは Root と Tip の色は、淡いブロンドに設定され、Random Variation は 0.0 に設定されています。Scatter を使ってどれくらいの光が髪を通るかを近似します。これは、Scatter 値を変えるだけで、様々な髪のトーンが生成される様子を表しています。[/REGION]

#### Tangent

Tangent プロパティは、ヘア シェーダーの Normal プロパティに変わるものです。接線は毛根に向かう各髪に平行なベクターとして計算されます。Tangent プロパティは、適切な異方性スペキュラリティを支援するためのものです。異方性スペキュラリティとは、つや消しした金属など、微小な溝のあるサーフェスからライトがバウンスするときに起こるものです。 

![](AnisoVsNonAniso.png)(w:700 convert:false)
[REGION:caption]左の球体は異方性があり影がありますが、右側はそうではありません。異方性スペキュラ ハイライトがサーフェスにそって伸びているのがわかります。[/REGION]

Tangent プロパティは、主に異方性ハイライトが伸びる方向を制御するためのベクターとして使用されます。

![](HairTangent.png)(w:700 convert:false)
[REGION:caption]この画像では黄色の線は、髪一本に沿う毛根に向かう接線を表します。[/REGION]

[REGION:tip]サンプル キャラクターのヘア シェーダーでは、ベクターは固有の ID テクスチャを使って 0.3 と -0.3 との間の Z- 軸でランダムなオフセットを与えられます。これで、円弧内でランダムな方向を持つベクターが生成され、異方性スペキュラ ハイライト内で変化をつけます。実際の髪の束で見られるのと同様です。[/REGION]

接線は、自動またはフロー マップの使用のいずれかの方法でマッピングされます。自動の方法では、一面の髪のテクスチャが、毛根が上に向かい、先端が下部に向くようにする必要があります。髪が短い限り、面が曲がったり、ツイストしすぎたりせず、この方法が適切です。サンプル キャラクターの髪で使われたのはこの方法です。

##### 接線のフローマップ

もうひとつの方法では、フローマップを作成する必要があります。これはキャラクターの髪が長く、真っ直ぐではなく、実際のジオメトリよりも曲がったり、カールしている必要がある場合、または髪の個々のテクスチャ部分が様々な方向に向いている場合に便利です (上記のように上から下ではなく)。フロー マップは、タンジェント空間すなわちサーフェスに沿って髪が動く方向を表します。Photoreal Character Bust プロジェクト内には、*T_Hair_Flow* という名前の未使用のフローマップがあります。以下は、フローマップとスペキュラリティの結果を比較したものです。 

[OBJECT:ComparisonSlider]
[PARAM:before]
![Final Result](SparowFlowMap.png)(w:600 convert:false)
[/PARAM]
[PARAM:after]
![Flow Map Texturing](SparowFlowMap2.png)(w:600 convert:false)
[/PARAM]
[/OBJECT]
[REGION:caption]ここでは、Sparrow の髪の表面にそってフローマップがどのようにテクスチャリングされるかがわかります。フローマップは、一部の髪の面でのみ使用され、髪全体で使用されるわけではないことに注意してください。フローマップに沿う様々な値によって、髪に沿ってスペキュラリティが変わるのがわかります。[/REGION]




#### ヘア シェーダーでピクセル深度オフセットを使用する

Pixel Depth Offset (PDO、ピクセル深度オフセット) は、ヘア シェーダー固有のプロパティではありません。わかりやすく説明すると、PDO ではカメラから離れてピクセルがへこんでいるように見え、サーフェスにそって人工的な深度を作り出します。[髪のジオメトリ](#髪のジオメトリ) で説明しているように、髪は単純なジオメトリのシートでできています。PDO を使用すると、全体として髪の形状に深度を加えます。以下のように髪のジオメトリの面が頭皮に接触する交差ポイントも分けます。

[OBJECT:ComparisonSlider]
[PARAM:before]
![Without Pixel Depth Offset](PDO_off.png)(w:700 convert:false)
[/PARAM]
[PARAM:after]
![With Pixel Depth Offset](PDO_On.png)(w:700 convert:false)
[/PARAM]
[/OBJECT]




## 目のシェーディング

![](EyeShading2.png)(w:700 convert:false)

目は、しばしば「心の窓」と言われます。実際の人間としてキャラクターの目ほど見る側の認識に影響を及ぼす部分はありません。UE4 の目のシェーダーは、目の表面をリアルにレンダリングするように設計されています。目そのものの生物学的な各部をアーティスティックに制御します。

[REGION:warning]UE4 の目のシェーダーは非常に技術的で、シェーダーのコード、マテリアル、ジオメトリの形状、およびジオメトリの UV レイアウトとの間で非常に **強い従属関係** を持つように開発されてきました。シェーダー開発で幅広い経験がない場合は、このシェーダーを使って何もないところから目を作るのはお勧めしません。この観点から、リアルな人間の目を作るには、このサンプルから目のジオメトリを抽出して、目的に合わせて必要なテクスチャを置き換えて目のマテリアルを **そのまま** 使うことを強くおすすめします。[/REGION]

[REGION:tip]Photoreal Character プロジェクト内に **PhotorealEyeGeo** という名前のスタティックメッシュがあります。これをプロジェクトから FBX 経由でご自分の DCC アプリケーションにエクスポートして各自のプロジェクトで使用することができます。[/REGION]

### 目の生物学

目の機能を十分に理解するには、簡単に目の仕組みを理解すると良いでしょう。ここで示す各部は、この目の構造で表されています。サンプル キャラクターの目に適用されたマテリアル インスタンス (*MI_TwinBlast_EyeRefractive_Bust*) で公開されているパラメータを使って変更することができます。

以下は概要です。

![](EyeDiagram.png)(w:700 convert:false)
|番号|名称|説明|
|------|----|-----------|
|1|強膜|眼球の白目部分です。目のこの部分は一般的に湿っていて、若干立体的なテクスチャになっています。|
|2|縁|虹彩と強膜の間にある暗い色の輪です。目によって目立つ度合いが異なり、真横から見ると見えなくなる傾向があります。|
|3|虹彩|目の中央周辺にある色の輪です。目が緑色であるのは、虹彩が主に緑色だからです。実際の目では、虹彩は筋肉状の繊維の輪であり、拡張、収縮し、瞳孔に入ってくる光の量を調整します。現実の世界では、虹彩は実際にはディスク状あるいは円錐形状であり、目の他の部分から出っ張ってはいません。|
|4|瞳孔| 瞳孔は、目中央部の暗い部分です。網膜の桿体細胞と錐体視細胞を通った光が通る穴です。|
|5|角膜|透明であり、液体で満たされたドーム状のもので、虹彩の表面上にあります。 |

### 目の中の屈折 - これまでと現在

眼球は液体で満たされているため、その中を通る光は屈折します。複数の角度から目を見ると、現実世界でもこれがわかります。角膜から見ると虹彩と瞳孔は反射によって歪みます。ゲームや映像でこれに対処する従来のアプローチは、2 つの別箇の目のサーフェスを作るというものです。ひとつは、強膜、虹彩、瞳孔になり、その上のもうひとつのサーフェスは角膜と全体的な目の水分になります。これにより、屈折が可能になります。下の方にあるサーフェスが水分がある層のシェルを通して見られるからです。こうしたアプローチは、エピックの「A Boy and His Kite」の技術デモで使用されました。以下の図では、2 つのサーフェスを表しています。

![](KiteBoyEyes.png)(w:700 convert:false)

ただし、目のシェーダーを使うと、1 つのサーフェスでさらにリアルなエフェクトを実現できます。角膜表面を通る光の屈折は、現在完全にシェーダー内で処理されています。これにより、下の層のジオメトリの必要性が軽減されます。これを試すには、*MI_EyeRefractive_Bust* マテリアル インスタンスを開いて、**Refraction On/Off** プロパティを調整します。

[OBJECT:ComparisonSlider]
[PARAM:before]
![Without Refraction|(Refraction On/Off at 0.0)](NotRefracting.png)(w:700 convert:false)
[/PARAM]
[PARAM:after]
![With Refraction|(Refraction On/Off at 1.0)](Refracting.png)(w:700 convert:false)
[/PARAM]
[/OBJECT]

### Eye Shader パラメータ

目のシェーダーは非常に複雑であり、そのまま使うことを推奨しています。マテリアルに組み込まれたアーティスティックなパラメータの内容を示します。以下は、 *MI_EyeRefractive_Bust* Material Instance Constant 内から微調整可能な目のシェーダーのパラメータです。可能な限り、推奨パラメータ範囲も含みます。

![](MI_EyeRefractive_Bust.png)

|名前|説明|値の推奨範囲|
|----|-----------|-------------------|
|[REGION:tablesection]Static Switch Parameter Values[/REGION]|||
|**UseEyeBulge**|このプロパティは、眼球のジオメトリが物理的にモデリングされた角膜の膨らみを使うかどうかに基づき、シェーダーの屈折プロパティを調整するためのものます。|なし|
|[REGION:tablesection]Vector Parameter Values[/REGION]|||
|**Sclera inner color**| 虹彩と接触する場所での強膜の色です。|なし|
|**Sclera outer color**| 目の外縁の強膜の色です。| なし|
|**SecondaryEnvBalance**|目の表面で [二次環境](#目のシェーダーの二次環境) がどの程度見えるかを制御します。|0.00 - 0.03|
|**SecondaryEnvRotationAxis**| [二次環境](#目のシェーダーの二次環境) は、見せかけの反射なので目の周囲で手動で回転させなければなりません。このプロパティは回転する軸を制御します。| 0.0, 0.0, 1.0 Z-Axis|
|[REGION:tablesection]Scalar Parameter Values[/REGION]|||
|**Depth Scale**|角膜の下の虹彩の屈折の深度を制御します。 |1.0-1.4|
|**Flatten Normal**|この値は目の法線マップを、特に強膜に焦点をあてて、どの程度平らにするかを制御します。|0.9 - 1.1|
|**IoR**|角膜の下の体液の屈折率。どれくらい屈折するかを制御します。|1.336|
|**Iris Concavity Power**| *Iris Concavity Scale* と併用し、光が角膜を通過するときに虹彩の表面上で計算されるライトのコースティックの形状と量を制御します。これは一般的に実際の lit (ライティング有り) シーンでのみ可視になり、マテリアル インスタンス エディタ内で視覚化するのは難しい場合があります。|0.2 - 0.3|
|**Iris Concavity Power**| *Iris Concavity Power* と併用し、光が角膜を通過するときに虹彩の表面上で計算されるライトのコースティックの形状と量を制御します。これは一般的に実際の lit (ライティング有り) シーンでのみ可視になり、マテリアル インスタンス エディタ内で視覚化するのは難しい場合があります。|0.07 - 0.15|
|**Iris UV Radius**| 眼球上の虹彩の全体的なサイズを制御します。|0.14 - 0.15|
|**Iris Brightness**| 虹彩の明るさを制御します。 | *虹彩の色に応じて変わります* |
|**Iris Roughness**| 虹彩のすぐ上の表面である角膜がどれくらい輝くかを操作します。 | 0.0 - 0.1 |
|**Limbus Dark Scale**| 縁の暗くなる輪のサイズを制御します。 | 2.0 - 2.15 |
|**Limbus Pow***| 縁領域の全体的な暗さを制御します。過度な値は角膜領域全体を暗くしてしまいます。 | 15.0 - 22.0 |
|**Limbus UV Width Color**| 縁のサンプル サイズを制御します。または縁を表すためにどれくらいの目の表面を割り当てるかを制御します。これは非常に微妙な設定であるため、最新の注意を払って調整してください。 | 0.025 - 0.040 |
|**Limbus UV Width Shading**| 縁のシェーディングにどれくらいの量の光が影響を及ぼすかを制御します。これは非常に微妙な設定であるため、最新の注意を払って調整してください。 | 0.040 - 0.050 |
|**Normal UV Scale**| 目の表面全体で使われる法線マップ テクスチャのスケールを制御します。 | 1.8 - 2.6 |
|**Pupil Scale**| 瞳孔の大きさを制御します。目を拡張するために使う設定です。 | 0.5 - 1.0 |
|**Refraction On/Off**| シェーダーの屈折するバージョンと屈折しないバージョンとの間でブレンドします。 | 1.0 |
|**Scale By Center**| 虹彩 / 瞳孔全体の中央からのスケールを調整します。 | 0.8 - 1.2 |
|**Sclera Brightness**| 強膜すなわち白目部分の明るさを制御します。 | 0.9 - 1.3 |
|**Sclera Roughness**| 強膜のマテリアルのラフネス値を制御します。| 0.0 - 0.1 |
|**Secondary Env Rotation**| SecondaryEnvRotationAxis プロパティを使って定義した軸の周りを [二次環境のキューブマップ](#目のシェーダーの二次環境) が回転するようにします。 | なし |
|**Shadow Hardness**| 強膜の内側と外側の色間のブレンドの鮮明さを制御します。Shadow Radius と併用し、強膜表面全体でシェーディングを操作する支援をします。眼球表面全体でまぶたがキャストするサブサーフェス スキャタリングのシャドウの影響を近似します。 | 0.1 - 0.2 |
|**Shadow Radius**| 強膜の内側と外側の色間のブレンドのサイズを制御します。Shadow Hardness と併用します。 | 0.5 - 0.85 |
|**Specularity Iris**| 角膜全体 (虹彩と瞳孔) のスペキュラリティ レベルを制御します。 | 0.25 - 0.8 |
|**Specularity Sclera**| 強膜全体のスペキュラリティ レベルを制御します | 0.25 - 0.8 |
|**Veins**| Sclera Color Map として示される目の静脈の可視性を制御します。 | *Sclera Color Map と望ましい静脈の量に応じて変わります。* |
|[REGION:tablesection]テクスチャ パラメータの値[/REGION]|||
|**Iris Color**| 以下の [目のテクスチャ](#目のテクスチャ) を参照してください。 | なし |
|**Normal Map**| 以下の [目のテクスチャ](#目のテクスチャ) を参照してください。 | なし |
|**Sclera Color**| 以下の [目のテクスチャ](#目のテクスチャ) を参照してください。 | なし |
|**Secondary Env**| 二次反射環境として使われるキューブマップです。以下の [目のシェーダーの二次環境](#目のシェーダーの二次環境) をご覧ください。 | なし |



#### 目のシェーダーの二次環境

二次環境は目のシェーダーの一部であり、目の表面に見せかけの反射マップを与えます。シェーダーで SecondaryEnv ParamCube を使ってテクスチャを与えて、他の SecondaryEnv プロパティで制御することができます。これは、目の前の環境や別のキャラクターなど特定の反射が見えるようにする場合、目をドラマチックにクローズアップする場合に役立ちます。

[OBJECT:ComparisonSlider]
[PARAM:before]
![Without Secondary Environment|(SecondaryEnvBalance at 0.0)](SecondaryEnvOFF.png)(w:700 convert:false)
[/PARAM]
[PARAM:after]
![With Secondary Environment|(SecondaryEnvBalance at 0.03)](SecondaryEnvON.png)(w:700 convert:false)
[/PARAM]
[/OBJECT]

### 目のオーサリング

このセクションの前の方で、目のシェーダーのコード、マテリアルのセットアップ、目のメッシュのジオメトリとの間には強い従属関係があることを警告しました。以下では目のセットアップがいかに特別であるかについての概要を説明します。これは、ジオメトリをキャラクターの目のメッシュで置き換える場合に役立ちます。

独自の目を作成する場合、このサンプルに入っている実際の目のジオメトリとマテリアルを使用することを **強く** お勧めします。ここで扱う情報のほとんどは、これらを使用することを前提にしています。 

[REGION:tip]Photoreal Character プロジェクト内に **PhotorealEyeGeo** という名前のスタティックメッシュがあります。これをプロジェクトから FBX 経由でご自分の DCC アプリケーションにエクスポートして各自のプロジェクトで使用することができます。[/REGION]

#### 形状と UV レイアウト

現実世界の人間の目のように、目のメッシュは完全に球状になるようにモデル化されていません。角膜を表すために前面ではっきりとドーム状になっています。こうした形状から、目はほとんど卵形になっています。

![](EyeGeometry.png)(w:400 convert:false)
[REGION:caption]この画像では、Maya で横から見た目のジオメトリを示しています。前面の角膜の一部が高く上がっているのがわかります。[/REGION]

目の UV レイアウトも非常に重要です。これを使って、各目のテクスチャの比率が生成されるからです。幸い、目のシェーダーで最もうまく機能する UV レイアウトはどちらかというと基本的なものです。目の前の軸に沿った平面プロジェクションです。裏面を含めるかどうかは、あまり重要ではありません (いずれにせよ目の後ろ側だからです)。サンプル キャラクターをご覧いただければわかります。
 
 UV レイアウトは以下のようになります。

![](EyeUVs.png)(w:400 convert:false)
[REGION:caption]UV レイアウトは 0-1 空間の中心にあり、プロジェクションは直接角膜を見ます。[/REGION]


### 目のテクスチャ

目のために作成するテクスチャの多くは、虹彩のマップを除いて、上記で作成した UV レイアウトに基づきます。基本的に編集可能なテクスチャとして以下があります。

| テクスチャ | 名前 | 説明 |
|---------|------|-------------|
|![](ScleraMap.png)(w:200 convert:false) |**Sclera Map**|この強膜マップは、白目の色を制御します。さらに、目の端にある静脈と組織の色も制御します。例えば、キャラクターの目を充血させたい場合は、(*UE4_Demo_Eye_Sclera_Color*) のテクスチャを修正します。|
|![](DispMap.png)(w:200 convert:false) |**Mid Plane Displacement Map**|このマップは目の中央を横断する平面をロックするために使い、虹彩の深度をオフセットする基本として使用します。(*EyeMidPlaneDisplacement_Example*)|
|![](WetNormal.png)(w:200 convert:false) |**Normal Map**|この法線マップは、立体的なテクスチャにする機能があるすべてのシェーダーの法線マップと同じように機能します。サンプル キャラクターの目のセットアップでは、目の湿った表面にそって小さなでこぼこを作っています (*T_Eye_Wet_Normal*)|
|![](Normal.png)(w:200 convert:false) |**Tangent Map**|タンジェント マップはタンジェント空間に流れこむサーフェスの方向を制御するために使用します。サンプル キャラクターの目のセットアップでは、角膜が強膜と接触する方向の変化を強調するために使用します。(*EYE_NORMALS.EYE_NORMALS*)|
|![](IrisTexture.png)(w:200 convert:false)|**Iris Map**|虹彩のテクスチャは UV レイアウトと一致しないという点においてユニークなものです。代わりにこのテクスチャは解像度を全体的に満たします。UV とアルファ マスクは、全体的な虹彩のサイズ、および瞳孔のサイズを制御するために使用します。独自の虹彩マップを作成することが難しければ、与えられたテクスチャの比率に近くなるように瞳孔のサイズを適切に維持するようにしてください。(*UE4_Demo_Eye_Iris*)|

[REGION:warning]Tangent Map の出力が Normal Map の入力に直接 **入力されないことに注意してください。**これは、**Tangent Output** ノードに接続されます。マスター マテリアルの **M_HairSheet_Master2** のように別個に作成しなければなりません。[/REGION]
![](TangentOutput.png)



### 目のアンビエント オクルージョン

サンプル キャラクターの目のセットアップの最終部分では、目の周囲にアンビエント オクルージョンをシミュレーションするために、透明のヘルパー サーフェスを使用します。現実世界では、目がまぶたや涙腺などの他の組織に接触するたびに、非常にソフトな陰影があります。このソフトさは、目そのものが透明であるためであり、光がその中で散乱します。これを現実的にシミュレートするために、目をカバーし、近似されたアンビエント オクルージョンが得られるジオメトリのシートを配置し、目全体のリアルさを増します。

このシートに適用されるマテリアルは、*MI_Eye_Occlusion_Bust* という名前であり、サンプル キャラクター モデルの Element 3 に入っています。

[REGION:note]キャラクターの目のコンテンツのオーサリングをする場合、ジオメトリのこの部分を自分でビルドする必要性が高くなります。まぶたが開いた領域にフィットし、その UV がご利用の 3D モデリング アプリケーション 0 から 1 の UV 空間をきちんと満たすようにします。[/REGION]

![](AOSheetMaya.png)(w:700 convert:false) 
[REGION:caption]この画像は、顔のジオメトリなしの Maya のアンビエント オクルージョン シートのジオメトリです。シートの境界エッジはまぶたの開口部分を完全に満たします。[/REGION]


[OBJECT:ComparisonSlider]
[PARAM:before]
![Without AO Sheet](WithoutAO.png)(w:700 convert:false)
[/PARAM]
[PARAM:after]
![With AO Sheet](WithAO.png)(w:700 convert:false)
[/PARAM]
[/OBJECT]



## 謝辞

[Importance of sampling for physically-based hair fiber models (物理ベースの髪の繊維モデルのサンプリングの重要性)](http://dl.acm.org/authorize?6967840) を公開してくださった [Eugene d'Eon 氏、 Steve Marschner 氏、 およびJohannes Hanika 氏](http://www.eugenedeon.com/project/importance-sampling-for-physically-based-hair-fiber-models/) の皆様に感謝いたします。 UE4 のヘア シェーダーの一部はこの内容に基づいたものです。
