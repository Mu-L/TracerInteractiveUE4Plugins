Availability:NoPublish
Title:Rolling Overview
Description:Rolling Template Overview
Crumbs:

[EXCERPT:StageMain]
[VAR:StageTitle]
Rolling Template.
[/VAR]

![](RollingScreen.png)

This is a template for a rolling game using C++. It is very simple and consists of a rolling ball and a level in which to roll. 
The level itself features some platforms and some cubes. Some of which can be knocked over, some that cannot.
Pretty much all of the actual 'work' in this template is handled by the physics within engine.

You can move around the level with either the W,A,S,D keys on the keyboard or the left stick of an attached controller and you can make the ball jump by pressing space or the A button on the controller.

The main classes in this template are:
* MarbleBall - this is the Game pawn class - the ball itself.
* MarbleGameMode - the game mode class. 

We shall look now these in greater detail.

[/EXCERPT:StageMain]

[EXCERPT:StageOverview]

[VAR:StageTitle]
Rolling game - Overview
[/VAR]

When you create a project from any template the unreal engine editor will create files in the folder you select and use the project name to create these files. The generated source code will be placed in the a folder named Source in the folder you selected for your project. For the purposes of this tutorial we shall assume that you named your project marble. So in this case you will have a Source folder that will contain a folder and 2 files.
Marble [Folder]
Marble.Target.cs
MarbleEditor.Target.cs

The 2 cs files contain the rules for creating the project that the unreal build system uses. These are explained in full here:
[Unreal build system](DOCLINK:Programming/UnrealBuildSystem)

Within the Marble folder you will see 3 folders and another cs file:
Private [Folder]
Public [Folder]
Resources [Folder]
Marble.build.cs

The CS file here is used to define what engine module dependencies the project has. It is also used to specify include paths for the project - in this case there are none of these. 
The 4 modules our project depends on are:
Core
This is as the name suggests the Core engine module. 
CoreUObject
Core UOjbect module - since our project is using classes that derive from UObject we need this
Engine
General engine core
InputCore
Input module. Since we need to interact in our project we need this module.

The Resources folder some system files for the app (Icon and info files. You can edit these as needed)

The Private folder contains all of the CPP files generated by our project and the Public folder contains the header files.
The files in these (assuming your project is named Marble) would be
Marble.cpp
This is the main project file and contains only a macro that deals with implementing the game module itself.

MarbleBall.cpp
This is the main code for the template. It is responsible for configuring the ball and handling the user interaction.

MarbleGameMode.cpp
This is the class that dictates the current 'mode' of the game. This will generally contain the 'rules of the game' and so forth. 


[/EXCERPT:StageOverview]

[EXCERPT:StagePawnSummary]

[VAR:StageTitle]
The Rolling Game Pawn - Summary
[/VAR]

![](MyPawn.png)

This class is the implementation of the pawn. In this case the pawn is a ball represented by a sphere mesh.

The class only contains 6 functions. Let's look at these now.

The MarbleBall class that has been created derives from the engines' Pawn class. For more details on this see 
[Pawn Overview](DOCLINK:Gameplay/Framework/Pawn)
Briefly this pawn class is a base class for all Actors that can be possessed by players or AI.
[/EXCERPT:StagePawnSummary]


[EXCERPT:StagePawnConstruct]

[VAR:StageTitle]
The Rolling Game Pawn - Construction
[/VAR]

The first function in the file is the constructor.
[Constructor](CODELINK:Private/[PROJECT]Ball.cpp,6,0)
The only parameter for the constructor is a FObjectInitializer type. This is a class that is used to finalize object creation once the real C++ constructor has been called. 
It is here in the constructor that we allocate the mesh and create the components we need for our rolling ball.

The first thing we do in the constructor is find the Mesh we wish to use for our ball. 
[First thing we do is find our mesh,](CODELINK:Private/[PROJECT]Ball.cpp,13,13)
The code creates a simple struct that will find pointer to the mesh we specified. In this case
[BallMesh](ASSETLINK:SELECT,BallMesh)
This is a helper that will attempt to find a Static Mesh within our application package. In the struct as you can see we pass the name of the mesh we wish to use.
We then create an instance of this struct. If the mesh exists we can then use this instance to access the pointer to our required mesh.

Next we create a Static Mesh component and give it a name
[Naming our mesh component](CODELINK:Private/[PROJECT]Ball.cpp,21,5)
Once we have done this we allocate the mesh we searched for using our constructor helper. 
[Allocate the mesh we found](CODELINK:Private/[PROJECT]Ball.cpp,22,5)
The next thing we do is allocate a collision profile to the body instance of our new ball component. 
[Allocate a collision profile](CODELINK:Private/[PROJECT]Ball.cpp,23,5)
The next few lines are simply setting so basic parameters that define how our ball will move as well as telling the component to simulate physics.
[Setup some component parameters](CODELINK:Private/[PROJECT]Ball.cpp,24,5)
Lastly we tell the component that we want to get notifications on right body collisions.
[Enable collision notifications](CODELINK:Private/[PROJECT]Ball.cpp,28,5)
Now that we have set our component up we set this as the ROOT 
[Set our component as the root](CODELINK:Private/[PROJECT]Ball.cpp,29,5)

The next thing we create for our marble is a SpringArm component. 
[Create a spring arm component](CODELINK:Private/[PROJECT]Ball.cpp,32,5)
This spring arm is attached to the ball, and we will eventually attach a camera to that. The spring arm class tries to keep its children at a fixed distance from the parent, but will also handle collisions, retracting and springing back as required.
Here the spring arm is acting as a sort of boom for the camera.  We create this and we attach it to our root component which is of course the Static Mesh that is our ball.
We then set some basic parameters to define the behaviour of this spring arm. Full details on the spring arm component are found here <LINK>. We give the arm a length, tell the arm not to rotate with the ball, an initial rotation etc. etc.
[Setup spring the arm component parameters](CODELINK:Private/[PROJECT]Ball.cpp,34,5)

Next we create a camera so we can see our ball. There is little to do here other than create the camera, attach it to spring arm and tell it not to rotate.
[Creating a camera component](CODELINK:Private/[PROJECT]Ball.cpp,42,5)

Finally we setup some specific parameters for our ball. 
RollTorque	- 	The amount of torque to apply when we interact and try to move the ball.
JumpImpulse	- 	The amount of impulse to apply when we want the ball to jump.
bCanJump 	- 	This is used to control the jumping of the ball - it is set when the ball jumps, and cleared when the ball hits something. If this is true, we prevent any further jumps; otherwise we could repeatedly press jump and keep having the jump impulse applied to our ball.
[Setup some default object parameters](CODELINK:Private/[PROJECT]Ball.cpp,47,5)

Next we will look at input.

[/EXCERPT:StagePawnConstruct]


[EXCERPT:StageSetupInput]

[VAR:StageTitle]
The Rolling Game Pawn - SetupPlayerInputComponent
[/VAR]

In this section we cover the setting up of the input handlers and their implementation.
For details on the input API please look here:
[Input Overview](DOCLINK:Gameplay/Input)

So first we need to setup the handlers.
[SetupPlayerInputComponent](CODELINK:Private/[PROJECT]Ball.cpp,53,0)
This is an overridden function. It is passed a UInputComponent pointer. We use this to bind our control handlers for our 3 controls.

[First we bind an Axis.](CODELINK:Private/[PROJECT]Ball.cpp,56,0)
We pass 3 parameters to this:
"MoveRight"
This is the name of the axis binding. This relates to input bindings that are defined in the editor. We shall cover how this is done later.
This 
is the pointer that points to our object
&AMarbleBall::MoveRight
This is the function we wish to have called to handle input from the MoveRight binding.

The next line is pretty much the same, except that it binds the "MoveForward" binding to the "MoveForward" function. 
The 2 functions we are passing here must of course match the delegate that is defined. For BindAxis this is a void function taking a single float. The float represents an axis value in the range -1 to 1

[The last binding here is an action.](CODELINK:Private/[PROJECT]Ball.cpp,59,0)
As you can see, this take 4 parameters.
The first is again the name of the binding.
The next is the action we wish to bind - in this case pressed. The final 2 parameters are much the same as they were for the axis binding the only difference being that the delegate for this takes no parameters. 
Jumping is just a simple key event

[/EXCERPT:StageSetupInput]

[EXCERPT:StageSetupMovement]

[VAR:StageTitle]
The Rolling Game Pawn - Movement functions
[/VAR]


There are 2 movement functions here. One for each axis.
[MoveRight](CODELINK:Private/[PROJECT]Ball.cpp,62,0)
This takes a float which will be in the range -1 to 1. This will also come in with ZERO as the parameter when the stick is unmoved.
The function calculates a torque vector on the X axis based on the RollTorque member variable and multiplies this by the amount of movement on the stick. It then passes this to the ball component as torque using the AddTorque function. When the ball component is updated it will updated the components torque and react accordingly.
[MoveForward](CODELINK:Private/[PROJECT]Ball.cpp,68,0)
This does exactly the same as MoveRight except it creates a torque vector for the Y axis.

The final function makes the ball jump.
[JumpFunction](CODELINK:Private/[PROJECT]Ball.cpp,74,0)
This checks that we are not already in a jump state, and if not we create an impulse vector on the Z axis using the JumpImpulse member and pass this to the ball component as an Impulse.
Finally we set the flag to say that we are now jumping.

[/EXCERPT:StageSetupMovement]

[EXCERPT:StageSetupImpact]
[VAR:StageTitle]
The Rolling Game Pawn - Impact
[/VAR]

[ReceiveHit](CODELINK:Private/[PROJECT]Ball.cpp,84,0)
This is the final function in the file. It is called when the object collides in the world. It takes 8 parameters. There is a detailed explanation for this function's parameters in the Actor API documentation. However we do not need to use any of these for the purposes of this template so we shall not go into them here.
So the first thing that we do is call up to the base class.
Finally we simply clear the flag that we set when pressed the jump button. We could of course do something far more elaborate on impact and determine just what it is we have hit before deeming the jump to have ended but to keep the templates clear we simply treat any impact is the end of the jump.

[/EXCERPT:StageSetupImpact]

	
[EXCERPT:StageInputBindings]

[VAR:StageTitle]
The Rolling Game Pawn - Input Bindings
[/VAR]

In the final section covering the pawn we shall explain how the input relates to the controller buttons and or keys. 
A more details explanation can be found in the documentation here:
[Input Overview](DOCLINK:Gameplay/Input)

The preferred method of setting up the control bindings is via the editors GUI. With the editor open click on the Edit Menu, and select Project Settings. Find the section in the panel on the left called INPUT and click it.
This opens the input page where you can configure input event names and such. The section we are interested in here is bindings.
![](Bindings.png)

The first section is for Action buttons
![](ActionMap.png)

These bind keys to generate simple events. If you pressed the button defined in the mapping an event will trigger.
If you click the arrow next to action mappings the section expands to reveal 2 bindings. If you then expand the Jump mapping you will see the binding. 
![](ActionMapExpanded.png)
So when you either press the spacebar or Gamepad button an event Jump will trigger. This will call the delegate function we bound in the 
SetupPlayerInputComponent function.

If you now click on the arrow next to axis mappings a list of mappings will appear. This contains the entries for MoveForward and MoveRight. If you then click on MoveForward you will see the 3 keys/buttons associated with that binding.
![](AxisMap.png)

So when either GamePadLeft X (which is the left stick on the controller), Left or Right is moved/pushed it will generate trigger the event resulting in the delegate being called.
There are some subtle differences in these - because one of them is a controller binding and the other 2 are key bindings. 
The controller binding has a scale of 1. This is fine, this will allow the stick to behave as we would expect. If we were to change this to -1 it would have the effect of flipping the axis. 
The next 2 bindings are keys - these do not have a range of -1 to 1 like an axis stick on a controller - they return 0-1 (as they are keyboard keys not analogue buttons as found on a game controller they will in-fact be 0 or 1). The scale on the binding for Left means that it will convert the 1 to -1 - thus behaving as if the stick were moved left.

[/EXCERPT:StageInputBindings]

[EXCERPT:StageGameMode]

[VAR:StageTitle]
The Rolling Game Mode
[/VAR]

This is a very simple, but important class. It is this class which specifies the default class to use when the game begins. So this is all the constructor does - it puts the MarbleBall static class instance into the DefaultPawnClass member which tells the game mode to use that when the game starts.

We would also use this class to control the game mode - control the rules and logic that sort of this. 

The final file that was generated that has the same name as that of the project generated (EG Marble.cpp) simply implements the game as a module and sets up various things relating to this - Module Name, Class etc. and is also used by the unreal build too. 
The header-file that accompanies this includes the main core header. 

[/EXCERPT:StageGameMode]

