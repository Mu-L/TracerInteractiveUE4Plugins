INTSourceChangelist:2574260
Availability:NoPublish
Title:回転の概要
Description:回転のテンプレートの概要
Crumbs:

[EXCERPT:StageMain]
[VAR:StageTitle]
回転テンプレート
[/VAR]

![](RollingScreen.png)

これは C++ を使用した回転ゲームのテンプレートです。非常に単純なもので、回転するボールとボールが回転するレベルで構成されます。 
レベル自体は、いくつかのプラットフォームとキューブを特徴とします。その一部はひっくり返り、一部はひっくり返りません。
このテンプレートでの実際の「作業」のほとんどは、エンジン内の物理によって処理されます。

キーボード上の W、A、S、D キーまたはアタッチされているコントローラの左スティックでレベル内を移動できます。スペースキーまたはコントローラの A ボタンを押してボールをジャンプさせることができます。

このテンプレートの主なクラスを以下に示します。
* MarbleBall - ゲームのポーン クラス、ボールそのものです。
* MarbleGameMode - ゲーム モード クラスです。 

この 2 つについて詳細に説明します。

[/EXCERPT:StageMain]

[EXCERPT:StageOverview]

[VAR:StageTitle]
回転ゲーム - 概要
[/VAR]

任意のテンプレートからプロジェクトを作成すると、アンリアル エンジンのエディタは、選択したフォルダ内にファイルを作成し、そのプロジェクト名を使用してファイルを作成します。生成されたソースコードは、プロジェクト用に選択したフォルダ内の「Source」という名前のフォルダに入れられます。このチュートリアルの目的上、プロジェクトに marble と名前を付けたことを前提とします。そのため、この場合、以下のように 1 つのフォルダと 2 つのファイルを含む「Source」フォルダがあることになります。
Marble [フォルダ]
Marble.Target.cs
MarbleEditor.Target.cs

2 つの cs ファイルには、アンリアル ビルド システムが使用するプロジェクトを作成するためのルールが含まれます。これについては、以下で詳しく説明しています。
[Unreal build system](DOCLINK:Programming/UnrealBuildSystem)

「Marble」 フォルダ内には、以下のように 3 つのフォルダともうひとつ cs ファイルがあります。
Private フォルダ
Public フォルダ
Resources フォルダ
Marble.build.cs

ここでの CS ファイルは、プロジェクトがどのようなエンジン モジュールの従属関係を持つかを定義するために使用されます。プロジェクトのインクルード パスを指定するためにも使用されます。このケースでは、何もありません。 
以下は、このプロジェクトが従属する 4 つのモジュールです。
Core、
名前が示すようにコアのエンジン モジュールです。 
CoreUObject、
コアの UOjbect モジュールです。プロジェクトで UObject から派生したクラスを使用しているため、これが必要です。
Engine、
一般的なエンジン コアです。
InputCore、
Input モジュールです。プロジェクト内でインタラクションする必要があるため、このモジュールが必要です。

Resources フォルダ、アプリケーション用のいくつかのシステム ファイル (アイコンと info ファイル。必要に応じて編集可能)。

Private フォルダには、プロジェクトによって生成されたすべての CPP ファイルが含まれ、Public フォルダにはヘッダファイルが含まれます。
これらの中のファイルは (プロジェクト名が Marble であることを前提に)
Marble.cpp になります。
これはメイン プロジェクト ファイルで、ゲーム モジュール自体の実装に関するマクロだけを含みます。

MarbleBall.cpp、
これはテンプレートの主要コードです。ボールを設定し、ユーザーのインタラクションの処理を扱います。

MarbleGameMode.cpp、
現在のゲームの「モード」を規定するクラスです。一般的に「ゲームのルール」などを含みます。 


[/EXCERPT:StageOverview]

[EXCERPT:StagePawnSummary]

[VAR:StageTitle]
回転ゲームのポーン - Summary
[/VAR]

![](MyPawn.png)

このクラスは、ポーンの実装です。この場合、ポーンは球体メッシュで表されるボールです。

このクラスには関数が 6 つだけ含まれます。これらを見てみましょう。

エンジンの Pawn クラスから派生したものから作成された MarbleBall クラス。詳細は以下を参照してください。 
[ポーンの概要](DOCLINK:Gameplay/Framework/Pawn)
簡単にいうと、このポーン クラスはプレイヤーまたは AI が所有可能なすべてのアクタに対する基底クラスです。
[/EXCERPT:StagePawnSummary]


[EXCERPT:StagePawnConstruct]

[VAR:StageTitle]
回転ゲームのポーン - Construction
[/VAR]

ファイルにある最初の関数は、コンストラクタです。
[Constructor](CODELINK:Private/[PROJECT]Ball.cpp,6,0)
コンストラクタの唯一のパラメータは、FObjectInitializer 型です。これは実際の C++ コンストラクタが呼び出されると、オブジェクト作成をファイナライズするために使用するクラスです。 
このコンストラクタでメッシュを割り当て、回転ボールに必要なコンポーネントを作成します。

コンストラクタで最初にすることは、ボールに使用したいメッシュを見つけることです。 
[最初にするのはメッシュを見つけることです。](CODELINK:Private/[PROJECT]Ball.cpp,13,13)
このコードは指定したメッシュを見つける単純な構造体を作成します。この場合、
[BallMesh](ASSETLINK:SELECT,BallMesh)
アプリケーション パッケージ内でスタティックメッシュを見つけようとするヘルパーです。構造体内で、ご覧のように使用したいメッシュの名前を渡します。
次にこの構造体のインスタンスを作成します。メッシュが存在する場合、このインスタンスを使用して必要なメッシュのポインタにアクセスできます。

次に、スタティックメッシュのコンポーネントを作成し、名前を付けます。
[メッシュコンポーネントに名前を付ける](CODELINK:Private/[PROJECT]Ball.cpp,21,5)
これを行ったら、コンストラクタ ヘルパーを使用して検索したメッシュを割り当てます。 
[見つかったメッシュを割り当てる](CODELINK:Private/[PROJECT]Ball.cpp,22,5)
次に行うのは、新しいボール コンポーネントのボディ インスタンスにコリジョン プロファイルを割り当てることです。 
[コリジョン プロファイルを割り当てる](CODELINK:Private/[PROJECT]Ball.cpp,23,5)
次の数行は単なる設定であり、ボールがどのように動くかを定義する、またコンポーネントに物理をシミュレーションするように指示する基本パラメータです。
[コンポーネントのパラメータをセットアップする](CODELINK:Private/[PROJECT]Ball.cpp,24,5)
最後に、右のボディ コリジョンで通知が必要であることをコンポーネントに指示します。
[コリジョン通知を有効にする](CODELINK:Private/[PROJECT]Ball.cpp,28,5)
これでコンポーネントをセットアップが終わったので、これを ROOT として設定します。 
[コンポーネントをルートとして設定する](CODELINK:Private/[PROJECT]Ball.cpp,29,5)

次に、marble に対して作成するのは、SpringArm コンポーネントです。 
[SpringArm コンポーネントを作成する](CODELINK:Private/[PROJECT]Ball.cpp,32,5)
このスプリングアームは、ボールにアタッチされ、最終的にそれにカメラをアタッチします。この spring arm クラスは、子を親から固定距離に保とうとしますが、コリジョンも処理し、必要に応じて伸縮します。
ここではスプリングアームは、カメラのブームのような働きをします。スプリングアームを作成し、ルート コンポーネントにアタッチします。ルートコンポーネントはもちろんスタティックメッシュであり、ボールです。
次にいくつかの基本パラメータを設定し、スプリングアームの挙動を定義します。スプリングアーム コンポーネントの詳細は、<LINK> を参照してください。アームの長さを指定し、ボールと共にアームが回転しないように指示し、最初の回転などを指定します。
[スプリングアーム コンポーネントのパラメータを設定する](CODELINK:Private/[PROJECT]Ball.cpp,34,5)

次に、ボールを見ることができるようにカメラを作成します。ここでは、カメラを作成し、それをスプリングアームにアタッチし、回転しないように指示する以外は他にやることはあまりありません。
[カメラ コンポーネントを作成する](CODELINK:Private/[PROJECT]Ball.cpp,42,5)

最後に、ボールに対して、いくつかの特定のパラメータをセットアップします。 
RollTorque	- 	ボールとインタラクションし、動かそうとする場合に適用するトルク量です。
JumpImpulse	- 	ボールをジャンプさせたい場合に適用する推進力です。
bCanJump 	- 	ボールのジャンプを制御するために使用します。ボールがジャンプするときに設定し、ボールが何かにぶつかるとクリアされます。これが、true の場合、以後ジャンプをさせないようにします。そうでなければ繰り返しジャンプを押して、ボールに適用されたジャンプの推進力を保つようにします。
[Setup some default object parameters](CODELINK:Private/[PROJECT]Ball.cpp,47,5)

次に入力について説明します。

[/EXCERPT:StagePawnConstruct]


[EXCERPT:StageSetupInput]

[VAR:StageTitle]
回転ゲームのポーン - SetupPlayerInputComponent
[/VAR]

このセクションでは、入力ハンドラのセットアップとその実装について説明します。
入力 API の詳細については、以下を参照してください。
[入力の概要](DOCLINK:Gameplay/Input)

まず、入力ハンドラをセットアップする必要があります。
[プレイヤーの入力コンポーネントをセットアップする](CODELINK:Private/[PROJECT]Ball.cpp,53,0)
これはオーバーライドされる関数です。UInputComponent ポインタを渡されます。これを使用して、コントロール ハンドラを 3 つのコントロールにバインディングします。

[最初に軸をバインド](CODELINK:Private/[PROJECT]Ball.cpp,56,0)
これを行うには、3 つのパラメータを渡します。
"MoveRight"
これはバインドする軸の名前です。これはエディタで定義される入力のバインディングに関連しています。どのように行うかについては後で説明します。
つまり、 
&AMarbleBall::MoveRight オブジェクトをポイントする
ポインタです。
MoveRight バインディングからの入力を処理するために呼び出されるようにしたい関数です。

次の行はほとんど同じですが、"MoveForward" のバインディングを"MoveForward" 関数にバインドするという点だけが異なります。 
ここで渡している 2 つの関数は、定義されているデリゲートと一致しなければなりません。BindAxis では、これは単精度浮動小数点値をとる void 関数です。単精度浮動小数点値は、-1 から 1 までの範囲で軸値を表します。

[ここでの最後のバインディングはアクション](CODELINK:Private/[PROJECT]Ball.cpp,59,0)
ご覧になってわかるように、これは 4 つのパラメータを取ります。
1 つめは、またバインディングの名前です。
2 つめはバインドしたいアクションです。この場合、押すことです。最後の 2 つのパラメータは、軸をバインドするためのものであるため、ほとんど同じです。唯一の違いは、これに対するデリゲートはパラメータを取らないことです。 
ジャンプは単純なキー イベントにすぎません。

[/EXCERPT:StageSetupInput]

[EXCERPT:StageSetupMovement]

[VAR:StageTitle]
回転ゲームのポーン - Movement 関数
[/VAR]


2 つの movement 関数があります。各軸に 1 つずつあります。
[MoveRight](CODELINK:Private/[PROJECT]Ball.cpp,62,0)
これは、-1 から 1 までの範囲で浮動小数点値を取ります。スティックが動かされない場合、パラメータとしてゼロにもなります。
この関数は、RollTorque メンバ変数に基づき、X 軸上のトルクベクトルを計算し、これにスティックの移動量を掛け合わせます。次に、これをAddTorque 関数を使用してボールのコンポーネントにトルクとして渡します。ボールのコンポーネントが更新されると、それに応じてコンポーネントのトルクと反応も更新されます。
[MoveForward](CODELINK:Private/[PROJECT]Ball.cpp,68,0)
これは Y 軸のトルクベクトルを作るという点以外は、MoveRight と全く同じです。

最後の関数はボールをジャンプさせます。
[JumpFunction](CODELINK:Private/[PROJECT]Ball.cpp,74,0)
これは、まだジャンプ状態でないことをチェックし、ジャンプ状態でなければJumpImpulse メンバを使用して、Z 軸上に推進力ベクトルを作成し、これをボール コンポーネントに推進力 (Impulse) として渡します。
最後に、ジャンプ中であることを示すフラグを設定します。

[/EXCERPT:StageSetupMovement]

[EXCERPT:StageSetupImpact]
[VAR:StageTitle]
回転ゲームのポーン - Impact
[/VAR]

[ReceiveHit](CODELINK:Private/[PROJECT]Ball.cpp,84,0)
これは、ファイルにある最後の関数です。ワールド内でオブジェクトが衝突するときに呼び出されます。8 つのパラメータを取ります。Actor API のドキュメントに、この関数パラメータの詳細な説明があります。しかし、このテンプレートの目的上、これらを使用する必要はありません。そのため、ここでは説明しません。
従って最初にやることは、基底クラスを呼び出すことです。
最後に、ジャンプボタンを押したときに設定したフラグをクリアするだけです。もちろん、衝撃時にはるかに複雑なことを行い、ジャンプを終わらせるとみなす前に、ぶつかった物が何であるか判断することができますが、テンプレートをクリアに維持するためには、衝撃は何でもジャンプの最後にくるものとして処理します。

[/EXCERPT:StageSetupImpact]

	[EXCERPT:StageInputBindings]


[VAR:StageTitle]
回転ゲームのポーン - 入力バインディング
[/VAR]

ポーンについての最終セクションでは、入力がコントローラのボタンやキーとどのような関連があるかについて説明します。 
詳細な情報は、以下のドキュメントに掲載されています。
[入力の概要](DOCLINK:Gameplay/Input)

コントロールのバインディングをセットアップするには、エディタの GUI を使用するのが適しています。エディタが開いた状態で、[編集] メニューをクリックし、[Project Settings] を選択します。パネルの左側にある INPUT というセクションを見つけて、クリックします。
入力イベント名などを設定する入力ページが開きます。ここで使用するセクションは、[bindings] です。
![](Bindings.png)

最初のセクションは、Action ボタンのためのものです。
![](ActionMap.png)

これらはキーをバインドし、単純なイベントを生成します。マッピングで定義されているボタンを押すとイベントがトリガーします。
アクション マッピングの隣にある矢印をクリックすると、このセクションが展開し、2 つのバインドが現れます。次に Jump のマッピングを展開すると、そのバインディングが表示されます。 
![](ActionMapExpanded.png)
スペースバーまたは Gamepad ボタンのいずれかを押すと、イベント Jump がトリガーします。これで、SetupPlayerInputComponent 関数でバインドした 
デリゲート関数が呼び出されます。

軸マッピングの隣にある矢印をクリックすると、マッピングのリストが表示されます。これには、MoveForward と MoveRight のエントリが含まれます。次に、MoveForward をクリックすると、そのバインディングに関連づけられている 3 つのキー/ボタンが表示されます。
![](AxisMap.png)

GamePadLeft X (コントローラの左スティック)、Left または Rightが動かされる/押されると、呼び出されているデリゲートの結果であるイベント、トリガーが生成されます。
これらのうち 1 つはコントローラのバインディングであり、他の 2 つはキーのバインディングであるため、微妙な違いがあります。 
コントローラのバインディングは 1 のスケールを持ちます。これは良いことです。スティックは予測したとおりの挙動を示します。これを -1 に変更すると、軸を反対方向にする効果があります。 
次の 2 つのバインディングはキーです。これらは、コントローラの軸スティックのように -1 から 1 までの範囲を持ちません。0-1 を戻します (ゲーム コントローラにあるようなアナログボタン (実際には 0 または 1) ではなく、キーボードのキーだからです)。Left をバインディングするスケールは、1 から -1 に変換することを意味します。従って、スティックが左に動いたような挙動を示します。

[/EXCERPT:StageInputBindings]

[EXCERPT:StageGameMode]

[VAR:StageTitle]
回転ゲーム Mode
[/VAR]

これは非常にシンプルですが重要なクラスです。これが、ゲーム開始時に使用するデフォルトクラスを指定するクラスです。従って、このコンストラクタが行うことは以下のとおりです。MarbleBall の静的クラス インスタンスを、DefaultPawnClass メンバに入れて、メンバがゲーム モードに対してゲーム開始時にこれを使用するように指示します。

このクラスを使用して、ルールやロジックなどを制御するゲームモードの制御も行います。 

生成された最後のファイル、すなわち生成されたプロジェクトと同じ名前を持つファイル (EG Marble.cpp) は、ゲームを単にモジュールとして実装し、関連する様々なもの、モジュール名、クラスなどをセットアップし、アンリアルビルドでも使用されます。 
これに付随するヘッダーファイルには、メインのコア ヘッダーが含まれます。 

[/EXCERPT:StageGameMode]

