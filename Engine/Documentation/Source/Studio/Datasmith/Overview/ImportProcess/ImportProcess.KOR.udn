INTSourceChangelist:6548867
Availability: Public
Title: 데이터스미스 임포트 프로세스에 대하여
Description: 데이터스미스로 언리얼 엔진에 씬을 임포트하는 방식의 구체적인 이슈 관련 자세한 내용, 그렇게 임포트한 애셋을 언리얼에서 작업하는 방법을 다룹니다.
Type: overview
Version: 4.22
Parent: Studio/Datasmith/Overview
Tags: Datasmith
Tags: Guides
Tags: importing
topic-image: datasmith-about-import-topic.png
Related: Engine/Content/Types/StaticMeshes/HowTo/SettingCollision
Related: Engine/Rendering/Materials/MaterialInstances/Editor
Related: Engine/Rendering/Materials/MaterialInstances
Related: Engine/Sequencer
Related: Engine/Content/Types/StaticMeshes/AutoGeneratedLightmaps
Related: Engine/Rendering/LightingAndShadows/Lightmass/Basics
Related: Studio/Datasmith/Overview/UsingDatasmithMetadata
Related: Engine/Editor/ScriptingAndAutomation/HowTos/SettingUpCollisionProperties
Related: Studio/Datasmith/HowTo/ModifyStaticMeshGeometry
Related: Engine/Content/Types/StaticMeshes/HowTo/UVChannels
Order: 0


[TOC]

여기서는 데이터스미스가 씬을 변환하는 도중 발생하는 이슈 관련 자세한 내용을 다룹니다. 그 이슈를 이해하면 데이터스미스가 생성한 결과를 이해하고 언리얼 에디터에서도 콘텐츠 작업을 쉽게 할 수 있습니다.

## 단위와 척도

언리얼 엔진에서 모든 거리 측정 단위는 항상 센티미터입니다. 하지만 다른 3D 디자인 애플리케이션은 대개 측정 단위를 선택할 수 있습니다. 소스 애플리케이션에서 다른 측정 단위를 사용하면, 데이터스미스가 씬의 스케일을 자동 처리하여 언리얼 엔진에서도 실제 크기와 똑같은 크기로 올바른 3D 위치에 나타나도록 합니다. 소스 애플리케이션에서 작업하는 방식은 아무것도 바꿀 필요 없습니다.  

예를 들어 소스 애플리케이션에서 인치를 측정 단위로 사용하는 경우 원래 씬에서 길이가 10 인치인 오브젝트는 언리얼 엔진에서 길이가 25.4 월드 유닛이 됩니다.

[REGION:imagetable]

|||
| --- | --- |
| ![](datasmith-units-1.png) | ![](datasmith-units-2.png) |
| 소스 | 임포트 이후 |

[/REGION]

## 이름과 라벨

데이터스미스는 소스 애플리케이션의 지오메트리 관련 이름 정보를 감지한 뒤, 그 정보를 최대한 재사용하여 애셋과 액터를 만듭니다. 정확한 프로세스는 애플리케이션마다 파일 포맷마다 약간씩 다르고 언리얼 엔진에서의 결과도 소스 애플리케이션과 살짝 다를 수 있지만, 최종 목적은 콘텐츠를 임포트한 후에도 찾아 관리할 수 있도록 하는 것입니다.

스태틱 메시의 경우, 콘텐츠 브라우저의 애셋 이름과, 디스크의 애셋 파일명과, 레벨의 액터 이름이 다른 경우가 종종 있습니다.

*   **콘텐츠 브라우저 라벨** - 데이터스미스는 소스 파일에서 찾은 명명 규칙 정보가 있으면 그에 따라 콘텐츠 브라우저의 스태틱 메시 애셋 각각에 대한 라벨을 생성합니다.  
    지원하는 애플리케이션과 파일 포맷이 여럿이라 이름이 같은 오브젝트도 여럿 있을 수 있습니다. 씬에 그러한 상황이 발생하면, 콘텐츠 브라우저에 라벨이 같은 애셋이 다수 생길 수 있습니다.

*   **파일명** - 하지만 디스크의 각 애셋 이름은 고유해야 합니다. 그래서 데이터스미스는 소스 애플리케이션에서 추출한 고유 식별자로 각 애셋 파일 이름을 붙입니다.

*   **액터 이름** - 데이터스미스가 레벨에 액터를 배치할 때마다 소스 파일에 그에 해당하는 오브젝트가 있으면 똑같은 이름을 붙입니다.  
    고유한 이름을 찾을 수 없으면, 콘텐츠 브라우저에서 같은 라벨을 재사용하여 액터 이름을 붙입니다. 레벨에 그 이름의 액터가 이미 존재하면, 데이터스미스는 접미사 숫자를 증가시켜 고유한 액터 이름으로 만듭니다.

예를 들어 아래 이미지에서 소스 씬의 이름 그대로 언리얼로 가져온 것이 보이며, 다수의 오브젝트가 이름이 같으면 예외입니다.

| 소스 파일의 계층 구조 | 언리얼의 계층 구조 |
|---|---|
| [INCLUDE:#sourcefilehierarchy] | [INCLUDE:#unrealhierarchy] |

<!--
[EXCERPT:sourcefilehierarchy]
[REGION:lightbox]
[![](datasmith-naming-before.png)](datasmith-naming-before.png "Hierarchy in source file ")
[/REGION]
[/EXCERPT:sourcefilehierarchy]

[EXCERPT:unrealhierarchy]
[REGION:lightbox]
[![](datasmith-naming-after.png)](datasmith-naming-after.png " Hierarchy in Unreal")
[/REGION]
[/EXCERPT:unrealhierarchy]
-->


[REGION:note]
참고로 콘텐츠 브라우저의 스태틱 메시 애셋 *라벨* 과 데이터스미스가 디스크 상의 그 애셋에 대해 생성하는 파일 *이름* 은 차이가 있습니다. 대부분의 경우 에디터에서 작업할 때는 괜찮습니다. 하지만 블루프린트나 Python 을 사용해서 애셋 또는 데이터스미스 씬 작업을 할 때는, 그 차이를 알아야 할 수 있습니다.
[/REGION]

## 트라이앵글이 향하는 방향

런타임에 최상의 퍼포먼스를 얻기 위해 언리얼 엔진은 보이지 않을 것으로 예상되는 트라이앵글을 컬링합니다. 그러면 그 트라이앵글 렌더링에 드는 GPU 사이클 소모가 방지됩니다. 특히 엔진은 모든 오브젝트에 두께가 있다 가정합니다. 카메라를 보지 않는 트라이앵글은 그 오브젝트의 뒷면이라 가정하여 오브젝트 정면 뷰에서는 숨깁니다. 이를 *back-face culling* (뒷면 컬링)이라 하며, 3D 렌더링에 광범위하게 사용되는 최적화 기법입니다.

하지만 표면을 위와 같이 앞뒤 구분하지 않고 표면을 어느 쪽에서 보든 상관없이 렌더링하는 디자인 애플리케이션도 있습니다. 디자인 툴에서 작업할 때는, 어떤 표면이 보는 방향을 알지 못할 수 있습니다. 그러면 표면의 노멀(법선, 표면과 수직 방향)이 안쪽, 즉 표면을 보는 방향 반대쪽을 향할 수 있습니다. 또는 두께가 전혀 없는 평면형 단일 벽 지오메트리가 만들어질 수 있습니다.

그렇게 되면 언리얼 엔진에 씬을 임포트한 후 특정 각도에서 봤을 때 일부분이 보이지 않게 될 수 있습니다. 심지어 모델 그 부분이 임포트 안된 것으로 보일 수도 있습니다. 하지만 단지 표면 노멀이 씬 뷰에 사용하는 카메라 반대 방향을 향하기 때문일 수 있습니다. 그런 경우 모델을 회전해 보면 표면이 갑자기 나타납니다.

예를 들어 다음 씬( 왼쪽)에서 지오메트리를 제대로 임포트했음에도 천장과 파이프 끝이 누락된 것처럼 보입니다. 머티리얼의 Two Sided (양면) 옵션을 켜면 표면이 나타납니다 (자세한 내용은 아래 참고).

[OBJECT:ComparisonSlider]
[PARAM:before]
![단면](datasmith-two-sided-off.png) 
[/PARAM]
[PARAM:after]
![양면](datasmith-two-sided-on.png) 
[/PARAM]
[/OBJECT]

이러한 상황에 대한 가장 좋은 해법은 소스 애플리케이션에서 처리하는 것입니다. 다음 제안 사항을 염두에 두세요.  

*   모든 방향에서 보이는 오브젝트는 전부 모델링할 때 두께를 주고, 노멀이 바깥쪽을 향하도록 합니다.

*   한쪽 방향에서만 보이는 것으로 알고 있는 오브젝트의 메시가 누락된 경우, 소스 애플리케이션에서 표면 노멀을 뒤집고(flip) 씬을 다시 임포트하여 고칩니다. 이렇게 하면 표면은 단면으로 유지하고 표면이 향하는 방향만 뒤집어 언리얼 엔진에서 의도한 방향에서 봤을 때 올바르게 보입니다.

하지만 소스 씬으로 돌아가지 않고 언리얼 에디터에서 문제를 고치기 위해 다음과 같은 옵션을 고려할 수도 있습니다.

*   스태틱 메시 에디터에서 트라이앵글 방향을 뒤집어 반대 방향을 보도록 하면 됩니다. [](Studio/Datasmith/HowTo/ModifyStaticMeshGeometry) 문서를 참고하세요.  
    하지만 그 트라이앵글이 반대쪽에서도 보인다면, 같은 문제가 여전히 남아있습니다. 즉 천장처럼 안에서만 보이는 것에는 좋은 해법이지만, 양쪽에서 보이는 내벽에는 좋지 않습니다.  
    유의할 점은 소스 씬에서 이 지오메트리 조각을 수정하고 데이터스미스 씬 애셋을 리임포트하면, 스태틱 메시 에디터에서 한 변경 작업은 잃게 됩니다. 즉 다른 이유로 돌아가서 지오메트리를 수정해야 한다면, SketchUp 에서 면의 방향도 동시에 수정해야 합니다.

*   머티리얼 에디터에서 머티리얼을 양면으로 만들면 됩니다. 그러면 그 표면은 어느 쪽에서 봐도 엔진이 렌더합니다. 얼핏 들었을 때 좋은 해법같지만, **스태틱** 또는 **스테이셔너리** 라이팅에서 시각적인 부작용이 생기는 경향이 있습니다. 표면의 양쪽 면이 라이트맵 텍스처에 똑같은 공간을 사용하기 때문입니다.  
    머티리얼이 머티리얼 인스턴스인 경우, 머티리얼 에디터에서 **디테일 패널** 의 **General > Material Property Overrides > Two Sided** 부분을 확인합니다.  
    ![Two Sided Material Property Override](material-instance-two-sided.png "Two Sided Material Property Override")  
    그 외의 경우, 머티리얼 에디터의 **디테일** 패널에서 **Material > Two Sided** 부분을 확인합니다.  
    ![Two Sided Material Property](material-details-two-sided.png "Two Sided Material Property")

*   표면 자체의 가시성 관련 문제가 아니라 빛이 오브젝트를 통과해 나오는 것만 문제인 경우, 즉 천장이 위쪽의 디렉셔널 라이트의 빛을 제대로 차단하지 못하는 경우, 스태틱 메시 액터가 양쪽면에서 그림자를 드리우도록 설정하면 됩니다.  
    **디테일** 패널에서 **Lighting > Shadow Two Sided** 세팅을 확인하세요.  
    [REGION:lightbox]
    [![Shadow Two Sided](staticmeshactor-shadowtwosided.png "Shadow Two Sided")  
    ](staticmeshactor-shadowtwosided.png)*이미지를 클릭하면 원본을 확인합니다.*
    [/REGION]
    

## 라이트맵 UV

언리얼 엔진은 씬의 라이팅 방법을 여러가지 제공합니다. 런타임 퍼포먼스가 가장 뛰어나면서 보통 간접광이 퍼지는 모습을 가장 부드럽고 현실적으로 표현하는 방법은 *baked* (구운) 라이팅입니다. 언리얼 엔진에서 이 방법을 사용하려면, 씬에 있는 라이트의 **모빌리티** 세팅을 **스태틱** 또는 **스테이셔너리** 로 설정한 뒤, 언리얼 엔진의 [Lightmass](Engine/Rendering/LightingAndShadows/Lightmass) (라이트매스)라는 툴을 사용하여 씬의 라이팅을 빌드하면 됩니다. 씬의 스태틱 및 스테이셔너리 라이트에서 나온 빛이 각 오브젝트에 닿는 것을 계산하여 *lightmap* (라이트맵)이라는 특별한 종류의 텍스처에 저장합니다. 런타임에 각 오브젝트의 라이트맵 텍스처에 있는 그 라이팅 정보를 오브젝트의 표면에 적용합니다.

이 시스템이 작동하려면 스태틱 메시의 모든 버텍스를 그 라이트맵 텍스처의 2D 곤간 고유 좌표에 매핑해야 합니다. 이 매핑을 UV 세트 또는 UV 채널이라 합니다. 또한 이 2D 좌표 공간을 배치할 때 메시의 트라이앵글이 2D 텍스처 공간에 서로 겹치지 않도록 해야 합니다. 메시의 두 트라이앵글을 2D 텍스처 같은 공간에 매핑하면, 라이트매스는 그 두 트라이앵글 각각에 대한 빛과 그림자 고유 패턴을 저장할 수 없습니다. 그러면 런타임에 이상한 라이팅 부작용이 생깁니다.

모든 스태틱 메시가 스태틱 라이팅을 제대로 받을 수 있도록 준비하기 위해, 데이터스미스는 임포트하는 스태틱 메시마다 언리얼 에디터의 자동 UV 언래핑 시스템을 자동으로 호출합니다. 이 프로세스는 각 스태틱 메시에 두 개의 새로운 UV 세트를 추가합니다.

*   하나는 메시를 이루는 트라이앵글을 2D 공간에 평면에 단순히 펼쳐 표현하는 것입니다. 메시를 다수의 작은 "island" (아일랜드)로 나누며, 각 아일랜드는 메시 표면의 연결 섹션을 나타냅니다.

*   그런 다음 첫 라이트맵의 아일랜드를 재배치하고 크기를 조절해서 겹침이 없는 레이아웃으로 만들어 아일랜드 주변 낭비 공간을 최소화합니다. 그러면 레벨의 라이팅을 빌드할 때 오브젝트의 라이트맵에 사용되는 최종 레아이웃이 됩니다.

그런 다음 데이터스미스는 라이트맵 저장 및 적용을 위해 2차 생성 UV 를 사용하도록 스태틱 메시 애셋을 설정합니다.

[REGION:note]
3ds Max 를 사용하고 라이트맵에 사용하려는 UV 채널을 이미 설정해 둔 경우, [](Studio/Datasmith/SoftwareInteropGuides/3dsMax) 문서를 참고하세요.
[/REGION]

## 콜리전 및 피직스

기본적으로 데이터스미스는 생성할 스태틱 메시 애셋에 대해 피직스 설정을 하지 않습니다. 임포트 후 언리얼 에디터에서 스태틱 메시에 피직스 설정을 할 수 있는데, 자세한 내용은 [](Engine/Content/Types/StaticMeshes/HowTo/SettingCollision), [](Engine/Editor/ScriptingAndAutomation/HowTos/SettingUpCollisionProperties) 문서를 참고하세요.

3ds Max 로 작업하는 경우 3ds Max 로 커스텀 지오메트리를 모델링하고 데이터스미스 임포터가 생성할 스태틱 메시 애셋에 그 지오메트리를 자동 할당하도록 할 수 있습니다. 자세한 내용은 [](Studio/Datasmith/SoftwareInteropGuides/3dsMax) 문서를 참고하세요.

## 머티리얼

[](Studio/Datasmith/Overview) 문서의 설명대로 데이터스미스 임포트 프로세스는 임포트한 씬에서 인식한 지오메트리 표면 프로퍼티의 여러 세트 각각을 표현하기 위해 언리얼 엔진 프로젝트에 머티리얼 애셋을 새로 만듭니다. 씬 변환의 목표는 표면 프로퍼티를 최상의 퀄리티로 넘기는 것이지만, 그래도 임포트 후 머티리얼 미세 조정은 해야 합니다. 머티리얼 애셋을 더블클릭하여 편집할 수 있습니다.

**Materials** 폴더에서 찾을 수 있는 머티리얼 대부분은 머티리얼 인스턴스입니다. 즉 머티리얼 인스턴스를 편집하면, 그 부모 또는 "마스터" 머티리얼에 의해 결정되는 프리셋 세팅 목록이 보인다는 뜻입니다. 예를 들어, 다음 이미지는 SketchUp 에서 가져온 모델에 대해 만들어진 머티리얼 인스턴스를 보여줍니다.

![Material Instance created by Datasmith](datasmith-material-instance.png)

머티리얼 인스턴스가 무엇이고 그 작업 방법에 대한 자세한 내용은 [](Engine/Rendering/Materials/MaterialInstances), [](Engine/Rendering/Materials/MaterialInstances/Editor) 문서를 참고하세요.

각 머티리얼 인스턴스에는 부모 머티리얼도 있습니다. 즉 블루프린트와 비슷한 노드 그래프가 들어있는 다른 종류의 머티리얼 애셋입니다. 이 그래프는 언리얼 엔진에서 부모 머티리얼 또는 그 머티리얼 인스턴스가 적용된 표면을 렌더링해야 할 때 GPU 에서 수행되는 실제 작업을 결정합니다. 부모 머티리얼의 그래프가 구성되는 방식은 머티리얼 인스턴스에 노출된 설정과 해당 설정이 사용되는 방법도 제어합니다.

데이터스미스는 소스 애플리케이션에 따라 머티리얼 인스턴스의 서로 다른 부모 머티리얼을 적용할 때 다음과 같은 원리를 적용합니다.

*  대부분의 경우 데이머스미스는 데이터스미스 플러그인의 일부로 포함 된 기존 부모 머티리얼을 각 머티리얼에 할당합니다. 일반적으로 이 부모 머티리얼에 의해 노출된 프리셋 세팅은 소스 애플리케이션에서 사용할 수있는 머티리얼 제작 세팅과 매우 유사합니다.  
    데이터스미스가 프로젝트에서 생성하는 각 머티리얼 인스턴스에서 이렇게 노출된 세팅을 자유롭게 편집할 수 있습니다. 데이터스미스가 제공하는 서로 다른 부모 머티리얼은 여러가지 프로퍼티 세트를 제공합니다.
    *   **Datasmith_Color** - 이 부모 머티리얼은 단색 및 텍스처 입힌 표면에, 주로 CAD 모델을 임포트할 때 사용됩니다. [데이터스미스 컬러 머티리얼](#데이터스미스컬러머티리얼) 부분을 참고하세요.
    
    *   **SketchUpMaster** - 이 부모 머티리얼은 SketchUp 에서 임포트된 모든 표면에 사용됩니다. [](Studio/Datasmith/SoftwareInteropGuides/SketchUp) 문서를 참고하세요.
    
    *   **RevitMaster** - 이 부모 머티리얼은 Revit 에서 임포트된 모든 표면에 사용됩니다. [](Studio/Datasmith/SoftwareInteropGuides/Revit) 문서를 참고하세요.
    
    *   **Datasmith_Material** - 이 부모 머티리얼은 Rhino 에서 임포트한 텍스처 입힌 표면에 사용됩니다. [](Studio/Datasmith/SoftwareInteropGuides/Rhino) 문서를 참고하세요.

*   3ds Max 에서 콘텐츠를 임포트하는 경우, 데이터스미스가 프로젝트의 **Materials/Master** 폴더에 새 머티리얼을 임포트한다는 것도 알 수 있습니다. 3ds Max 는 다른 대부분의 소스 애플리케이션보다 훨씬 풍부한 머티리얼 저작 워크플로를 제공하며, 언리얼 엔진 머티리얼 그래프와 개념적으로 유사합니다. 따라서 데이터스미스는 일반적으로 3ds Max 에 있는 커스텀 머티리얼과 매우 비슷한 마스터 머티리얼을 새로 만들 수 있으며, 프리셋 세팅이 노출된 그래프와 리스트를 가진 프리셋 부모 머티리얼을 재사용하지 않아도 됩니다.  
    이 경우에도 데이터스미스는 일반적으로 계속해서 그 커스텀 부모 머티리얼에 대해 머티리얼 인스턴스를 생성합니다. 그런 다음 그 머티리얼 인스턴스를 자신의 스태틱 메시 애셋과 씬의 스태틱 메시 액터에 적용합니다. 대부분의 경우, 머티리얼 인스턴스의 프로퍼티만 수정해도 렌더링된 결과물을 제어하기에 충분합니다.  
    3ds Max 머티리얼 일부 유형의 경, 데이터스미스는 머티리얼 인스턴스 생성을 생략할 수 있습니다. 이 경우, 단순히 새 부모 머티리얼을 스태틱 메시 애셋과 액터에 할당합니다.

머티리얼 인스턴스가 프로퍼티에 따라 표면의 셰이딩 방법을 결정할 때 사용하는 실제 머티리얼 그래프를 변경하려면, 부모 머티리얼을 복제하고 그 복제본의 프로퍼티를 수정해야 합니다. 이 프로세스 관련 자세한 내용은 [](Studio/Datasmith/HowTo/ModifyDSParentMaterial) 문서를 참고하세요.  

또다른 옵션으로, 데이터스미스가 만든 머티리얼 작업을 하는 대신, 항상 그 머티리얼을 다른 물리 기반 머티리얼로 완전 대체하는 것입니다. 언리얼 에디터에서, 아니면 타사 프로그램으로 직접 만든 머티리얼일 수 있습니다.

[REGION:tip]
언리얼 스튜디오에 가입하면 Allegorithmic 의 물리 기반 섭스턴스 머티리얼 100 종 라이브러리에 액세스할 수 있습니다. 시작은 [여기를(영문)](https://www.allegorithmic.com/substance-ue4) 참고하세요.
[/REGION]

### 데이터스미스 컬러 머티리얼

많은 CAD 애플리케이션은 지오메트리 셰이더에 단순한 표면 색을 사용합니다. 데이터스미스가 이런 표면을 언리얼로 가져올 때 보통 **Datasmith_Color** 머티리얼의 인스턴스로 가져옵니다.

![Datasmith Color Material Instance](datasmith-color-material.png "Datasmith Color Material Instance")

*   이 머티리얼의 색은 보통 미리 설정하여 소스 씬의 색과 똑같이 맞춥니다.  
    언리얼 엔진에서 이 머티리얼을 사용할 때, 색 값의 밝기에 특히 주의하세요. 디자인 툴에서는 가끔, 심지어 흰색 단색에도 매우 밝은 표면 색을 허용하는데, 현실에서 그런 경우는 별로 없습니다. 라이팅을 사실적으로 보이게 하려면 이 값을 크게 낮춰야 할 수도 있습니다.

*   데이터스미스는 보통 소스 머티리얼의 오파시티를 따릅니다. 소스 씬의 표면 색이 유리 패널과 같은 반투명(semi-transparent)으로 설정된 경우 데이터스미스는 오파시티를 Color 세팅의 **Alpha** 채널에 가져옵니다.  
    Alpha 채널을 사용하여 기존에 투명하지 않은 머티리얼이 언리얼 에디터에서 반투명이 되게 하려면, 머티리얼의 블렌딩 모드도 변경해야 할 것입니다. **General** (일반) 섹션에서 **Material Property Overrides** (머티리얼 프로퍼티 오버라이드) 그룹을 펼치고, **Blend Mode** (블렌드 모드) 옵션을 체크한 뒤 값을 **Translucent** (반투명)으로 설정합니다. 

*   Datasmith_Color 부모 머티리얼에서는 세 가지 다른 종류의 텍스처 맵을 사용할 수도 있습니다. 디퓨즈 맵으로 (Color 세팅을 무시하고) 표면의 바탕색을, 노멀 맵으로 미세한 표면 디테일을, 반투명(transparency) 맵으로 같은 표면의 다른 부분에 다른 오파시티 값을 갖도록 할 수 있습니다.  
    데이터스미스는 소스 애플리케이션에서 그런 텍스처 맵 유형을 익스포트할 수 있는 경우 이 텍스처 맵 세팅을 사용할 수 있습니다. 단조로운 색의 Datasmith_Color 인스턴스가 있고, 이런 텍스처 맵을 사용하여 표면의 사실감을 높이고 싶다면, 이 세팅을 활성화하고 텍스처 애셋을 할당하는 것이 좋습니다.  
    맵 세팅 중 하나를 활성화하면, Texture Parameter Values (텍스처 파라미터 값) 아래 새로운 세팅이 생겨 사용하고자 하는 텍스처를 설정할 수 있습니다.  
    ![Datasmith Color Instance with a texture map](datasmith-color-map-active.png "Datasmith Color Instance with a texture map")  
    하지만 처음부터 머티리얼을 직접 만드는 법을 배우는 편이 더 나을 수 있습니다. 그래야 Datasmith_Color 부모 머티리얼에 노출되지 않는 언리얼 엔진 렌더러의 다른 물리 기반 프로퍼티, 예를 들면 러프니스나 메탈릭 같은 것을 활용할 수 있습니다. [](Engine/Rendering/Materials/PhysicallyBased) 문서를 참고하세요.

## 애니메이션

소스 씬에 애니메이션 적용 3D 트랜스폼이 있는 오브젝트, 즉 시간에 따라 이동, 회전, 스케일 값이 변하는 오브젝트가 들어있는 경우, 데이터스미스는 그 애니메이션도 언리얼 엔진 프로젝트에 임포트할 수 있습니다. 씬의 애니메이션 적용 오브젝트 각각에 대한 트랙이 들어있는 레벨 시퀀스를 새로 만들고, 이 레벨 시퀀스를 데이터스미스 씬 애셋 옆 **Animations** 폴더에 저장합니다. 이 레벨 시퀀스로 언리얼 에디터에서 또는 언리얼 엔진에서 런타임에 애니메이션을 재생할 수 있습니다.

예를 들어 이 3ds Max 씬에서, 이 차고 문 부분은 스플라인을 따라 움직이는 애니메이션이 있으며, 동시에 카메라도 그 오브젝트를 중심으로 회전하는 애니메이션이 있습니다.

[OBJECT:EmbeddedVideo]
 [PARAMLITERAL:width]
 640
 [/PARAMLITERAL]
 [PARAMLITERAL:height]
 360
 [/PARAMLITERAL]
 [PARAMLITERAL:videoid]
 Ki_QwohfVOg
 [/PARAMLITERAL]
[/OBJECT]

임포트 이후, 레벨 시퀀스를 더블클릭해서 시퀀서 UI 에서 열고 애니메이션을 재생할 수 있습니다.

예를 들어 이 비디오에서, 레벨 뷰포트가 데이터스미스 씬의 카메라 위치에서 보도록 설정되어 있어, 애니메이션 적용 결과가 3ds Max 원본과 같아 보입니다.

[OBJECT:EmbeddedVideo]
 [PARAMLITERAL:width]
 640
 [/PARAMLITERAL]
 [PARAMLITERAL:height]
 360
 [/PARAMLITERAL]
 [PARAMLITERAL:videoid]
 DaCXnD9AIC0
 [/PARAMLITERAL]
[/OBJECT]

이 워크플로 관련 중요한 사항이 몇 가지 있습니다.

*   데이터스미스는 애니메이션 커브를 임포트하지 않습니다. 대신 원래 소스 애니메이션의 각 프레임에 대해, 각 애니메이션 적용 오브젝트의 현재 트랜스폼이 들어있는 키프레임을 굽습니다.

*   데이터스미스는 서브 오브젝트, 메시 디포메이션, 오브젝트 프로퍼티, 또는 스켈레탈 릭 애니메이션의 애니메이션을 처리하지 않습니다. 3D 공간에서 씬 오브젝트의 전체 이도으 회전, 또는 스케일을 변경하는 애니메이션만 처리합니다.

레벨 시퀀스 및 시퀀서 UI 사용법 관련 자세한 내용은 [](Engine/Sequencer) 문서를 참고하세요.

[REGION:note]
애니메이션 임포트 지원은 현재 3ds Max 및 glTF 파일에서 임포트된 씬으로 제한됩니다. (3ds Max 씬에서 익스포트한 데이터스미스 파일에 애니메이션을 포함하는 방법은, [](Studio/Datasmith/SoftwareInteropGuides/3dsMax/ExportingDatasmithContentfrom3dsMax) 문서를 참고하세요.) 그러나 오브젝트 트랜스폼 애니메이션이 가능한 다른 소스 애플리케이션과 파일 포맷 지원도 차차 늘려갈 계획입니다.
[/REGION]

### 여러 레벨에서 애니메이션 사용

모든 레벨 시퀀스에는 단일 지정 레벨 안의 액터에 대한 레퍼런스가 들어있습니다. 데이터스미스를 사용해서 애니메이션이 들어있는 씬을 임포트할 때, 레벨 시퀀스에는 씬을 임포트할 당시 열린 레벨에 있던 애니메이션 적용 액터로의 레퍼런스가 포함됩니다.  

나중에 같은 데이터스미스 씬 애셋을 다른 레벨에 드롭할 때, 레벨 시퀀스는 그 새 레벨에 같은 액터를 찾지 못할 것입니다. 시퀀서에 트랙 이름이 빨갛게 표시되고, 새 레벨을 열고 시퀀스를 재생해도 아무 효과가 없습니다. 이 문제를 해결할 수 있는 몇 가지 옵션이 있습니다.

*   레벨 시퀀스가 새 레벨의 액터 사본을 가리키도록 업데이트할 수 있습니다.  
    새 레벨을 연 상태에서, 시퀀서 툴바의 일반 세팅 아이콘을 클릭하고, 메뉴에서 **Fix Actor References** (액터 레퍼런스 픽스)를 선택합니다.  
    ![Fix Actor References](datasmith-animation-fix-actor-refs.png "Fix Actor References") 액터 트랙이 평소의 색으로 돌아갈 것입니다. 그러면, 레벨 시퀀스 변경사항을 저장합니다.
    [REGION:note]
    이제 레벨 시퀀스가 새 레벨을 가리키므로, 이제 원래 레벨에서는 사용할 수 없을 것입니다. 한 번에 하나의 레벨에만 사용할 수 있습니다.
    [/REGION]
    

*   콘텐츠 브라우저에서 레벨 시퀀스 애셋을 복제한 다음 위와 같이 액터 레퍼런스를 고치는 방법도 있습니다. 그러면 레벨 시퀀스 하나는 콘텐츠를 임포트했던 원래 레벨에, 사본은 새 레벨에 사용할  수 있습니다.
    [REGION:note]
    데이터스미스 씬 애셋을 리임포트하면, 원래 레벨 시퀀스만 소스 씬의 애니메이션에 가한 변경사항이 업데이트됩니다. 복제본을 다시 만들고 그 액터 레퍼런스 픽스를 다시 해야 할 수도 있습니다.
    [/REGION]
    

*   동일한 레벨 시퀀스 애니메이션이 여러 레벨에서 작동해야 하는 경우, *서브레벨* 을 사용해 보세요. 데이터스미스 씬을 빈 레벨에 임포트한 다음, 그 레벨을 애니메이션을 재생해야 하는 각 레벨 안에 서브레벨로 추가하면 됩니다. 서브레벨은 무엇이고 어떻게 사용하는지 자세한 정보는 [](Engine/Levels/LevelsWindow) 문서를 참고하세요.

## 레이어

소스 애플리케이션에서 콘텐츠를 체계적으로 분류하는 레이어 기능이나 비슷한 콘텐츠를 사용할 수 있는 경우, 데이터스미스는 언리얼 엔진에서 그 체계를 보존합니다. **레이어** 창에서 (**창 > 레이어**) 레이어를 표시하고 숨기거나, 레이어의 모든 오브젝트를 빠르게 찾아 선택할 수 있습니다.

![데이터스미스가 임포트한 레이어](datasmith_overview_layers.png "Layers imported by Datasmith")

하지만 언리얼 에디터는 *중첩* 레이어를 지원하지 않습니다. 소스 씬에서 중첩 레이어를 사용하는 경우, 데이터스미스는 자동으로 레이어의 계층구조를 단일 목록으로 평평하게 만듭니다.

언리얼 에디터에서 레이어 작업 방법 관련 자세한 정보는 [](Engine/UI/LevelEditor/Layers) 문서를 참고하세요.

## 메타데이터

일부 소스 파일 포맷의 경우 데이터스미스는 소스 애플리케이션에서 설정한 씬의 지오메트리 오브젝트 관련 메타데이터를 임포트합니다. 언리얼 에디터에서 블루프린트와 Python 스크립트를 사용하여 이 메타데이터에 액세스할 수 있습니다. 이 시스템 관련 자세한 내용은 [](Studio/Datasmith/Overview/UsingDatasmithMetadata) 문서를 참고하세요.

### 애플리케이션 전용 기술 메타데이터

일부 서드파티 애플리케이션 및 파일 포맷은 고유 ID, 오브젝트 클래스, 다른 애플리케이션 전용 데이터와 같은 개별 씬 오브젝트 관련 기술 메타데이터 값에 대한 액세스를 제공합니다. 데이터스미스는 이런 종류의 기술 데이터를 컴포넌트 태그로 가져와서 스태틱 메시 컴포넌트에 할당한 뒤 레벨에 있는 각 오브젝트의 지오메트리를 표현합니다.

이 기술 메타데이터에 액세스하려면:

1.  **레벨 뷰포트** 또는 **월드 아웃라이너** 에서 컴포넌트 태그를 확인하려는 액터를 선택합니다.  
    ![Select an Actor](tags-select-object.png "Select an Actor")

2.  **디테일** 패널에서 액터에 할당된 스태틱 메시 컴포넌트를 선택합니다.  
    ![Select the Static Mesh Component](tags-select-component.png "Select the Static Mesh Component")

3.  **디테일** 패널에서 아래로 스크롤하여 **Tags > Component Tags** 목록을 찾습니다.  
    ![Component Tags list](tags-list.png "Component Tags list")  
    예를 들어 위 이미지는 3ds Max 에서 임포트한 오브젝트를 보여줍니다. 그 컴포넌트 태그에는 3ds Max 원래 오브젝트의 클래스와 수퍼클래스, 오브젝트의 핸들 ID, 3ds Max 가 그 오브젝트를 표현하는 방법 관련 기타 정보가 포함됩니다.

[REGION:tip]
이런 종류의 기술 정보는 일반적으로 그 오브젝트를 만든 소스 애플리케이션에만 적용됩니다. 따라서 이전 섹션에서 설명한 데이터스미스 메타데이터와 별도로 유지됩니다. 반면 데이터스미스 메타데이터는 일반적으로 BIM 데이터, 생성 속성, 비용, 제조사 등 개별 씬 오브젝트에 대한 "현실 세계" 정보를 나타냅니다.
[/REGION]