// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
NiagaraDataInterfacePressureGrid.ush 
=============================================================================*/

#pragma once

/* -----------------------------------------------------------------
 * Pressure Grid constants and context
 * -----------------------------------------------------------------
 */

#define FAST_MODE 1
#define HAIR_MODE 1

static const float FLOAT_PRECISION = 1e+4;

static const int FLUID_MASS_OFFSET = 0;
static const int FLUID_VELOCITY_OFFSET = 3;
static const int FLUID_PRESSURE_OFFSET = 6;
static const int SOLID_WEIGHT_OFFSET = 7;
static const int SOLID_VELOCITY_OFFSET = 10;
static const int SOLID_DISTANCE_OFFSET = 13;
static const int FLUID_DISTANCE_OFFSET = 14;
static const int FLUID_DENSITY_OFFSET = 15;

struct FDIPressureGridContext
{
	float4x4			WorldTransform;
	float4x4			WorldInverse;
	float4				GridOrigin;
	int3				GridSize;
	Texture3D<int>		GridCurrentBuffer;
	RWTexture3D<int>	GridDestinationBuffer;
}; 

#define DIPRESSUREGRID_DECLARE_CONSTANTS(NAME)\
float4x4 WorldTransform_##NAME;\
float4x4 WorldInverse_##NAME;\
float4 GridOrigin_##NAME;\
int3 GridSize_##NAME;\
Texture3D<int> GridCurrentBuffer_##NAME;\
RWTexture3D<int> GridDestinationBuffer_##NAME;\

#define DIPRESSUREGRID_MAKE_CONTEXT(NAME)\
FDIPressureGridContext DIContext; \
DIContext.WorldTransform = WorldTransform_##NAME;\
DIContext.WorldInverse = WorldInverse_##NAME;\
DIContext.GridOrigin = GridOrigin_##NAME;\
DIContext.GridSize = GridSize_##NAME;\
DIContext.GridCurrentBuffer = GridCurrentBuffer_##NAME;\
DIContext.GridDestinationBuffer = GridDestinationBuffer_##NAME;\

/* -----------------------------------------------------------------
 * Grid topology conversion
 * -----------------------------------------------------------------
 */

// Compute the grid origin and grid length
void DIPressureGrid_BuildGridTopology(in FDIPressureGridContext DIContext, in float3 GridCenter, 
									  in float3 GridExtent, out float3 OutGridOrigin, out float OutGridLength)
{
	const float3 GridLengths = float3(2.0*GridExtent.x/(DIContext.GridSize.x-2),
									  2.0*GridExtent.y/(DIContext.GridSize.y-2),
									  2.0*GridExtent.z/(DIContext.GridSize.z-2));

	const float MaxLength = max(GridLengths.x,max(GridLengths.y,GridLengths.z));

	const float3 RegularSize = float3(DIContext.GridSize.x*MaxLength,
									  DIContext.GridSize.y*MaxLength,
									  DIContext.GridSize.z*MaxLength);

	OutGridOrigin = GridCenter - 0.5 * RegularSize;
	OutGridLength = MaxLength;
}

// Transform the node world position in grid space
float3 DIPressureGrid_GetGridPosition(in FDIPressureGridContext DIContext, in float3 NodePosition, in float3 GridOrigin)
{
	return NodePosition - GridOrigin;
}

/* -----------------------------------------------------------------
 * Grid cell/node/face validity
 * -----------------------------------------------------------------
 */

// Return true if the grid cell index is in any voxel center (0,N-1)
bool DIPressureGrid_IsCellValid(in FDIPressureGridContext DIContext, in int3 CellIndex)
{
	return (CellIndex.x >= 0 && CellIndex.x < DIContext.GridSize.x) && 
		   (CellIndex.y >= 0 && CellIndex.y < DIContext.GridSize.y) &&
		   (CellIndex.z >= 0 && CellIndex.z < DIContext.GridSize.z);
}

// Return true if the grid face index is for the component one (0,N) and in the voxel center for the others (0,N-1)
bool DIPressureGrid_IsFaceValid(in FDIPressureGridContext DIContext, in int3 FaceIndex, in int ComponentIndex)
{
	switch(ComponentIndex)
	{
		case 0 :
			return (FaceIndex.x >= 0 && FaceIndex.x <= DIContext.GridSize.x) && 
			   (FaceIndex.y >= 0 && FaceIndex.y < DIContext.GridSize.y) &&
			   (FaceIndex.z >= 0 && FaceIndex.z < DIContext.GridSize.z);
		case 1 : 
			return (FaceIndex.x >= 0 && FaceIndex.x < DIContext.GridSize.x) && 
			   (FaceIndex.y >= 0 && FaceIndex.y <= DIContext.GridSize.y) &&
			   (FaceIndex.z >= 0 && FaceIndex.z < DIContext.GridSize.z);
		default : 
			return (FaceIndex.x >= 0 && FaceIndex.x < DIContext.GridSize.x) && 
			   (FaceIndex.y >= 0 && FaceIndex.y < DIContext.GridSize.y) &&
			   (FaceIndex.z >= 0 && FaceIndex.z <= DIContext.GridSize.z);
	}
}

// Return true if the grid node index is valid (0,N)
bool DIPressureGrid_IsNodeValid(in FDIPressureGridContext DIContext, in int3 NodeIndex)
{
	return (NodeIndex.x >= 0 && NodeIndex.x <= DIContext.GridSize.x) && 
		   (NodeIndex.y >= 0 && NodeIndex.y <= DIContext.GridSize.y) &&
		   (NodeIndex.z >= 0 && NodeIndex.z <= DIContext.GridSize.z);
}

// Return true if the grid face index is inside the grid
bool DIPressureGrid_IsFaceInside(in FDIPressureGridContext DIContext, in int3 FaceIndex, in int ComponentIndex)
{
	switch(ComponentIndex)
	{
		case 0 :
			return (FaceIndex.x >  0 && FaceIndex.x < DIContext.GridSize.x) && 
			   (FaceIndex.y >= 0 && FaceIndex.y < DIContext.GridSize.y) &&
			   (FaceIndex.z >= 0 && FaceIndex.z < DIContext.GridSize.z);
		case 1 :
			return (FaceIndex.x >= 0 && FaceIndex.x < DIContext.GridSize.x) && 
			   (FaceIndex.y >  0 && FaceIndex.y < DIContext.GridSize.y) &&
			   (FaceIndex.z >= 0 && FaceIndex.z < DIContext.GridSize.z);
		default : 
			return (FaceIndex.x >= 0 && FaceIndex.x < DIContext.GridSize.x) && 
			   (FaceIndex.y >= 0 && FaceIndex.y < DIContext.GridSize.y) &&
			   (FaceIndex.z >  0 && FaceIndex.z < DIContext.GridSize.z);
	}
}

bool DIPressureGrid_IsCellInside(in FDIPressureGridContext DIContext, in int3 CellIndex)
{
	return (CellIndex.x > 0 && CellIndex.x < (DIContext.GridSize.x-1)) && 
		   (CellIndex.y > 0 && CellIndex.y < (DIContext.GridSize.y-1)) &&
		   (CellIndex.z > 0 && CellIndex.z < (DIContext.GridSize.z-1));
}

bool DIPressureGrid_IsNodeInside(in FDIPressureGridContext DIContext, in int3 NodeIndex)
{
	return (NodeIndex.x > 0 && NodeIndex.x < DIContext.GridSize.x) && 
		   (NodeIndex.y > 0 && NodeIndex.y < DIContext.GridSize.y) &&
		   (NodeIndex.z > 0 && NodeIndex.z < DIContext.GridSize.z);
}

/* -----------------------------------------------------------------
 * Grid indexing utilities
 * -----------------------------------------------------------------
 */

// Compute the grid index and fraction given a grid position and a grid offset
int3 DIPressureGrid_ComputeGridIndex(in FDIPressureGridContext DIContext, in float3 GridPosition, in float3 GridOffset, 
								 in float GridLength, out float3 OutGridFraction)
{
	const float3 GridCoordinate = GridPosition / GridLength - GridOffset;

	const int3 GridIndex = floor(GridCoordinate);
	OutGridFraction = GridCoordinate - GridIndex;
	return GridIndex;
}

// Compute the grid index given a grid hash
int3 DIPressureGrid_GetGridIndex(in FDIPressureGridContext DIContext, in int GridHash)
{
	const int GridSizeYZ = (DIContext.GridSize.y+1) * (DIContext.GridSize.z+1);
	const int GridHashYZ = GridHash % GridSizeYZ;

	return int3(GridHash / GridSizeYZ, GridHashYZ / (DIContext.GridSize.z+1), GridHashYZ % (DIContext.GridSize.z+1));
}

/* -----------------------------------------------------------------
 * Get Cell/Node/Face world positions
 * -----------------------------------------------------------------
 */
 
 // Compute the world face position
void DIPressureGrid_GetFacePosition(in FDIPressureGridContext DIContext, in int GridHash, 
									in float3 GridOrigin, in float GridLength, in int ComponentIndex, out float3 OutFacePosition)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);

	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,ComponentIndex) )
	{
		float3 ComponentOffset = float3(0.5,0.5,0.5); ComponentOffset[ComponentIndex] = 0.0;
		OutFacePosition = (GridIndex+ComponentOffset)*GridLength+GridOrigin;
	}
	else
	{
		OutFacePosition = float3(0,0,0);
	}
}

// Compute the world cell position
void DIPressureGrid_GetCellPosition(in FDIPressureGridContext DIContext, in int GridHash, 
									in float3 GridOrigin, in float GridLength, out float3 OutCellPosition)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);

	if( DIPressureGrid_IsCellValid(DIContext,GridIndex) )
	{
		OutCellPosition = (GridIndex+float3(0.5,0.5,0.5))*GridLength+GridOrigin;
	}
	else
	{
		OutCellPosition = float3(0,0,0);
	}
}

// Compute the world node position
void DIPressureGrid_GetNodePosition(in FDIPressureGridContext DIContext, in int GridHash, 
									in float3 GridOrigin, in float GridLength, out float3 OutNodePosition)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);

	if( DIPressureGrid_IsNodeValid(DIContext,GridIndex) )
	{
		OutNodePosition = GridIndex*GridLength+GridOrigin;
	}
	else
	{
		OutNodePosition = float3(0,0,0);
	}
}

/* -----------------------------------------------------------------
 * Interlocked Add/Min Float (slow but accurate version) and Int (fast but approximate version)
 * -----------------------------------------------------------------
 */

// Compute the data index from agrid index and a data offset
int3 DIPressureGrid_GetDataIndex( in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset)
{
	return int3( GridIndex.x + DataOffset * (DIContext.GridSize.x+1), GridIndex.yz);
}

#if FAST_MODE == 1

void DIPressureGrid_InterlockedAddInt(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in int IntValue)
{
	InterlockedAdd(DIContext.GridDestinationBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)], IntValue);
}

void DIPressureGrid_InterlockedMinInt(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in int IntValue)
{
	InterlockedMin(DIContext.GridDestinationBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)], IntValue);
}

#else

void DIPressureGrid_InterlockedAddFloat(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float FloatValue)
{
	int IntValue = asint(FloatValue);
	int CompareValue = 0;
	int StoredValue = 0;

	[allow_uav_condition] while(true)
	{
		InterlockedCompareExchange(DIContext.GridDestinationBuffer[
				DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)],CompareValue,IntValue,StoredValue);
		if(StoredValue == CompareValue)
		{
			break;
		}
		CompareValue = StoredValue;
		IntValue = asint(FloatValue+asfloat(StoredValue));
	}
}

void DIPressureGrid_InterlockedMinFloat(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float FloatValue)
{
	int IntValue = asint(FloatValue);
	int CompareValue = 0;
	int StoredValue = 0;

	[allow_uav_condition] while(true)
	{
		InterlockedCompareExchange(DIContext.GridDestinationBuffer[
				DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)],CompareValue,IntValue,StoredValue);
		if(StoredValue == CompareValue)
		{
			break;
		}
		CompareValue = StoredValue;
		IntValue = asint(min(FloatValue,asfloat(StoredValue)));
	}
}

#endif

/* -----------------------------------------------------------------
 * Datas accessors
 * -----------------------------------------------------------------
 */

 void DIPressureGrid_InterlockedMinScalar(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float FloatValue)
{
#if FAST_MODE == 1
	const int IntValue = FloatValue * FLOAT_PRECISION;
	DIPressureGrid_InterlockedMinInt(DIContext,GridIndex,DataOffset,IntValue);
#else
	DIPressureGrid_InterlockedMinFloat(DIContext,GridIndex,DataOffset,FloatValue);
#endif
}

void DIPressureGrid_InterlockedAddScalar(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float FloatValue)
{
#if FAST_MODE == 1
	const int IntValue = FloatValue * FLOAT_PRECISION;
	DIPressureGrid_InterlockedAddInt(DIContext,GridIndex,DataOffset,IntValue);
#else
	DIPressureGrid_InterlockedAddFloat(DIContext,GridIndex,DataOffset,FloatValue);
#endif
}

float DIPressureGrid_ConvertGridScalar(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset)
{
	const int IntValue = DIContext.GridCurrentBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)];

#if FAST_MODE == 1
	return float(IntValue) / FLOAT_PRECISION;
#else
	return asfloat(IntValue);
#endif
}

void DIPressureGrid_AddGridScalar(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float FloatValue)
{
	const float SumValue = asfloat(DIContext.GridCurrentBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)])+FloatValue;
	DIContext.GridDestinationBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)] = asint(SumValue);
}

float DIPressureGrid_GetGridScalar(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset)
{
	return asfloat(DIContext.GridCurrentBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)]);
}

void DIPressureGrid_SetGridScalar(in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float FloatValue)
{
	DIContext.GridDestinationBuffer[DIPressureGrid_GetDataIndex(DIContext,GridIndex,DataOffset)] = asint(FloatValue);
}

void DIPressureGrid_SetGridVector( in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float3 NodeVector)
{
	DIPressureGrid_SetGridScalar(DIContext,GridIndex,DataOffset,NodeVector.x);
	DIPressureGrid_SetGridScalar(DIContext,GridIndex,DataOffset+1,NodeVector.y);
	DIPressureGrid_SetGridScalar(DIContext,GridIndex,DataOffset+2,NodeVector.z);
}

void DIPressureGrid_AddGridVector( in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset, in float3 NodeVector)
{
	DIPressureGrid_AddGridScalar(DIContext,GridIndex,DataOffset,NodeVector.x);
	DIPressureGrid_AddGridScalar(DIContext,GridIndex,DataOffset+1,NodeVector.y);
	DIPressureGrid_AddGridScalar(DIContext,GridIndex,DataOffset+2,NodeVector.z);
}

float3 DIPressureGrid_GetGridVector( in FDIPressureGridContext DIContext, in int3 GridIndex, in int DataOffset)
{
	return float3(DIPressureGrid_GetGridScalar(DIContext,GridIndex,DataOffset),
				  DIPressureGrid_GetGridScalar(DIContext,GridIndex,DataOffset+1),
				  DIPressureGrid_GetGridScalar(DIContext,GridIndex,DataOffset+2));
}

/* -----------------------------------------------------------------
 * Transfer the velocity, mass and distance buffer from the current to the destination buffer
 * -----------------------------------------------------------------
 */

void DIPressureGrid_TransferCellDistance(in FDIPressureGridContext DIContext, in int3 GridIndex, in float GridLength )
{
#if HAIR_MODE == 0
	float FluidDistance = DIPressureGrid_ConvertGridScalar(DIContext,GridIndex,FLUID_DISTANCE_OFFSET);

	[branch]
	if(FluidDistance < 0.5 * GridLength)
	{
		const float SolidDistance = (DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+0,GridIndex.y+0,GridIndex.z+0),SOLID_DISTANCE_OFFSET) + 
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+0,GridIndex.y+0,GridIndex.z+1),SOLID_DISTANCE_OFFSET) +
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+0,GridIndex.y+1,GridIndex.z+0),SOLID_DISTANCE_OFFSET) +
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+0,GridIndex.y+1,GridIndex.z+1),SOLID_DISTANCE_OFFSET) +
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+1,GridIndex.y+0,GridIndex.z+0),SOLID_DISTANCE_OFFSET) +
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+1,GridIndex.y+0,GridIndex.z+1),SOLID_DISTANCE_OFFSET) +
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+1,GridIndex.y+1,GridIndex.z+0),SOLID_DISTANCE_OFFSET) +
									 DIPressureGrid_GetGridScalar(DIContext,int3(GridIndex.x+1,GridIndex.y+1,GridIndex.z+1),SOLID_DISTANCE_OFFSET) ) / 8.0;

		if(SolidDistance < 0.0) FluidDistance = -0.5 * GridLength;
	}

	DIPressureGrid_SetGridScalar(DIContext,GridIndex,FLUID_DISTANCE_OFFSET,FluidDistance);
#endif
}


void DIPressureGrid_TransferFaceVelocity(in FDIPressureGridContext DIContext, in int3 GridIndex, in int ComponentIndex)
{
	const float GridMomentum = DIPressureGrid_ConvertGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET+ComponentIndex);
	const float GridMass = DIPressureGrid_ConvertGridScalar(DIContext,GridIndex,FLUID_MASS_OFFSET+ComponentIndex);

	float GridVelocity = (GridMass != 0.0) ? GridMomentum / GridMass : 0.0;
	//if(ComponentIndex == 2) GridVelocity -= 981.0 * 0.033;

	DIPressureGrid_SetGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET+ComponentIndex,GridVelocity);
	DIPressureGrid_SetGridScalar(DIContext,GridIndex,FLUID_MASS_OFFSET+ComponentIndex,GridMass);
}

void DIPressureGrid_TransferCellVelocity(in FDIPressureGridContext DIContext, in int GridHash, in float GridLength, out bool OutTransferStatus)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);

	OutTransferStatus = false;
	if(DIPressureGrid_IsFaceValid(DIContext,GridIndex,0))
	{
		DIPressureGrid_TransferFaceVelocity(DIContext,GridIndex,0);
	}
	if(DIPressureGrid_IsFaceValid(DIContext,GridIndex,1))
	{
		DIPressureGrid_TransferFaceVelocity(DIContext,GridIndex,1);
	}
	if(DIPressureGrid_IsFaceValid(DIContext,GridIndex,2))
	{
		DIPressureGrid_TransferFaceVelocity(DIContext,GridIndex,2);
	}
#if HAIR_MODE == 0
	if(DIPressureGrid_IsCellValid(DIContext,GridIndex))
	{
		DIPressureGrid_TransferCellDistance(DIContext,GridIndex,GridLength);
	}
	if(DIPressureGrid_IsCellValid(DIContext,GridIndex))
	{
		const float PrevDensity = DIPressureGrid_ConvertGridScalar(DIContext,GridIndex,FLUID_DENSITY_OFFSET);
		const float NextDensity = DIPressureGrid_ConvertGridScalar(DIContext,GridIndex,FLUID_DENSITY_OFFSET+1);

		const float DensityRatio = (PrevDensity != 0.0) ? GridLength * (1.0-NextDensity / PrevDensity) / 0.033 : 0.0;

		DIPressureGrid_SetGridScalar(DIContext,GridIndex,FLUID_DENSITY_OFFSET,DensityRatio);
		DIPressureGrid_SetGridScalar(DIContext,GridIndex,FLUID_DENSITY_OFFSET+1,NextDensity);
	}
#endif
}

/* -----------------------------------------------------------------
 * Interpolation function and gradient
 * -----------------------------------------------------------------
 */

 float DIPressureGrid_GetShapeFunction( in float3 GridFraction, in int3 ijk)
 {
	const float GridWeightX = (ijk.x == 0) ? 1.0 - GridFraction.x : GridFraction.x;
	const float GridWeightY = (ijk.y == 0) ? 1.0 - GridFraction.y : GridFraction.y;
	const float GridWeightZ = (ijk.z == 0) ? 1.0 - GridFraction.z : GridFraction.z;

	return GridWeightX*GridWeightY*GridWeightZ;
 }

 float3 DIPressureGrid_GetShapeGradient( in float3 GridFraction, in int3 ijk)
 {
	const float GridWeightX = (ijk.x == 0) ? 1.0 - GridFraction.x : GridFraction.x;
	const float GridWeightY = (ijk.y == 0) ? 1.0 - GridFraction.y : GridFraction.y;
	const float GridWeightZ = (ijk.z == 0) ? 1.0 - GridFraction.z : GridFraction.z;

	const float GridGradientX = (ijk.x == 0) ? -1.0: 1.0;
	const float GridGradientY = (ijk.y == 0) ? -1.0: 1.0;
	const float GridGradientZ = (ijk.z == 0) ? -1.0: 1.0;

	return  float3(GridGradientX*GridWeightY*GridWeightZ,
				   GridWeightX*GridGradientY*GridWeightZ,
				   GridWeightX*GridWeightY*GridGradientZ);
 }

/* -----------------------------------------------------------------
 * Build Velocity Field from nodes
 * -----------------------------------------------------------------
 */
 
// Transfer the distance from the node to the grid
void DIPressureGrid_BuildDistanceField(in FDIPressureGridContext DIContext, in float3 NodePosition, in float3 GridOrigin, in float GridLength)
{
#if HAIR_MODE == 0
	const float3 GridPosition = DIPressureGrid_GetGridPosition(DIContext,NodePosition,GridOrigin);

	float3 GridFraction = float3(0,0,0);
	const int3 GridIndex = DIPressureGrid_ComputeGridIndex(DIContext,GridPosition,float3(0.5,0.5,0.5),GridLength,GridFraction);

	const float NodeRadius = GridLength * 0.5 * 1.414213;

	for(int i = -2; i <= 2; ++i)
	for(int j = -2; j <= 2; ++j)
	for(int k = -2; k <= 2; ++k)
	{
		const int3 GridLocation = int3(GridIndex.x+i,GridIndex.y+j,GridIndex.z+k);

		if( DIPressureGrid_IsCellValid(DIContext,GridLocation) )
		{
			const float3 CellPosition = (GridLocation+float3(0.5,0.5,0.5))*GridLength+GridOrigin;
			const float CellDistance = length(CellPosition-NodePosition) - NodeRadius; 

			DIPressureGrid_InterlockedMinScalar(DIContext,GridLocation,FLUID_DISTANCE_OFFSET,CellDistance);
		}
	}
#endif
}
 
// Transfer the velocity component from the node to the grid
void DIPressureGrid_BuildVelocityFace(in FDIPressureGridContext DIContext, in int3 GridIndex, in float3 GridFraction, in int3 ijk, in float3 GridPosition, in float SampleMass, in float SampleMomentum,
			in float3 MomentumGradient, in float3 ComponentOffset, in int ComponentIndex, in float GridLength )
{
	const int3 GridLocation = int3(GridIndex.x+ijk.x,GridIndex.y+ijk.y,GridIndex.z+ijk.z);

	if( DIPressureGrid_IsFaceValid(DIContext,GridLocation,ComponentIndex) )
	{
		const float ShapeFunction = DIPressureGrid_GetShapeFunction(GridFraction,ijk);

		const float3 DeltaPosition = (GridLocation+ComponentOffset)*GridLength - GridPosition;
		const float GridMomentum = SampleMomentum + dot(MomentumGradient, DeltaPosition);

		DIPressureGrid_InterlockedAddScalar(DIContext,GridLocation,FLUID_MASS_OFFSET+ComponentIndex,SampleMass*ShapeFunction);
		DIPressureGrid_InterlockedAddScalar(DIContext,GridLocation,FLUID_VELOCITY_OFFSET+ComponentIndex,GridMomentum*ShapeFunction);
	}
}

// Transfer the velocity component from the node to the grid
void DIPressureGrid_BuildVelocityComponent(in FDIPressureGridContext DIContext, in float3 GridPosition, in float SampleMass, in float SampleMomentum,
			in float3 MomentumGradient, in float3 ComponentOffset, in int ComponentIndex, in float GridLength )
{
	float3 GridFraction = float3(0,0,0);
	const int3 GridIndex = DIPressureGrid_ComputeGridIndex(DIContext,GridPosition,ComponentOffset,GridLength,GridFraction);

	for(int i = 0; i < 2; ++i)
	{
		const float GridWeightX = (i == 0) ? 1.0 - GridFraction.x : GridFraction.x;
		for(int j = 0; j < 2; ++j)
		{
			const float GridWeightY = (j == 0) ? 1.0 - GridFraction.y : GridFraction.y;
			for(int k = 0; k < 2; ++k)
			{
				const float GridWeightZ = (k == 0) ? 1.0 - GridFraction.z : GridFraction.z;
				const float GridWeightXYZ = GridWeightX*GridWeightY*GridWeightZ;

				const int3 GridLocation = int3(GridIndex.x+i,GridIndex.y+j,GridIndex.z+k);
				if( DIPressureGrid_IsFaceValid(DIContext,GridLocation,ComponentIndex) )
				{
					const float3 DeltaPosition = ((GridLocation+ComponentOffset)*GridLength) - GridPosition;
					const float GridMomentum = SampleMomentum + dot(MomentumGradient, DeltaPosition);

					DIPressureGrid_InterlockedAddScalar(DIContext,GridLocation,FLUID_MASS_OFFSET+ComponentIndex,SampleMass*GridWeightXYZ);
					DIPressureGrid_InterlockedAddScalar(DIContext,GridLocation,FLUID_VELOCITY_OFFSET+ComponentIndex,GridMomentum*GridWeightXYZ);
				}
			}
		}
	}

	/*DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(0,0,0),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(0,0,1),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(0,1,0),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(0,1,1),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(1,0,0),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(1,0,1),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(1,1,0),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);
	DIPressureGrid_BuildVelocityFace(DIContext,GridIndex,GridFraction,int3(1,1,1),GridPosition,SampleMass,
		SampleMomentum,MomentumGradient,ComponentOffset,ComponentIndex,GridLength);*/
}

// Transfer the velocity from the node to the grid
void DIPressureGrid_BuildSampleVelocity(in FDIPressureGridContext DIContext, in float3 NodePosition, in float NodeMass, in float3 NodeVelocity, 
			in float3 VelocityGradientX, in float3 VelocityGradientY, in float3 VelocityGradientZ, in float3 GridOrigin, in float GridLength)
{
	const float3 NodeMomentum = NodeVelocity * NodeMass;

	const float3 MomentumGradientX = VelocityGradientX * NodeMass;
	const float3 MomentumGradientY = VelocityGradientY * NodeMass;
	const float3 MomentumGradientZ = VelocityGradientZ * NodeMass;

	const float3 GridPosition = DIPressureGrid_GetGridPosition(DIContext,NodePosition,GridOrigin);

	DIPressureGrid_BuildVelocityComponent(DIContext,GridPosition,NodeMass,NodeMomentum.x,MomentumGradientX,float3(0.0,0.5,0.5),0,GridLength);
	DIPressureGrid_BuildVelocityComponent(DIContext,GridPosition,NodeMass,NodeMomentum.y,MomentumGradientY,float3(0.5,0.0,0.5),1,GridLength);
	DIPressureGrid_BuildVelocityComponent(DIContext,GridPosition,NodeMass,NodeMomentum.z,MomentumGradientZ,float3(0.5,0.5,0.0),2,GridLength);

#if HAIR_MODE == 0
	DIPressureGrid_BuildDistanceField(DIContext,NodePosition,GridOrigin,GridLength);

	const float3 PreviousPosition = NodePosition - NodeVelocity * 0.033;
	const float3 GridPositionP = DIPressureGrid_GetGridPosition(DIContext,PreviousPosition,GridOrigin);

	float3 GridFractionP = float3(0,0,0);
	const int3 GridIndexP = DIPressureGrid_ComputeGridIndex(DIContext,GridPositionP,float3(0.5,0.5,0.5),GridLength,GridFractionP);

	float3 GridFractionN = float3(0,0,0);
	const int3 GridIndexN = DIPressureGrid_ComputeGridIndex(DIContext,GridPosition,float3(0.5,0.5,0.5),GridLength,GridFractionN);

	for( int i = 0; i < 2; ++i)
	{
	for( int j = 0; j < 2; ++j)
	{
	for( int k = 0; k < 2; ++k)
	{
		const int3 ijk = int3(i,j,k);
		const int3 GridLocationP = int3(GridIndexP.x+ijk.x,GridIndexP.y+ijk.y,GridIndexP.z+ijk.z);

		if( DIPressureGrid_IsCellValid(DIContext,GridLocationP) )
		{
			const float ShapeFunction = DIPressureGrid_GetShapeFunction(GridFractionP,ijk);
			DIPressureGrid_InterlockedAddScalar(DIContext,GridLocationP,FLUID_DENSITY_OFFSET,ShapeFunction);
		}
		const int3 GridLocationN = int3(GridIndexN.x+ijk.x,GridIndexN.y+ijk.y,GridIndexN.z+ijk.z);

		if( DIPressureGrid_IsCellValid(DIContext,GridLocationN) )
		{
			const float ShapeFunction = DIPressureGrid_GetShapeFunction(GridFractionN,ijk);
			DIPressureGrid_InterlockedAddScalar(DIContext,GridLocationN,FLUID_DENSITY_OFFSET+1,ShapeFunction);
		}
	}
	}
	}
#endif
}

// Transfer the velocity from the node to the grid
void DIPressureGrid_BuildVelocityField(in FDIPressureGridContext DIContext, in int StrandsSize, in float3 NodePosition, in float NodeMass, in float3 NodeVelocity, 
			in float3 VelocityGradientX, in float3 VelocityGradientY, in float3 VelocityGradientZ, in float3 GridOrigin, in float GridLength, out bool OutBuildStatus)
{
	if(StrandsSize == 1)
	{
		DIPressureGrid_BuildSampleVelocity(DIContext,NodePosition,NodeMass,NodeVelocity,VelocityGradientX,VelocityGradientY,VelocityGradientZ,GridOrigin,GridLength);
	}
	else
	{
		SharedNodePosition[GGroupThreadId.x] = NodePosition;
		SharedPreviousPosition[GGroupThreadId.x] = NodeVelocity;
		SharedInverseMass[GGroupThreadId.x] = NodeMass;
		GroupMemoryBarrier();

		const int LocalIndex = GGroupThreadId.x % StrandsSize;

		if( LocalIndex > 0 )
		{
			const float3 DeltaVelocity = SharedPreviousPosition[GGroupThreadId.x] - SharedPreviousPosition[GGroupThreadId.x-1];
			const float3 DeltaPosition = SharedNodePosition[GGroupThreadId.x] - SharedNodePosition[GGroupThreadId.x-1];

			const float2 SegmentWeight = (LocalIndex == 1) ? float2(1.0,0.5) : (LocalIndex == (StrandsSize-1) ) ? float2(0.5,1.0) : float2(0.5,0.5);
			const float SegmentMass =  (SharedInverseMass[GGroupThreadId.x-1] * SegmentWeight.x + SharedInverseMass[GGroupThreadId.x] * SegmentWeight.y);
			const float SegmentLength = length(DeltaPosition);

			const int NumSamples = ceil(SegmentLength / GridLength);
			const float SampleMass = SegmentMass / NumSamples;

			for( int SampleIndex = 0; SampleIndex < NumSamples; ++SampleIndex)
			{
				const float SampleCoord = (0.5+SampleIndex) / NumSamples;
				const float3 SamplePosition = SharedNodePosition[GGroupThreadId.x] + SampleCoord * DeltaPosition;
				const float3 SampleVelocity = (SharedPreviousPosition[GGroupThreadId.x] + SampleCoord * DeltaVelocity);

				DIPressureGrid_BuildSampleVelocity(DIContext,SamplePosition,SampleMass,SampleVelocity,
						VelocityGradientX,VelocityGradientY,VelocityGradientZ,GridOrigin,GridLength);
			}
		}
	}
	OutBuildStatus = true;
}

/* -----------------------------------------------------------------
 * Sample Velocity field from grid
 * -----------------------------------------------------------------
 */
 
// Sample the grid velocity field and gradient component at the node local position 
void DIPressureGrid_SampleVelocityFace(in FDIPressureGridContext DIContext, in int3 GridIndex, in float3 GridFraction, in int3 ijk, in float3 GridPosition, in float3 ComponentOffset, in int ComponentIndex, in float GridLength,
						inout float OutGridVelocity, inout float OutGridMass, inout float3 OutGridGradient)
{
	const int3 GridLocation = int3(GridIndex.x+ijk.x,GridIndex.y+ijk.y,GridIndex.z+ijk.z);

	if( DIPressureGrid_IsFaceValid(DIContext,GridLocation,ComponentIndex) )
	{
		const float ShapeFunction = DIPressureGrid_GetShapeFunction(GridFraction,ijk);
		const float3 ShapeGradient = DIPressureGrid_GetShapeGradient(GridFraction,ijk) / GridLength;

		const float GridVelocity = DIPressureGrid_GetGridScalar(DIContext,GridLocation,FLUID_VELOCITY_OFFSET+ComponentIndex);
		const float GridMass = DIPressureGrid_GetGridScalar(DIContext,GridLocation,FLUID_MASS_OFFSET+ComponentIndex);

		OutGridMass += GridMass * ShapeFunction;
		OutGridVelocity += GridVelocity * ShapeFunction;
		OutGridGradient += GridVelocity * ShapeGradient;
	}
}

// Sample the grid velocity field and gradient component at the node local position 
void DIPressureGrid_SampleVelocityComponent(in FDIPressureGridContext DIContext, in float3 GridPosition, in float3 ComponentOffset, in int ComponentIndex, in float GridLength,
						out float OutGridVelocity, out float OutGridMass, out float3 OutGridGradient)
{
	float3 GridFraction = float3(0,0,0); 
	const int3 GridIndex = DIPressureGrid_ComputeGridIndex(DIContext,GridPosition,ComponentOffset,GridLength,GridFraction);

	OutGridVelocity = 0.0;
	OutGridGradient = float3(0,0,0); 
	OutGridMass = 0.0;

	for(int i = 0; i < 2; ++i)
	{
		const float GridWeightX = (i == 0) ? 1.0 - GridFraction.x : GridFraction.x;
		const float GridGradientX = (i == 0) ? -1.0: 1.0;
		for(int j = 0; j < 2; ++j)
		{
			const float GridWeightY = (j == 0) ? 1.0 - GridFraction.y : GridFraction.y;
			const float GridGradientY = (j == 0) ? -1.0: 1.0;
			for(int k = 0; k < 2; ++k)
			{
				const float GridWeightZ = (k == 0) ? 1.0 - GridFraction.z : GridFraction.z;
				const float GridGradientZ = (k == 0) ? -1.0: 1.0;

				const int3 GridLocation = int3(GridIndex.x+i,GridIndex.y+j,GridIndex.z+k);

				if( DIPressureGrid_IsFaceValid(DIContext,GridLocation,ComponentIndex) )
				{
					const float GridWeightXYZ = GridWeightX*GridWeightY*GridWeightZ;
					const float3 GridGradientXYZ = float3(GridGradientX*GridWeightY*GridWeightZ,
														GridWeightX*GridGradientY*GridWeightZ,
														GridWeightX*GridWeightY*GridGradientZ) / GridLength;
					const float GridVelocity = DIPressureGrid_GetGridScalar(DIContext,GridLocation,FLUID_VELOCITY_OFFSET+ComponentIndex);
					const float GridMass = DIPressureGrid_GetGridScalar(DIContext,GridLocation,FLUID_MASS_OFFSET+ComponentIndex);

					OutGridMass += GridMass * GridWeightXYZ;
					OutGridVelocity += GridVelocity * GridWeightXYZ;
					OutGridGradient += GridVelocity * GridGradientXYZ;
				}
			}
		}
	}

	/*DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(0,0,0),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(0,0,1),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(0,1,0),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(0,1,1),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(1,0,0),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(1,0,1),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(1,1,0),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);
	DIPressureGrid_SampleVelocityFace(DIContext,GridIndex,GridFraction,int3(1,1,1),GridPosition,
		ComponentOffset,ComponentIndex,GridLength,OutGridVelocity,OutGridMass,OutGridGradient);*/
}

// Sample the grid velocity field and gradient at the node world position 
void DIPressureGrid_SampleVelocityField(in FDIPressureGridContext DIContext, in float3 NodePosition, in float3 GridOrigin, in float GridLength, out float3 OutGridVelocity, out float OutNodeDensity,
			out float3 OutGridGradientX, out float3 OutGridGradientY, out float3 OutGridGradientZ)
{
	OutGridVelocity = float3(0,0,0);
	OutGridGradientX = float3(0,0,0);
	OutGridGradientY = float3(0,0,0);
	OutGridGradientZ = float3(0,0,0);

	float3 GridMass = float3(0,0,0);

	const float3 GridPosition = DIPressureGrid_GetGridPosition(DIContext,NodePosition,GridOrigin);
	DIPressureGrid_SampleVelocityComponent(DIContext,GridPosition,float3(0.0,0.5,0.5),0,GridLength,OutGridVelocity.x,GridMass.x,OutGridGradientX);
	DIPressureGrid_SampleVelocityComponent(DIContext,GridPosition,float3(0.5,0.0,0.5),1,GridLength,OutGridVelocity.y,GridMass.y,OutGridGradientY);
	DIPressureGrid_SampleVelocityComponent(DIContext,GridPosition,float3(0.5,0.5,0.0),2,GridLength,OutGridVelocity.z,GridMass.z,OutGridGradientZ);

	OutNodeDensity = (GridMass.x+GridMass.y+GridMass.z)/(3.0*GridLength*GridLength*GridLength);
}

/* -----------------------------------------------------------------
 * Velocity Accessors
 * -----------------------------------------------------------------
 */

void DIPressureGrid_AddGridVelocity(in FDIPressureGridContext DIContext, in int GridHash, in float3 GridVelocity, out bool OutAddStatus)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);
	OutAddStatus = true;

	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,0) )
	{
		OutAddStatus = true;
		DIPressureGrid_AddGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET,GridVelocity.x);
	}
	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,1) )
	{
		OutAddStatus = true;
		DIPressureGrid_AddGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET+1,GridVelocity.y);
	}
	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,2) )
	{
		OutAddStatus = true;
		DIPressureGrid_AddGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET+2,GridVelocity.z);
	}
}

void DIPressureGrid_GetGridVelocity(in FDIPressureGridContext DIContext, in int GridHash, out float3 OutGridVelocity)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);

	OutGridVelocity = float3(0,0,0);

	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,0) )
	{
		OutGridVelocity.x = DIPressureGrid_GetGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET);
	}
	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,1) )
	{
		OutGridVelocity.y = DIPressureGrid_GetGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET+1);
	}
	if( DIPressureGrid_IsFaceValid(DIContext,GridIndex,2) )
	{
		OutGridVelocity.z = DIPressureGrid_GetGridScalar(DIContext,GridIndex,FLUID_VELOCITY_OFFSET+2);
	}
}

/* -----------------------------------------------------------------
 * Update boundary weights
 * -----------------------------------------------------------------
 */

 #if HAIR_MODE == 0
 float DIPressureGrid_GetFractionInsideEdge(in float SignedDistanceA, in float SignedDistanceB)
 {
	const bool IsInsideA = SignedDistanceA<0.0;
	const bool IsInsideB = SignedDistanceB<0.0;

	return (IsInsideA && IsInsideB) ? 1.0 : (IsInsideA && !IsInsideB) ? SignedDistanceA / (SignedDistanceA - SignedDistanceB) : 
		   (!IsInsideA && IsInsideB) ? SignedDistanceB / (SignedDistanceB - SignedDistanceA)  : 0.0;
 }

 float DIPressureGrid_GetFractionInsideImplA(in float SignedDistanceA, in float SignedDistanceB, in float SignedDistanceD)
 {
	const float Side0 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceD);
	const float Side1 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceB);
	return 1.0 - 0.5 * Side0 * Side1;
 }

 float DIPressureGrid_GetFractionInsideImplB(in float SignedDistanceA, in float SignedDistanceB, in float SignedDistanceC, in float SignedDistanceD)
 {
	const float Side0 = DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceD);
	const float Side1 = DIPressureGrid_GetFractionInsideEdge(SignedDistanceB,SignedDistanceC);
	return 0.5 * ( Side0 + Side1);
 }

 float DIPressureGrid_GetFractionInsideImplC(in float SignedDistanceA, in float SignedDistanceB, in float SignedDistanceC, in float SignedDistanceD)
 {
	const float MiddlePoint = 0.25 * (SignedDistanceA+SignedDistanceB+SignedDistanceC+SignedDistanceD);
	if(MiddlePoint < 0.0)
	{
		float FaceArea = 0.0;

		const float Side1 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceD);
		const float Side3 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceC,SignedDistanceD);
		FaceArea += 0.5 * Side3 * Side1;

		const float Side2 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceC,SignedDistanceB);
		const float Side0 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceB);
		FaceArea += 0.5 * Side0 * Side2;

		return 1.0 - FaceArea;
	}
	else
	{
		float FaceArea = 0.0;

		const float Side0 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceB);
		const float Side1 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceD);
		FaceArea += 0.5 * Side0 * Side1;

		const float Side2 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceC,SignedDistanceB);
		const float Side3 = 1.0 - DIPressureGrid_GetFractionInsideEdge(SignedDistanceC,SignedDistanceD);
		FaceArea += 0.5 * Side3 * Side2;

		return FaceArea;

	}
 }

 float DIPressureGrid_GetFractionInsideImplD(in float SignedDistanceA, in float SignedDistanceB, in float SignedDistanceD)
 {
	const float Side0 = DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceD);
	const float Side1 = DIPressureGrid_GetFractionInsideEdge(SignedDistanceA,SignedDistanceB);
	return 0.5 * Side0 * Side1;
 }

 float DIPressureGrid_GetFractionInsideFace(in float SignedDistanceA, in float SignedDistanceB, in float SignedDistanceC, in float SignedDistanceD )
 {
	const bool IsInsideA = SignedDistanceA<0.0;
	const bool IsInsideB = SignedDistanceB<0.0;
	const bool IsInsideC = SignedDistanceC<0.0;
	const bool IsInsideD = SignedDistanceD<0.0;

	const int InsideCount = IsInsideA + IsInsideB + IsInsideC + IsInsideD;

	[branch]
	if(InsideCount == 4)
	{
		return 1.0;
	}
	else if(InsideCount == 3)
	{
		[branch]
		if(!IsInsideA)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceA,SignedDistanceB,SignedDistanceD);
		}
		else if(!IsInsideB)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceB,SignedDistanceC,SignedDistanceA);
		}
		else if(!IsInsideC)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceC,SignedDistanceD,SignedDistanceB);
		}
		else if(!IsInsideD)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceD,SignedDistanceA,SignedDistanceC);
		}
	}
	else if(InsideCount == 2)
	{
		[branch]
		if(IsInsideA && IsInsideB)
		{
			return DIPressureGrid_GetFractionInsideImplB(SignedDistanceA,SignedDistanceB,SignedDistanceC, SignedDistanceD);
		}
		else if(IsInsideB && IsInsideC)
		{
			return DIPressureGrid_GetFractionInsideImplB(SignedDistanceB,SignedDistanceC,SignedDistanceD, SignedDistanceA);
		}
		else if(IsInsideC && IsInsideD)
		{
			return DIPressureGrid_GetFractionInsideImplB(SignedDistanceC,SignedDistanceD,SignedDistanceA, SignedDistanceB);
		}
		else if(IsInsideD && IsInsideA)
		{
			return DIPressureGrid_GetFractionInsideImplB(SignedDistanceD,SignedDistanceA,SignedDistanceB, SignedDistanceC);
		}
		else if(IsInsideA && IsInsideC)
		{
			return DIPressureGrid_GetFractionInsideImplC(SignedDistanceA,SignedDistanceB,SignedDistanceC, SignedDistanceD);
		}
		else if(IsInsideB && IsInsideD)
		{
			return DIPressureGrid_GetFractionInsideImplC(SignedDistanceB,SignedDistanceC,SignedDistanceD, SignedDistanceA);
		}
	}
	else if(InsideCount == 1)
	{
		[branch]
		if(IsInsideA)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceA,SignedDistanceB,SignedDistanceD);
		}
		else if(IsInsideB)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceB,SignedDistanceC,SignedDistanceA);
		}
		else if(IsInsideC)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceC,SignedDistanceD,SignedDistanceB);
		}
		else if(IsInsideD)
		{
			return DIPressureGrid_GetFractionInsideImplA(SignedDistanceD,SignedDistanceA,SignedDistanceC);
		}
	}
	return 0;
 }

 #endif

 // Update the solid weights and velocities
void DIPressureGrid_SetSolidBoundary(in FDIPressureGridContext DIContext, in int GridHash, in float SolidDistance,
																in float3 SolidVelocity, out bool OutBoundaryStatus)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);
	OutBoundaryStatus = false;

	#if HAIR_MODE == 0

	[branch]
	if( DIPressureGrid_IsNodeValid(DIContext,GridIndex))
	{
		OutBoundaryStatus = true;
		DIPressureGrid_SetGridScalar(DIContext,GridIndex,SOLID_DISTANCE_OFFSET,SolidDistance);
		DIPressureGrid_SetGridVector(DIContext,GridIndex,SOLID_VELOCITY_OFFSET,SolidVelocity);
	}

	#endif
}

#if HAIR_MODE == 0

void DIPressureGrid_ComputeFaceWeights(in FDIPressureGridContext DIContext, in int3 GridLocation, in int ComponentIndex, out float SignedDistance, inout float NodeVelocity )
{
	SignedDistance = DIPressureGrid_GetGridScalar(DIContext,GridLocation,SOLID_DISTANCE_OFFSET);
	NodeVelocity += DIPressureGrid_GetGridScalar(DIContext,GridLocation,SOLID_VELOCITY_OFFSET+ComponentIndex);
}

void DIPressureGrid_ComputeComponentWeights(in FDIPressureGridContext DIContext, in int3 GridIndex, in int ComponentIndex)
{
	[branch]
	if( DIPressureGrid_IsFaceInside(DIContext,GridIndex,ComponentIndex))
	{
		float SignedDistance[4];
		float NodeVelocity = 0.0;

		[branch]
		if(ComponentIndex == 0)
		{
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x,GridIndex.y+0,GridIndex.z+0),ComponentIndex,SignedDistance[0],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x,GridIndex.y+0,GridIndex.z+1),ComponentIndex,SignedDistance[1],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x,GridIndex.y+1,GridIndex.z+0),ComponentIndex,SignedDistance[2],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x,GridIndex.y+1,GridIndex.z+1),ComponentIndex,SignedDistance[3],NodeVelocity);
		}
		else if(ComponentIndex == 1)
		{
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+0,GridIndex.y,GridIndex.z+0),ComponentIndex,SignedDistance[0],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+0,GridIndex.y,GridIndex.z+1),ComponentIndex,SignedDistance[1],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+1,GridIndex.y,GridIndex.z+0),ComponentIndex,SignedDistance[2],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+1,GridIndex.y,GridIndex.z+1),ComponentIndex,SignedDistance[3],NodeVelocity);
		}
		else
		{
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+0,GridIndex.y+0,GridIndex.z),ComponentIndex,SignedDistance[0],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+0,GridIndex.y+1,GridIndex.z),ComponentIndex,SignedDistance[1],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+1,GridIndex.y+0,GridIndex.z),ComponentIndex,SignedDistance[2],NodeVelocity);
			DIPressureGrid_ComputeFaceWeights(DIContext,int3(GridIndex.x+1,GridIndex.y+1,GridIndex.z),ComponentIndex,SignedDistance[3],NodeVelocity);
		}

		const float SolidWeight = max(0.0,min(1.0 - DIPressureGrid_GetFractionInsideFace(SignedDistance[0],SignedDistance[1],SignedDistance[3],SignedDistance[2]),1.0));
		const float SolidVelocity = 0.25 * NodeVelocity;

		DIPressureGrid_SetGridScalar(DIContext,GridIndex,SOLID_WEIGHT_OFFSET+ComponentIndex,SolidWeight);
		DIPressureGrid_SetGridScalar(DIContext,GridIndex,SOLID_VELOCITY_OFFSET+ComponentIndex,SolidVelocity);
	}
}

#endif

 // Update the solid weights and velocities
void DIPressureGrid_ComputeBoundaryWeights(in FDIPressureGridContext DIContext, in int GridHash, out bool OutWeightsStatus)
{
	const int3 GridIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);
	OutWeightsStatus = false;

	#if HAIR_MODE == 0

	DIPressureGrid_ComputeComponentWeights(DIContext,GridIndex,0);
	DIPressureGrid_ComputeComponentWeights(DIContext,GridIndex,1);
	DIPressureGrid_ComputeComponentWeights(DIContext,GridIndex,2);

	#endif
}

/* -----------------------------------------------------------------
 * Sample Velocity field from grid
 * -----------------------------------------------------------------
 */

// Compute the grid pressure
// Mdv/dt = Jt * P with C = Volume * div(V) = 0.0 = ( vnx * wnx * dx * dx - vpx * wpx * dx * dx ) + ... (divergence theorem)
// -> dv = inv(M) * Jt * P * dt;
// Jnx = dC/dvnx = wnx * dx * dx, Jpx = dC/dvpx = -wpx * dx * dx
// since C = C0 + dC/dv * dv = C0 + J * dv = 0 = C0 + J * inv(M) * Jt * P * dt; and M = wnx * mnx
// the schur complement is J * inv(M) * Jt * P * dt = -C0 -> P * dt = -C0 / (wnx * dx * dx * wnx * dx * dx / ( wnx * mnx) + wpx * ....)
// P * dt = - sum( vnx * wnx * dx * dx - vpx * wpx * dx * dx ) / sum (wnx * dx * dx * wnx * dx * dx / ( wnx * mnx);
//        = - sum( vnx * wnx ) / sum( wnx * dx * dx / mnx ) = -sum( vnx * wnx ) / ( dx * dx * sum( wnx / mnx ) )
// P * dt * dx * dx = Pt = -sum( vnx * wnx ) / ( sum( wnx / mnx ) )
// dv = wnx * dx * dx * P * dt / (wnx * mnx) = Pt / mnx

#if HAIR_MODE == 0

float DIPressureGrid_ComputeGridPressure(in FDIPressureGridContext DIContext, in int3 PrevIndex, in float CentreDistance, out float3 PrevFraction, out float3 NextFraction)
{	
	float GridPressure = 0.0;
	float GridDivergence = 0.0;
	float GridFraction = 0.0;

	for(int ComponentIndex = 0; ComponentIndex < 3; ++ComponentIndex)
	{
		int3 NextIndex = PrevIndex; NextIndex[ComponentIndex] += 1;

		const float PrevDistance = DIPressureGrid_GetGridScalar(DIContext,PrevIndex,FLUID_DISTANCE_OFFSET);
		PrevFraction[ComponentIndex] = (PrevDistance < 0.0) ? 1.0 : max(DIPressureGrid_GetFractionInsideEdge(CentreDistance,PrevDistance),0.01);
		const float PrevWeight = DIPressureGrid_GetGridScalar(DIContext,PrevIndex,SOLID_WEIGHT_OFFSET+ComponentIndex);
			
		GridDivergence -= DIPressureGrid_GetGridScalar(DIContext,PrevIndex,SOLID_VELOCITY_OFFSET+ComponentIndex) * (1.0-PrevWeight);
		GridDivergence -= DIPressureGrid_GetGridScalar(DIContext,PrevIndex,FLUID_VELOCITY_OFFSET+ComponentIndex) * PrevWeight;
		GridFraction += PrevWeight / PrevFraction[ComponentIndex];

		const float NextDistance = DIPressureGrid_GetGridScalar(DIContext,NextIndex,FLUID_DISTANCE_OFFSET);
		NextFraction[ComponentIndex] = (NextDistance < 0.0) ? 1.0 : max(DIPressureGrid_GetFractionInsideEdge(CentreDistance,NextDistance),0.01);
		const float NextWeight = DIPressureGrid_GetGridScalar(DIContext,NextIndex,SOLID_WEIGHT_OFFSET+ComponentIndex);
			
		GridDivergence += DIPressureGrid_GetGridScalar(DIContext,NextIndex,SOLID_VELOCITY_OFFSET+ComponentIndex) * (1.0-NextWeight);
		GridDivergence += DIPressureGrid_GetGridScalar(DIContext,NextIndex,FLUID_VELOCITY_OFFSET+ComponentIndex) * NextWeight;
		GridFraction += NextWeight / NextFraction[ComponentIndex];
	}
	if( GridFraction > 0.0)
	{
		//GridDivergence += DIPressureGrid_GetGridScalar(DIContext,PrevIndex,FLUID_DENSITY_OFFSET);
		GridPressure = -GridDivergence / (GridFraction);
	}
	return GridPressure;
}

#endif

// Project the pressure grid to be divergence free
void DIPressureGrid_ProjectVelocityField(in FDIPressureGridContext DIContext, in int GridHash, in int InitStage, out bool OutProjectStatus)
{	
	OutProjectStatus = false;

	#if HAIR_MODE == 0

	const int3 PrevIndex = DIPressureGrid_GetGridIndex(DIContext,GridHash);
	const bool IsInitStage = (ShaderStageIndex == InitStage) || (ShaderStageIndex == (InitStage+1));

	if(DIPressureGrid_IsCellValid(DIContext,PrevIndex))
	{
		if( (PrevIndex.x+PrevIndex.y+PrevIndex.z+ShaderStageIndex) % 2 == 0)
		{
			OutProjectStatus = true;
			const float CentreDistance = DIPressureGrid_GetGridScalar(DIContext,PrevIndex,FLUID_DISTANCE_OFFSET);
			if( CentreDistance < 0.0)
			{
				float3 PrevFraction = float3(0,0,0);
				float3 NextFraction = float3(0,0,0);

				float GridPressure = DIPressureGrid_ComputeGridPressure(DIContext,PrevIndex,CentreDistance,PrevFraction,NextFraction);
				if(!IsInitStage)
				{
					DIPressureGrid_AddGridScalar(DIContext,PrevIndex,FLUID_PRESSURE_OFFSET,GridPressure);
				}
				else 
				{
					GridPressure =  DIPressureGrid_GetGridScalar(DIContext,PrevIndex,FLUID_PRESSURE_OFFSET);
				}

				for( int ComponentIndex = 0; ComponentIndex < 3; ++ComponentIndex)
				{
					int3 NextIndex = PrevIndex; NextIndex[ComponentIndex] += 1;

					const float PrevWeight = DIPressureGrid_GetGridScalar(DIContext,PrevIndex,SOLID_WEIGHT_OFFSET+ComponentIndex);
					if( PrevWeight > 0.0 && PrevFraction[ComponentIndex] > 0.0)
					{
						DIPressureGrid_AddGridScalar(DIContext,PrevIndex,FLUID_VELOCITY_OFFSET+ComponentIndex,-GridPressure/PrevFraction[ComponentIndex]);
					}
					else
					{
						const float SolidVelocity = DIPressureGrid_GetGridScalar(DIContext,PrevIndex,SOLID_VELOCITY_OFFSET+ComponentIndex);
						DIPressureGrid_SetGridScalar(DIContext,PrevIndex,FLUID_VELOCITY_OFFSET+ComponentIndex,SolidVelocity);
					}

					const float NextWeight = DIPressureGrid_GetGridScalar(DIContext,NextIndex,SOLID_WEIGHT_OFFSET+ComponentIndex);
					if( NextWeight > 0.0 && NextFraction[ComponentIndex] > 0.0)
					{
						DIPressureGrid_AddGridScalar(DIContext,NextIndex,FLUID_VELOCITY_OFFSET+ComponentIndex,GridPressure/NextFraction[ComponentIndex]);
					}
					else
					{
						const float SolidVelocity = DIPressureGrid_GetGridScalar(DIContext,NextIndex,SOLID_VELOCITY_OFFSET+ComponentIndex);
						DIPressureGrid_SetGridScalar(DIContext,NextIndex,FLUID_VELOCITY_OFFSET+ComponentIndex,SolidVelocity);
					}
				}
			}
			else
			{
				DIPressureGrid_SetGridScalar(DIContext,PrevIndex,FLUID_PRESSURE_OFFSET,0.0);
			}
		}
	}

	#endif
}










