// Copyright Epic Games, Inc. All Rights Reserved.

#include "MeshTangentsTool.h"
#include "InteractiveToolManager.h"
#include "ToolBuilderUtil.h"

#include "DynamicMesh3.h"
#include "DynamicMeshToMeshDescription.h"
#include "MeshDescription.h"
#include "MeshDescriptionToDynamicMesh.h"
#include "ToolSetupUtil.h"
#include "ToolDataVisualizer.h"

#include "AssetUtils/MeshDescriptionUtil.h"
#include "Engine/Classes/Engine/StaticMesh.h"
#include "Engine/Classes/Components/StaticMeshComponent.h"

#define LOCTEXT_NAMESPACE "UMeshTangentsTool"

/*
 * ToolBuilder
 */

bool UMeshTangentsToolBuilder::CanBuildTool(const FToolBuilderState& SceneState) const
{
	return (ToolBuilderUtil::CountComponents(SceneState, CanMakeComponentTarget) == 1)
		&& (ToolBuilderUtil::CountComponents(SceneState, [&](UActorComponent* Comp) { return Cast<UStaticMeshComponent>(Comp) != nullptr; }) == 1);		
}

UInteractiveTool* UMeshTangentsToolBuilder::BuildTool(const FToolBuilderState& SceneState) const
{
	UMeshTangentsTool* NewTool = NewObject<UMeshTangentsTool>(SceneState.ToolManager);

	UActorComponent* ActorComponent = ToolBuilderUtil::FindFirstComponent(SceneState, CanMakeComponentTarget);
	check(Cast<UStaticMeshComponent>(ActorComponent) != nullptr);
	auto* MeshComponent = Cast<UPrimitiveComponent>(ActorComponent);
	check(MeshComponent != nullptr);
	NewTool->SetSelection(MakeComponentTarget(MeshComponent));
	NewTool->SetWorld(SceneState.World);

	return NewTool;
}

/*
 * Tool
 */
UMeshTangentsTool::UMeshTangentsTool()
{
}

void UMeshTangentsTool::SetWorld(UWorld* World)
{
	this->TargetWorld = World;
}



void UMeshTangentsTool::Setup()
{
	UInteractiveTool::Setup();

	// copy input MeshDescription and make sure it has initialized normals/tangents
	InputMeshDescription = MakeShared<FMeshDescription>(*ComponentTarget->GetMesh());
	UE::MeshDescription::InitializeAutoGeneratedAttributes(*InputMeshDescription, ComponentTarget->GetOwnerComponent(), 0);

	// hide input StaticMeshComponent
	ComponentTarget->SetOwnerVisibility(false);

	// make our preview mesh
	PreviewMesh = NewObject<UPreviewMesh>(this);
	PreviewMesh->bBuildSpatialDataStructure = false;
	PreviewMesh->CreateInWorld(ComponentTarget->GetOwnerActor()->GetWorld(), FTransform::Identity);
	PreviewMesh->SetTransform(ComponentTarget->GetWorldTransform());
	// configure materials
	FComponentMaterialSet MaterialSet;
	ComponentTarget->GetMaterialSet(MaterialSet);
	PreviewMesh->SetMaterials(MaterialSet.Materials);
	// initialize with meshdescription created above, that has valid tangents
	PreviewMesh->SetTangentsMode(EDynamicMeshTangentCalcType::ExternallyCalculated);
	PreviewMesh->InitializeMesh(InputMeshDescription.Get());

	// make a copy of initialized mesh and tangents
	InputMesh = MakeShared<FDynamicMesh3>(*PreviewMesh->GetMesh());
	InitialTangents = MakeShared<FMeshTangentsf>(InputMesh.Get());
	InitialTangents->CopyTriVertexTangents(*PreviewMesh->GetTangents());

	// initialize our properties
	Settings = NewObject<UMeshTangentsToolProperties>(this);
	Settings->RestoreProperties(this);
	AddToolPropertySource(Settings);

	Settings->WatchProperty(Settings->TangentType, [this](EMeshTangentsType) { Compute->InvalidateResult(); });
	Settings->WatchProperty(Settings->LineLength, [this](float) { bLengthDirty = true; });
	Settings->WatchProperty(Settings->LineThickness, [this](float) { bThicknessDirty = true; });
	Settings->WatchProperty(Settings->bShowTangents, [this](float) { bVisibilityChanged = true; });
	Settings->WatchProperty(Settings->bShowNormals, [this](float) { bVisibilityChanged = true; });

	PreviewGeometry = NewObject<UPreviewGeometry>(this);
	PreviewGeometry->CreateInWorld(ComponentTarget->GetOwnerActor()->GetWorld(), PreviewMesh->GetTransform());

	Compute = MakeUnique<TGenericDataBackgroundCompute<FMeshTangentsd>>();
	Compute->Setup(this);
	Compute->OnResultUpdated.AddLambda( [this](const TUniquePtr<FMeshTangentsd>& NewResult) { OnTangentsUpdated(NewResult); } );
	Compute->InvalidateResult();

	GetToolManager()->DisplayMessage(
		LOCTEXT("OnStartTool", "Configure or Recalculate Tangents on a Static Mesh Asset (disables autogenerated Tangents and Normals)"),
		EToolMessageLevel::UserNotification);
}



void UMeshTangentsTool::Shutdown(EToolShutdownType ShutdownType)
{
	PreviewGeometry->Disconnect();
	PreviewMesh->Disconnect();

	Settings->SaveProperties(this);

	TUniquePtr<FMeshTangentsd> Tangents = Compute->Shutdown();
	if (ShutdownType == EToolShutdownType::Accept)
	{
		GetToolManager()->BeginUndoTransaction(LOCTEXT("UpdateTangents", "Update Tangents"));

		UStaticMeshComponent* StaticMeshComponent = Cast<UStaticMeshComponent>(ComponentTarget->GetOwnerComponent());
		UStaticMesh* StaticMesh = StaticMeshComponent->GetStaticMesh();
		StaticMesh->Modify();

		// disable auto-generated normals and tangents build settings
		UE::MeshDescription::FStaticMeshBuildSettingChange SettingsChange;
		SettingsChange.AutoGeneratedNormals = UE::MeshDescription::EBuildSettingBoolChange::Disable;
		SettingsChange.AutoGeneratedTangents = UE::MeshDescription::EBuildSettingBoolChange::Disable;
		UE::MeshDescription::ConfigureBuildSettings(StaticMesh, 0, SettingsChange);

		ComponentTarget->CommitMesh([&](const FPrimitiveComponentTarget::FCommitParams& CommitParams)
		{
			FDynamicMeshToMeshDescription Converter;
			Converter.UpdateAttributes(InputMesh.Get(), *CommitParams.MeshDescription, true, false);
			Converter.UpdateTangents(InputMesh.Get(), *CommitParams.MeshDescription, Tangents.Get());
		});

		GetToolManager()->EndUndoTransaction();
	}

	// Restore (unhide) the source meshes
	ComponentTarget->SetOwnerVisibility(true);

}

void UMeshTangentsTool::OnTick(float DeltaTime)
{
	Compute->Tick(DeltaTime);

	if (bThicknessDirty || bLengthDirty || bVisibilityChanged)
	{
		UpdateVisualization(bThicknessDirty, bLengthDirty);
		bThicknessDirty = bLengthDirty = bVisibilityChanged = false;
	}
}


void UMeshTangentsTool::Render(IToolsContextRenderAPI* RenderAPI)
{
	if (Settings->bCompareWithMikkt && Deviations.Num() > 0)
	{
		FToolDataVisualizer Visualizer;
		Visualizer.BeginFrame(RenderAPI);
		Visualizer.SetTransform(PreviewMesh->GetTransform());
		for (const FMikktDeviation& ErrorPt : Deviations)
		{
			if (ErrorPt.MaxAngleDeg > Settings->AngleThreshDeg)
			{
				Visualizer.DrawPoint(ErrorPt.VertexPos, FLinearColor(0.95, 0.05, 0.05), 6 * Settings->LineThickness, false);
				Visualizer.DrawLine(ErrorPt.VertexPos, ErrorPt.VertexPos + Settings->LineLength * ErrorPt.MikktTangent, FLinearColor(0.95, 0.05, 0.05), 2 * Settings->LineThickness, false);
				Visualizer.DrawLine(ErrorPt.VertexPos, ErrorPt.VertexPos + Settings->LineLength * ErrorPt.MikktBitangent, FLinearColor(0.05, 0.95, 0.05), 2 * Settings->LineThickness, false);

				Visualizer.DrawLine(ErrorPt.VertexPos, ErrorPt.VertexPos + (1.1f*Settings->LineLength) * ErrorPt.OtherTangent, FLinearColor(0.95, 0.50, 0.05), Settings->LineThickness, false);
				Visualizer.DrawLine(ErrorPt.VertexPos, ErrorPt.VertexPos + (1.1f*Settings->LineLength) * ErrorPt.OtherBitangent, FLinearColor(0.05, 0.95, 0.95), Settings->LineThickness, false);
			}
		}
		Visualizer.EndFrame();
	}
}


bool UMeshTangentsTool::CanAccept() const
{
	return Super::CanAccept() && Compute->HaveValidResult();
}


TUniquePtr<TGenericDataOperator<FMeshTangentsd>> UMeshTangentsTool::MakeNewOperator()
{
	TUniquePtr<FCalculateTangentsOp> TangentsOp = MakeUnique<FCalculateTangentsOp>();

	TangentsOp->SourceMesh = InputMesh;
	TangentsOp->SourceTangents = InitialTangents;
	TangentsOp->CalculationMethod = Settings->TangentType;

	return TangentsOp;
}


void UMeshTangentsTool::UpdateVisualization(bool bThicknessChanged, bool bLengthChanged)
{
	ULineSetComponent* TangentLines = PreviewGeometry->FindLineSet(TEXT("Tangents"));
	ULineSetComponent* NormalLines = PreviewGeometry->FindLineSet(TEXT("Normals"));
	if (TangentLines == nullptr || NormalLines == nullptr)
	{
		return;
	}

	if (bThicknessChanged)
	{
		float Thickness = (Settings->LineThickness-2.0) / 10.0;
		TangentLines->SetAllLinesThickness(Thickness);
		NormalLines->SetAllLinesThickness(Thickness);
	}

	if (bLengthChanged)
	{
		float LineLength = Settings->LineLength;
		TangentLines->SetAllLinesLength(LineLength);
		NormalLines->SetAllLinesLength(LineLength);
	}

	PreviewGeometry->SetLineSetVisibility(TEXT("Tangents"), Settings->bShowTangents);
	PreviewGeometry->SetLineSetVisibility(TEXT("Normals"), Settings->bShowNormals);
}


void UMeshTangentsTool::OnTangentsUpdated(const TUniquePtr<FMeshTangentsd>& NewResult)
{
	float LineLength = Settings->LineLength;
	float Thickness = (Settings->LineThickness-2.0) / 10.0;

	TSet<int32> DegenerateTris;
	if (Settings->bHideDegenerates || (Settings->bCompareWithMikkt && Settings->TangentType != EMeshTangentsType::MikkTSpace) )
	{
		FMeshTangentsd DegenTangents(InputMesh.Get());
		DegenTangents.ComputeTriangleTangents(InputMesh->Attributes()->GetUVLayer(0));
		DegenerateTris = TSet<int32>(DegenTangents.GetDegenerateTris());
	}

	// update Tangents rendering line set
	PreviewGeometry->CreateOrUpdateLineSet(TEXT("Tangents"), InputMesh->MaxTriangleID(),
		[&](int32 Index, TArray<FRenderableLine>& Lines) 
	{

		if (InputMesh->IsTriangle(Index) && DegenerateTris.Contains(Index) == false)
		{
			FVector3d Verts[3];
			InputMesh->GetTriVertices(Index, Verts[0], Verts[1], Verts[2]);
			for (int j = 0; j < 3; ++j)
			{
				FVector3d Tangent, Bitangent;
				NewResult->GetPerTriangleTangent(Index, j, Tangent, Bitangent);

				Lines.Add(FRenderableLine((FVector)Verts[j], (FVector)Verts[j] + LineLength * (FVector)Tangent, FColor(240,15,15), Thickness));
				Lines.Add(FRenderableLine((FVector)Verts[j], (FVector)Verts[j] + LineLength * (FVector)Bitangent, FColor(15,240,15), Thickness));
			}
		}
	}, 6);


	// update Normals rendering line set
	const FDynamicMeshNormalOverlay* NormalOverlay = InputMesh->Attributes()->PrimaryNormals();
	PreviewGeometry->CreateOrUpdateLineSet(TEXT("Normals"), NormalOverlay->MaxElementID(),
		[&](int32 Index, TArray<FRenderableLine>& Lines) 
	{
		if (NormalOverlay->IsElement(Index))
		{
			FVector3f Normal = NormalOverlay->GetElement(Index);
			int32 ParentVtx = NormalOverlay->GetParentVertex(Index);
			FVector3f Position = (FVector3f)InputMesh->GetVertex(ParentVtx);
			Lines.Add(FRenderableLine((FVector)Position, (FVector)Position + LineLength * (FVector)Normal, FColor(15,15,240), Thickness));
		}
	}, 1);


	// calculate deviation between what we have and MikkT, if necessary
	Deviations.Reset();
	if (Settings->bCompareWithMikkt && Settings->TangentType != EMeshTangentsType::MikkTSpace)
	{
		FProgressCancel TmpCancel;
		FCalculateTangentsOp MikktOp;
		MikktOp.SourceMesh = InputMesh;
		MikktOp.CalculationMethod = EMeshTangentsType::MikkTSpace;
		MikktOp.CalculateResult(&TmpCancel);
		TUniquePtr<FMeshTangentsd> MikktTangents = MikktOp.ExtractResult();

		FCalculateTangentsOp NewOp;
		NewOp.SourceMesh = InputMesh;
		NewOp.CalculationMethod = EMeshTangentsType::FastMikkTSpace;
		NewOp.CalculateResult(&TmpCancel);
		TUniquePtr<FMeshTangentsd> NewTangents = NewOp.ExtractResult();

		for (int32 Index : InputMesh->TriangleIndicesItr())
		{
			if (DegenerateTris.Contains(Index) == false)
			{
				FVector3d Verts[3];
				InputMesh->GetTriVertices(Index, Verts[0], Verts[1], Verts[2]);
				for (int j = 0; j < 3; ++j)
				{
					FVector3d TangentMikkt, BitangentMikkt;
					MikktTangents->GetPerTriangleTangent(Index, j, TangentMikkt, BitangentMikkt);
					TangentMikkt.Normalize(); BitangentMikkt.Normalize();
					FVector3d TangentNew, BitangentNew;
					NewTangents->GetPerTriangleTangent(Index, j, TangentNew, BitangentNew);
					TangentNew.Normalize(); BitangentNew.Normalize();
					ensure(TangentMikkt.IsNormalized() && BitangentMikkt.IsNormalized());
					ensure(TangentNew.IsNormalized() && BitangentNew.IsNormalized());
					double MaxAngleDeg = FMathd::Max(TangentMikkt.AngleD(TangentNew), BitangentMikkt.AngleD(BitangentNew));
					if (MaxAngleDeg > 0.5)
					{
						FMikktDeviation Deviation{ static_cast<float>(MaxAngleDeg), Index, j, Verts[j], TangentMikkt, BitangentMikkt, TangentNew, BitangentNew };
						Deviations.Add(Deviation);
					}
				}
			}
		}
	}

	// update the tangents on the preview mesh
	PreviewMesh->UpdateTangents(NewResult.Get(), true);

	UpdateVisualization(false, false);
}


#undef LOCTEXT_NAMESPACE
