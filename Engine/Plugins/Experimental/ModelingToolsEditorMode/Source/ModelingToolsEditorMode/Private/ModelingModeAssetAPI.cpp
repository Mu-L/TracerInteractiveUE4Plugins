// Copyright Epic Games, Inc. All Rights Reserved.

#include "ModelingModeAssetAPI.h"
#include "ModelingToolsEditorModeSettings.h"
#include "MeshDescription.h"
#include "./StaticMeshComponentBuilder.h"


#define LOCTEXT_NAMESPACE "FModelingModeAssetAPI"


AActor* FModelingModeAssetAPI::GenerateStaticMeshActor(
	UWorld* TargetWorld,
	FTransform Transform,
	FString ObjectBaseName,
	FGeneratedStaticMeshAssetConfig&& AssetConfig)
{
	check(TargetWorld);

	const UModelingToolsEditorModeSettings* Settings = GetDefault<UModelingToolsEditorModeSettings>();
	EModelingModeAssetGenerationBehavior AutoGenMode = Settings->AssetGenerationMode;


	// construct the desired folder path
	FString PackageFolderPath = FPaths::Combine(TEXT("/Game/"), Settings->AutoGeneratedAssetPath);
	if (Settings->AssetGenerationLocation == EModelingModeAssetGenerationLocation::CurrentAssetBrowserPathIfAvailable)
	{
		FString CurrentAssetPath = GetActiveAssetFolderPath();
		if (CurrentAssetPath.IsEmpty() == false)
		{
			PackageFolderPath = CurrentAssetPath;
		}
	}

	// If we are in interactive mode, show the modal dialog and then get the path/name.
	// If the user cancels, we are going to discard the asset
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		FString SelectedPath = InteractiveSelectAssetPath(ObjectBaseName, LOCTEXT("GenerateStaticMeshActorPathDialogWarning", "Choose Folder Path and Name for New Asset. Cancel to Discard New Asset."));
		if (SelectedPath.IsEmpty() == false)
		{
			PackageFolderPath = FPaths::GetPath(SelectedPath);
			ObjectBaseName = FPaths::GetBaseFilename(SelectedPath, true);
		}
		else
		{
			return nullptr;
		}
	}

	// create new package
	FString UniqueAssetName;
	UPackage* AssetPackage = MakeNewAssetPackage(PackageFolderPath, ObjectBaseName, UniqueAssetName);

	// create new actor
	FRotator Rotation(0.0f, 0.0f, 0.0f);
	FActorSpawnParameters SpawnInfo;
	// @todo nothing here is specific to AStaticMeshActor...could we pass in a CDO and clone it instead of using SpawnActor?
	AStaticMeshActor* NewActor = TargetWorld->SpawnActor<AStaticMeshActor>(FVector::ZeroVector, Rotation, SpawnInfo);
	NewActor->SetActorLabel(*UniqueAssetName);

	// construct new static mesh
	FStaticMeshComponentBuilder Builder;
	Builder.Initialize(AssetPackage, FName(*UniqueAssetName), AssetConfig.Materials.Num());

	if (AssetConfig.MeshDescription.IsValid())
	{
		*Builder.MeshDescription = *AssetConfig.MeshDescription;
	}
	else
	{
		// should generate default sphere here or something...
	}

	// create new mesh component and set as root of NewActor.
	Builder.CreateAndSetAsRootComponent(NewActor);

	// configure transform and materials of new component
	Builder.NewMeshComponent->SetWorldTransform((FTransform)Transform);
	for (int MatIdx = 0, NumMats = AssetConfig.Materials.Num(); MatIdx < NumMats; MatIdx++)
	{
		Builder.NewMeshComponent->SetMaterial(MatIdx, AssetConfig.Materials[MatIdx]);
	}

	// save the new asset (or don't, if that's what the user wants)
	if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateAndAutosave )
	{ 
		AutoSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::InteractivePromptToSave)
	{
		AutoSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
		// this spawns a dialog that just allows save or not-save, but not renaming/etc, seems kind of useless...
		//InteractiveSaveGeneratedAsset(Builder.NewStaticMesh, AssetPackage);
	}
	else if (AutoGenMode == EModelingModeAssetGenerationBehavior::AutoGenerateButDoNotAutosave)
	{
		NotifyGeneratedAssetModified(Builder.NewStaticMesh, AssetPackage);
	}

	return NewActor;
}


#undef LOCTEXT_NAMESPACE