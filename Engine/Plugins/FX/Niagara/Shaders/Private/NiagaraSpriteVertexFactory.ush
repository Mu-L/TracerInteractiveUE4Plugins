// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	ParticleSpriteVertexFactory.hlsl: Particle vertex factory shader code.
	Shared by standard sprite particles and SubUV sprite particles.
=============================================================================*/

#include "/Engine/Private/VertexFactoryCommon.ush"
#include "/Engine/Private/ParticleVertexFactoryCommon.ush"
#include "NiagaraVFParticleAccess.usf"

#define USE_PARTICLE_LIGHTING_OFFSET (FEATURE_LEVEL >= FEATURE_LEVEL_SM5 && !MATERIAL_SHADINGMODEL_UNLIT)
#define USE_PARTICLE_POSITION (NEEDS_PARTICLE_POSITION || PASS_NEEDS_PRIMITIVE_VOLUME_BOUNDS)
#define USE_PARTICLE_VELOCITY (NEEDS_PARTICLE_VELOCITY)
#define USE_PARTICLE_TIME (NEEDS_PARTICLE_TIME)
#define USE_PARTICLE_SIZE (NEEDS_PARTICLE_SIZE)
#define USE_PARTICLE_RANDOM (NEEDS_PARTICLE_RANDOM)

// Must keep these in sync with ENiagaraSpriteAlignment in NiagaraSpriteRendererProperties.h
/** Only Particles.SpriteRotation and FacingMode impact the alignment of the particle.*/
#define ALIGNMENT_MODE_UNALIGNED 0
/** Imagine the particle texture having an arrow pointing up, this mode makes the arrow point in the direction of the Particles.Velocity attribute. Particles.SpriteRotation rotation is ignored.*/
#define ALIGNMENT_MODE_VELOCITYALIGNED 1
/** Imagine the particle texture having an arrow pointing up, this mode makes the arrow point towards the axis defined by the Particles.SpriteAlignment attribute, after taking Particles.SpriteRotation and the FacingMode into account.*/
#define ALIGNMENT_MODE_CUSTOMALIGNMENT 2

/** The sprite billboard origin is always "looking at" the camera origin, trying to keep its up axis aligned to the camera's up axis. */
#define FACING_MODE_FACECAMERA 0
/** The sprite billboard plane is completely parallel to the camera plane. Particle always looks "flat" */
#define FACING_MODE_FACECAMERAPLANE 1
/** The sprite billboard faces toward the "Particles.SpriteFacing" vector attribute. */
#define FACING_MODE_CUSTOMFACINGVECTOR 2
/** Faces the camera position, but is not dependent on the camera rotation.  This method produces more stable particles under camera rotation. Uses the up axis of (0,0,1).*/
#define FACING_MODE_FACECAMERAPOSITION 3 
/** Blends between FaceCamera and FaceCameraPosition.*/
#define FACING_MODE_FACECAMERADISTANCEBLEND 4

struct FVertexFactoryInput
{
	float2	TexCoord				: ATTRIBUTE0;
	uint VertexId					: SV_VertexID;
	uint InstanceId					: SV_InstanceID;
};

// RHI_RAYTRACING
#if COMPUTESHADER || RAYHITGROUPSHADER
FVertexFactoryInput LoadVertexFactoryInputForHGS(uint TriangleIndex, int VertexIndex)
{
	FVertexFactoryInput Input;
	
	uint IndexBuffer[6] = { 0, 2, 3, 0, 1, 2 };
	uint VertexId = IndexBuffer[(TriangleIndex * 3 + VertexIndex) % 6];
	float2 TexCoords[4] = { float2(0.0f, 0.0f), float2(0.0f, 1.0f), float2(1.0f, 1.0f), float2(1.0f, 0.0f) };
	Input.TexCoord = TexCoords[VertexId];
	Input.VertexId = VertexId;
	Input.InstanceId = TriangleIndex / 2;

	return Input;
}

FVertexFactoryInput LoadVertexFactoryInputForDynamicUpdate(uint TriangleIndex, int VertexIndex, uint PrimitiveId)
{
	return LoadVertexFactoryInputForHGS(TriangleIndex, VertexIndex);
}
uint GetNumRayTracingDynamicMeshVerticesIndirect()
{
	return 6 * NiagaraSpriteVFLooseParameters.IndirectArgsBuffer[NiagaraSpriteVFLooseParameters.IndirectArgsOffset + 1];
}
#endif

struct FVertexFactoryInterpolantsVSToPS
{
	// First row of the tangent to world matrix, Interp_Sizer used by SUBUV_PARTICLES in w
	float4	TangentToWorld0AndInterp_Sizer : TANGENTTOWORLD0;
	// Last row of the tangent to world matrix in xyz
	float4	TangentToWorld2	: TANGENTTOWORLD2;
	
#if (DYNAMIC_PARAMETERS_MASK & 1)
	nointerpolation float4 DynamicParameter	: PARTICLE_DYNAMIC_PARAM0;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	nointerpolation float4 DynamicParameter1 : PARTICLE_DYNAMIC_PARAM1;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	nointerpolation float4 DynamicParameter2 : PARTICLE_DYNAMIC_PARAM2;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	nointerpolation float4 DynamicParameter3 : PARTICLE_DYNAMIC_PARAM3;
#endif

#if NEEDS_PARTICLE_COLOR
	float4	Color				: TEXCOORD0;
#endif

#if NUM_TEX_COORD_INTERPOLATORS
	float4	TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2]	: TEXCOORD1;
#endif

	//Not sure this is actually being used now and it's awkward to slot in now we're supporting custom UVs so I'm just giving this its own interpolant.
#if LIGHTMAP_UV_ACCESS
	float2 LightMapUVs : LIGHTMAP_UVS;
#endif

#if USE_PARTICLE_SUBUVS
	float4 ParticleSubUVs : PARTICLE_SUBUVS;
#endif

#if USE_PARTICLE_POSITION
	/** Cam-relative (translated) particle center and radius */
	nointerpolation float4 ParticleTranslatedWorldPositionAndSize	: PARTICLE_POSITION;
#endif

#if USE_PARTICLE_VELOCITY
	nointerpolation float4 ParticleVelocity : PARTICLE_VELOCITY;
#endif

#if USE_PARTICLE_TIME
	nointerpolation float RelativeTime : PARTICLE_TIME;
#endif

#if USE_PARTICLE_LIGHTING_OFFSET
	float3 LightingPositionOffset : PARTICLE_LIGHTING_OFFSET;
#endif

#if USE_PARTICLE_SIZE
	nointerpolation float2 ParticleSize : PARTICLE_SIZE;
#endif

#if USE_PARTICLE_RANDOM
	nointerpolation float ParticleRandom : PARTICLE_RANDOM;
#endif

#if INSTANCED_STEREO
	nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

struct FVertexFactoryIntermediates
{
	/** The position of the vertex in translated world space. */
	float3 VertexWorldPosition;
	/** Last frame's position of the vertex in translated world space. */
	float3 PreviousVertexWorldPosition;
	/** Particle translated world space position and size. */
	float4 TranslatedWorldPositionAndSize;
	
#if USE_PARTICLE_LIGHTING_OFFSET
	float3 LightingPositionOffset;
#endif

	/** The texture coordinate at this vertex. */
	float4 TexCoord;
#if NUM_MATERIAL_TEXCOORDS >= 3 //Unflipped UVs are placed in UVs 2-3
	/** A second UV set. Always non-UV flipped. Allows use of UV flipping with Normal maps etc. */
	float4 TexCoord_Unflipped;
#endif
	/** The sprite tangent in world space (+V). */
	float3 TangentUp;
	/** The sprite tangent in world space (+U). */
	float3 TangentRight;
	/** The color of the sprite. */
	float4 Color;
	/** The velocity of the particle, XYZ: direction, W: speed. */
	float4 ParticleVelocity;

	/** The particle worldspace position */
	float3 Position;
	float3 OldPosition;
	
	float4 SizeRotSubImage;
	
	float3 CustomFacingVector;
	float3 CustomAlignmentVector;

#if (DYNAMIC_PARAMETERS_MASK & 1)
	float4 DynamicParameter;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	float4 DynamicParameter1;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	float4 DynamicParameter2;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	float4 DynamicParameter3;
#endif

	/** The sub-image lerp. */
	float SubImageLerp;

#if USE_PARTICLE_TIME
	/** Relative time. */
	float RelativeTime;
#endif

	/** Transform from tangent space to local space. */
	float3x3 TangentToLocal;
	/** Size of the particle */
	float2 ParticleSize;

#if USE_PARTICLE_RANDOM
	/** Particle Random value */
	float ParticleRandom;
#endif
};

#if NUM_TEX_COORD_INTERPOLATORS
bool UVIndexUseZW(int UVIndex)
{
	return (UVIndex % 2) != 0;
}

float2 GetUV(FVertexFactoryInterpolantsVSToPS Interpolants, int UVIndex)
{
	float4 UVVector = Interpolants.TexCoords[UVIndex / 2];
	return UVIndexUseZW(UVIndex) ? UVVector.zw : UVVector.xy;
}

void SetUV(inout FVertexFactoryInterpolantsVSToPS Interpolants, int UVIndex, float2 InValue)
{
	FLATTEN
	if (UVIndexUseZW(UVIndex))
	{
		Interpolants.TexCoords[UVIndex / 2].zw = InValue;
	}
	else
	{
		Interpolants.TexCoords[UVIndex / 2].xy = InValue;
	}
}
#endif

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
	// GetMaterialPixelParameters is responsible for fully initializing the result
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NUM_TEX_COORD_INTERPOLATORS
	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = GetUV(Interpolants, CoordinateIndex);
	}
#endif	// NUM_TEX_COORD_INTERPOLATORS

	Result.VertexColor = 1;

	half4 TangentToWorld0 = Interpolants.TangentToWorld0AndInterp_Sizer;
	half4 TangentToWorld2 = Interpolants.TangentToWorld2;
	float SubImageLerp = Interpolants.TangentToWorld0AndInterp_Sizer.w;

	#if GENERATE_SPHERICAL_PARTICLE_NORMALS && USE_PARTICLE_POSITION
		{	
			// can be optimized
			float4 ScreenPosition = SvPositionToResolvedScreenPosition(SvPosition);
			float3 TranslatedWorldPosition = SvPositionToResolvedTranslatedWorld(SvPosition);
			Result.TangentToWorld = GetSphericalParticleNormal(TranslatedWorldPosition, Interpolants.ParticleTranslatedWorldPositionAndSize.xyz, Interpolants.ParticleTranslatedWorldPositionAndSize.w);
		}
	#else
		Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0.xyz, TangentToWorld2);
	#endif

	Result.UnMirrored = 1;
	Result.Particle.MacroUV = NiagaraSpriteVF.MacroUVParameters;

#if NEEDS_PARTICLE_COLOR
	Result.Particle.Color = Interpolants.Color;
#endif

#if (DYNAMIC_PARAMETERS_MASK != 0)
	Result.Particle.DynamicParameterValidMask = NiagaraSpriteVF.MaterialParamValidMask;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 1)
	Result.Particle.DynamicParameter = Interpolants.DynamicParameter;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	Result.Particle.DynamicParameter1 = Interpolants.DynamicParameter1;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	Result.Particle.DynamicParameter2 = Interpolants.DynamicParameter2;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	Result.Particle.DynamicParameter3 = Interpolants.DynamicParameter3;
#endif

#if USE_PARTICLE_POSITION
	Result.Particle.TranslatedWorldPositionAndSize = Interpolants.ParticleTranslatedWorldPositionAndSize;
#endif

#if USE_PARTICLE_VELOCITY
	Result.Particle.Velocity = Interpolants.ParticleVelocity;
#endif

#if USE_PARTICLE_TIME
	Result.Particle.RelativeTime = Interpolants.RelativeTime;
#endif

	Result.Particle.MotionBlurFade = 1.0f;


#if USE_PARTICLE_LIGHTING_OFFSET
	Result.LightingPositionOffset = Interpolants.LightingPositionOffset;
#endif

#if USE_PARTICLE_SUBUVS
	Result.Particle.SubUVCoords[0] = Interpolants.ParticleSubUVs.xy;
	Result.Particle.SubUVCoords[1] = Interpolants.ParticleSubUVs.zw;
	Result.Particle.SubUVLerp = SubImageLerp;
#endif

#if LIGHTMAP_UV_ACCESS
	Result.LightmapUVs = Interpolants.LightMapUVs;
#endif

#if USE_PARTICLE_SIZE
	Result.Particle.Size = Interpolants.ParticleSize;
#endif

#if USE_PARTICLE_RANDOM
	Result.Particle.Random = Interpolants.ParticleRandom;
#else
	Result.Particle.Random = 0.0f;
#endif

	Result.TwoSidedSign = 1;
	return Result;
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, float3x3 TangentToLocal)
{
	FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
	Result.WorldPosition = WorldPosition;
	Result.VertexColor = Intermediates.Color;
	Result.TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3()); 
	Result.Particle.MacroUV = NiagaraSpriteVF.MacroUVParameters;
	Result.Particle.Color = Intermediates.Color;
	Result.Particle.MotionBlurFade = 1.0f;
	Result.PreSkinnedPosition = Intermediates.Position.xyz;
	Result.PreSkinnedNormal = TangentToLocal[2].xyz;

	// Previous frame not handled deliberately. Lacks necessary information and
	// primitives using this VF are usually transparent and hence don't output velocity
	Result.PrevFrameLocalToWorld = float4x4(float4(1.0f, 0.0f, 0.0f, 0.0f), float4(0.0f, 1.0f, 0.0f, 0.0f), float4(0.0f, 0.0f, 1.0f, 0.0f), float4(0.0f, 0.0f, 0.0f, 1.0f));

#if (DYNAMIC_PARAMETERS_MASK != 0)
	Result.Particle.DynamicParameterValidMask = NiagaraSpriteVF.MaterialParamValidMask;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 1)
	Result.Particle.DynamicParameter = Intermediates.DynamicParameter;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	Result.Particle.DynamicParameter1 = Intermediates.DynamicParameter1;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	Result.Particle.DynamicParameter2 = Intermediates.DynamicParameter2;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	Result.Particle.DynamicParameter3 = Intermediates.DynamicParameter3;
#endif

#if USE_PARTICLE_POSITION
	Result.Particle.TranslatedWorldPositionAndSize = Intermediates.TranslatedWorldPositionAndSize;
#endif

#if USE_PARTICLE_VELOCITY
	Result.Particle.Velocity = Intermediates.ParticleVelocity;
#endif

#if USE_PARTICLE_TIME
	Result.Particle.RelativeTime = Intermediates.RelativeTime;
#endif

#if USE_PARTICLE_RANDOM
	Result.Particle.Random = Intermediates.ParticleRandom;
#else
	Result.Particle.Random = 0.0f;
#endif

#if NUM_MATERIAL_TEXCOORDS_VERTEX
	#if NUM_MATERIAL_TEXCOORDS_VERTEX >= 1
		Result.TexCoords[0] = Intermediates.TexCoord.xy;
	#if NUM_MATERIAL_TEXCOORDS_VERTEX >= 2
		Result.TexCoords[1] = Intermediates.TexCoord.zw;
	#if NUM_MATERIAL_TEXCOORDS_VERTEX >= 3
		Result.TexCoords[2] = Intermediates.TexCoord_Unflipped.xy;
	#if NUM_MATERIAL_TEXCOORDS_VERTEX >= 4
		Result.TexCoords[3] = Intermediates.TexCoord_Unflipped.zw;
	#endif	// >= 4
	#endif	// >= 3
	#endif	// >= 2
	#endif	// >= 1
#endif	//NUM_MATERIAL_TEXCOORDS_VERTEX

#if USE_PARTICLE_SUBUVS
	Result.Particle.SubUVCoords[0] = Intermediates.TexCoord.xy;
	Result.Particle.SubUVCoords[1] = Intermediates.TexCoord.zw;
#endif

#if USE_PARTICLE_SIZE
	Result.Particle.Size = Intermediates.ParticleSize;
#endif
	return Result;
}

float3 SafeNormalize(float3 V)
{
	// NOTE: Use a very low threshold, close to machine-epsilon when used on near-unit-length vectors. 
	//       This is primarily to avoid division-by-zero, so we can use a small constant and let things blow up slightly
	//       on very small vectors, which won't work very well anyway. 
	float L = length(V);
	return V = V / max(L, 0.000001); 
}

float3 SafeNormalizeWithFallback(float3 V, float3 Fallback)
{
	float L = length(V);
	return L > 0.000001 ? V / L : Fallback; 
}

void GetTangents(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 ParticleDirection, out float3 OutRight, out float3 OutUp)
{
	// Select camera up/right vectors.
	float3 ResolvedViewRight = lerp(ResolvedView.ViewRight, ResolvedView.HMDViewNoRollRight, NiagaraSpriteVF.RemoveHMDRoll);
	float3 ResolvedViewUp = lerp(ResolvedView.ViewUp, ResolvedView.HMDViewNoRollUp, NiagaraSpriteVF.RemoveHMDRoll);

	// The standard camera facing vectors
	float3 CameraRight = ResolvedViewRight;
	float3 CameraUp = -ResolvedViewUp;
	float3 CameraFacingVector = -ResolvedView.ViewForward;

	// Determine the vector from the particle to the camera and the particle's movement direction.
	const float3 CameraVector = ResolvedView.WorldCameraOrigin - Intermediates.Position;
	const float3 CameraDirection = SafeNormalize(CameraVector);

	float3 CustomFacingVector = NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_CUSTOMFACINGVECTOR ? Intermediates.CustomFacingVector : CameraDirection;
	
	// the particle's movement direction.
	float3 DirectionVector	= lerp(ParticleDirection, Intermediates.CustomAlignmentVector, NiagaraSpriteVFLooseParameters.ParticleAlignmentMode == ALIGNMENT_MODE_CUSTOMALIGNMENT);
	
	// Tangent vectors for any non-default alignment mode.
	float3 CameraRightAligned	= SafeNormalize(cross(CustomFacingVector, DirectionVector));
	float3 CameraUpAligned = lerp(-DirectionVector, cross(CustomFacingVector, CameraRightAligned), NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_CUSTOMFACINGVECTOR);

	// Tangent vectors for camera plane facing mode
	float3 CameraRightPlaneFacing = SafeNormalize(cross(CameraFacingVector,ResolvedViewUp));
	float3 CameraUpPlaneFacing = cross(CameraFacingVector, CameraRightPlaneFacing);

	// Tangent vectors for camera custom facing mode
	float3 CameraRightCustomFacing = SafeNormalize(cross(CustomFacingVector,ResolvedViewUp));
	float3 CameraUpCustomFacing = cross(CustomFacingVector, CameraRightCustomFacing);

	// Tangent vectors for camera facing position.
	float3 CameraRightPosition = SafeNormalize(cross(CameraDirection,float3(0,0,1)));
	float3 CameraUpPosition = cross(CameraDirection, CameraRightPosition);

	float3 Right;
	float3 Up;
	
	/**This could well be better as a branch*/
	BRANCH
	if(NiagaraSpriteVFLooseParameters.ParticleAlignmentMode == ALIGNMENT_MODE_UNALIGNED)
	{
		FLATTEN
		if (NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_FACECAMERADISTANCEBLEND)
		{
			float CameraDistanceSq = dot(CameraVector, CameraVector);
			float Interp = saturate(CameraDistanceSq * NiagaraSpriteVF.CameraFacingBlend.y - NiagaraSpriteVF.CameraFacingBlend.z);
			Right = cross(CameraDirection,float3(0,0,1));
			Up = cross(CameraDirection, Right);
			Right = lerp(Right, CameraRight.xyz, Interp);
			Up = lerp(Up, CameraUp.xyz, Interp);
		} 
		else if(NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_FACECAMERA)
		{
			Right = CameraRight.xyz;
			Up = CameraUp.xyz;
		}		 
		else if(NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_FACECAMERAPLANE)
		{
			Right = CameraRightPlaneFacing;
			Up = CameraUpPlaneFacing;
		}
		else if(NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_CUSTOMFACINGVECTOR)
		{
			Right = CameraRightCustomFacing;
			Up = CameraUpCustomFacing;
		}
		else//(NiagaraSpriteVFLooseParameters.ParticleFacingMode == FACING_MODE_FACECAMERAPOSITION)
		{
			Right = CameraRightPosition;
			Up = CameraUpPosition;
		}
	}
	else 
	{	
		Right = CameraRightAligned;
		Up = CameraUpAligned;
	}


	// Determine the angle of rotation.
	float SinRotation;
	float CosRotation;
	const float SpriteRotation = Intermediates.SizeRotSubImage.z * NiagaraSpriteVF.RotationScale + NiagaraSpriteVF.RotationBias;
	sincos(SpriteRotation, SinRotation, CosRotation);

	float3 SR = Right * SinRotation;
	float3 SU = Up * SinRotation;
	float3 CR = Right * CosRotation;
	float3 CU = Up * CosRotation;
	OutRight = SU + CR;
	OutUp = CU - SR;
}

/** derive basis vectors */
float3x3 CalcTangentBasis(FVertexFactoryIntermediates Intermediates)
{
	// Using camera facing TangentX and TangentY.  The resulting tangent basis is not orthonormal with anything other than ENM_CameraFacing, 
	// So there are artifacts with tangent space calculations like the TransformVector node,
	// But this allows lighting based on a world space shape via the normal while still having normal maps camera aligned.
	float3x3 Result;
	Result[0] = Intermediates.TangentRight;
	Result[1] = Intermediates.TangentUp;

	// ENM_CameraFacing
	//@todo - use static branching
	if (NiagaraSpriteVF.NormalsType < .5f)
	{
		Result[2] = normalize(cross(Result[0],Result[1]));
	} 
	// ENM_Spherical
	else if (NiagaraSpriteVF.NormalsType < 1.5f)
	{
		float3 TangentZ = normalize(Intermediates.Position - NiagaraSpriteVF.NormalsSphereCenter.xyz);
		Result[2] = TangentZ;	
	}
	// ENM_Cylindrical
	else
	{
		float3 ClosestPointOnCylinder = NiagaraSpriteVF.NormalsSphereCenter.xyz + dot(NiagaraSpriteVF.NormalsCylinderUnitDirection.xyz, Intermediates.Position - NiagaraSpriteVF.NormalsSphereCenter.xyz) * NiagaraSpriteVF.NormalsCylinderUnitDirection.xyz;
		float3 TangentZ = normalize(Intermediates.Position - ClosestPointOnCylinder);
		Result[2] = TangentZ;	
	}

	return Result;
}

void ComputeBillboardUVs(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, out float2 UVForPosition, out float2 UVForTexturing, out float2 UVForTexturingUnflipped)
{
	// Encoding the UV flip in the sign of the size data.
	float2 UVFlip = sign(Intermediates.SizeRotSubImage.xy);

#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4
	BRANCH
	if (NiagaraSpriteVFLooseParameters.NumCutoutVerticesPerFrame > 0)
	{
		// Avoid uint divide which is extremely slow on GCN
		const uint VertexIndexMask = NiagaraSpriteVFLooseParameters.NumCutoutVerticesPerFrame == 8 ? 7 : 3; // BVC_FourVertices || BVC_EightVertices
		uint CutoutVertexIndex = Input.VertexId & VertexIndexMask;
		float NumFrames = NiagaraSpriteVF.SubImageSize.x * NiagaraSpriteVF.SubImageSize.y;
		uint SubImageIndexInt = (uint)fmod(Intermediates.SizeRotSubImage.w, NumFrames);

		FLATTEN
		if (UVFlip.x * UVFlip.y < 0)
		{
			// Reverse the winding order of the polygon when only flipping in one direction to counteract UV flipping
			CutoutVertexIndex = NiagaraSpriteVFLooseParameters.NumCutoutVerticesPerFrame - 1 - CutoutVertexIndex;
		}

		// Fetch the billboard space positions from the appropriate frame of the preprocessed cutout geometry
		UVForTexturing = UVForTexturingUnflipped = NiagaraSpriteVFLooseParameters.CutoutGeometry[SubImageIndexInt * NiagaraSpriteVFLooseParameters.NumCutoutVerticesPerFrame + CutoutVertexIndex];

		// Invert positions on the billboard so that the cutout geometry still contains the visible portion
		// This changes the winding order when only one direction is flipped
		UVForPosition.x = UVFlip.x < 0.0 ? 1.0 - UVForTexturing.x : UVForTexturing.x;
		UVForPosition.y = UVFlip.y < 0.0 ? 1.0 - UVForTexturing.y : UVForTexturing.y;
	}
	else
#endif
	{
		UVForTexturing.x = UVFlip.x < 0.0 ? 1.0 - Input.TexCoord.x : Input.TexCoord.x;
		UVForTexturing.y = UVFlip.y < 0.0 ? 1.0 - Input.TexCoord.y : Input.TexCoord.y;

		// Note: not inverting positions, as that would change the winding order
		UVForPosition = UVForTexturingUnflipped = Input.TexCoord.xy;
	}
}

float3 TransformPosition(float3 InPosition)
{
	if (NiagaraSpriteVF.bLocalSpace)
	{
		return TransformLocalToWorld(InPosition).xyz;
	}
	else
	{
		return InPosition;
	}
}

float3 TransformPrevPosition(float3 InPosition)
{
	if (NiagaraSpriteVF.bLocalSpace)
	{
		return mul(float4(InPosition,1), Primitive.PreviousLocalToWorld).xyz;
	}
	else
	{
		return InPosition;
	}
}

float3 TransformVector(float3 InVector)
{
	if (NiagaraSpriteVF.bLocalSpace)
	{
		return RotateLocalToWorld(InVector);
	}
	else
	{
		return InVector;
	}
}

/*********************************************************************************
 *							Particle specific
 *********************************************************************************/

float3 GetNiagaraParticlePosition(uint InstanceID)
{
	if(NiagaraSpriteVF.PositionDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return TransformPosition(NiagaraSpriteVF.DefaultPos.xyz);
	}
	return TransformPosition(GetVec3(NiagaraSpriteVF.PositionDataOffset, InstanceID));
}
float3 GetNiagaraParticlePrevPosition(uint InstanceID)
{
	if(NiagaraSpriteVF.PositionDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return TransformPrevPosition(NiagaraSpriteVF.DefaultPos.xyz);
	}
	return TransformPrevPosition(GetVec3(NiagaraSpriteVF.PositionDataOffset, InstanceID));
}
float3 GetNiagaraParticleVelocity(uint InstanceID)
{
	if(NiagaraSpriteVF.VelocityDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return TransformVector(float3(0.0f,0.0f,0.0f));
	}
	return TransformVector(GetVec3(NiagaraSpriteVF.VelocityDataOffset, InstanceID));
}
float2 GetNiagaraParticleSize(uint InstanceID)
{
	if(NiagaraSpriteVF.SizeDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return float2(50.0f, 50.0f);
	}
	return GetVec2(NiagaraSpriteVF.SizeDataOffset, InstanceID);
}
float GetNiagaraParticleRotation(uint InstanceID)
{
	if(NiagaraSpriteVF.RotationDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return 0.0f;
	}
	return (GetFloat(NiagaraSpriteVF.RotationDataOffset, InstanceID) / 180.0f) * PI;
}
float4 GetNiagaraParticleColor(uint InstanceID)
{
	if(NiagaraSpriteVF.ColorDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return float4(1.0f, 1.0f, 1.0f, 1.0f);
	}
	return GetVec4(NiagaraSpriteVF.ColorDataOffset, InstanceID);
}

float2 GetNiagaraUVScale(uint InstanceID)
{
	if(NiagaraSpriteVF.UVScaleDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return float2(1.0f, 1.0f);
	}
	return GetVec2(NiagaraSpriteVF.UVScaleDataOffset, InstanceID);	
}

float GetNiagaraParticleRandom(uint InstanceID)
{
	if(NiagaraSpriteVF.MaterialRandomDataOffset  == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return 0.0f;
	}
	return GetFloat(NiagaraSpriteVF.MaterialRandomDataOffset, InstanceID);	
}

float GetNiagaraCameraOffset(uint InstanceID)
{
	if (NiagaraSpriteVF.CameraOffsetDataOffset == -1)
	{
		// See FNiagaraConstants for a synchronized value...
		return 0.0f;
	}
	return GetFloat(NiagaraSpriteVF.CameraOffsetDataOffset, InstanceID);
}

#if USE_PARTICLE_TIME
float GetNiagaraNormalizedAge(uint InstanceID)
{
	if (NiagaraSpriteVF.NormalizedAgeDataOffset == -1)
	{
		return 0;
	}
	return GetFloat(NiagaraSpriteVF.NormalizedAgeDataOffset, InstanceID);
}
#endif

#if (DYNAMIC_PARAMETERS_MASK & 1)
float4 GetNiagaraParticleDynamicParameters(uint InstanceID)
{
	if (NiagaraSpriteVF.MaterialParamDataOffset != -1)
	{
		return GetVec4(NiagaraSpriteVF.MaterialParamDataOffset, InstanceID);
	}
	else
	{
		return float4(1.0f, 1.0f, 1.0f, 1.0f);;
	}
}
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
float4 GetNiagaraParticleDynamicParameters1(uint InstanceID)
{
	if (NiagaraSpriteVF.MaterialParam1DataOffset != -1)
	{
		return GetVec4(NiagaraSpriteVF.MaterialParam1DataOffset, InstanceID);
	}
	else
	{
		return float4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
float4 GetNiagaraParticleDynamicParameters2(uint InstanceID)
{
	if (NiagaraSpriteVF.MaterialParam2DataOffset != -1)
	{
		return GetVec4(NiagaraSpriteVF.MaterialParam2DataOffset, InstanceID);
	}
	else
	{
		return float4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
float4 GetNiagaraParticleDynamicParameters3(uint InstanceID)
{
	if (NiagaraSpriteVF.MaterialParam3DataOffset != -1)
	{
		return GetVec4(NiagaraSpriteVF.MaterialParam3DataOffset, InstanceID);
	}
	else
	{
		return float4(1.0f, 1.0f, 1.0f, 1.0f);
	}
}
#endif


float GetNiagaraParticleSubimage(uint InstanceID)
{
	// See FNiagaraConstants for a synchronized value...
	float Val = 0.0f;
    if(NiagaraSpriteVF.SubimageDataOffset != -1)
	{
		Val = GetFloat(NiagaraSpriteVF.SubimageDataOffset, InstanceID);
	}
	return Val;
}

float3 GetNiagaraParticleFacingVector(uint InstanceID)
{
	// See FNiagaraConstants for a synchronized value...
	float3 Val = float3(1.0f, 0.0f, 0.0f);
    if(NiagaraSpriteVF.FacingDataOffset != -1)
	{
		Val = GetVec3(NiagaraSpriteVF.FacingDataOffset, InstanceID);
	}
	return TransformVector(Val);
}

float3 GetNiagaraParticleAlignmentVector(uint InstanceID)
{
	float3 Val = float3(1.0f, 0.0f, 0.0f);
    if(NiagaraSpriteVF.AlignmentDataOffset != -1)
	{
		Val = GetVec3(NiagaraSpriteVF.AlignmentDataOffset, InstanceID);
	}
	return TransformVector(Val);
}


FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
	uint ParticleID = Input.InstanceId;

#if !SHADOW_DEPTH_SHADER && !SPHERICAL_OPACITY_FOR_SHADOW_DEPTHS
	// Don't use sort buffer in the shadow because they are only valid after opaque.
	if(NiagaraSpriteVFLooseParameters.SortedIndicesOffset != 0xFFFFFFFF)
	{
		ParticleID = NiagaraSpriteVFLooseParameters.SortedIndices[NiagaraSpriteVFLooseParameters.SortedIndicesOffset + Input.InstanceId];
	}
#endif

	float2 ParticleSize = GetNiagaraParticleSize(ParticleID);
	Intermediates.SizeRotSubImage = float4(ParticleSize.x, ParticleSize.y, GetNiagaraParticleRotation(ParticleID), GetNiagaraParticleSubimage(ParticleID));
	Intermediates.Color	= GetNiagaraParticleColor(ParticleID);
	Intermediates.CustomFacingVector = SafeNormalize(GetNiagaraParticleFacingVector(ParticleID));
	Intermediates.CustomAlignmentVector = SafeNormalize(GetNiagaraParticleAlignmentVector(ParticleID));

#if (DYNAMIC_PARAMETERS_MASK & 1)
	Intermediates.DynamicParameter = GetNiagaraParticleDynamicParameters(ParticleID);
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	Intermediates.DynamicParameter1 = GetNiagaraParticleDynamicParameters1(ParticleID);
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	Intermediates.DynamicParameter2 = GetNiagaraParticleDynamicParameters2(ParticleID);
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	Intermediates.DynamicParameter3 = GetNiagaraParticleDynamicParameters3(ParticleID);
#endif

	// Particle world position, before any sprite aligment.
	Intermediates.Position = GetNiagaraParticlePosition(ParticleID);

	const float3 ParticleVelocity = GetNiagaraParticleVelocity(ParticleID);

	// Tangents.
	{
		const float3 ParticleDirection = SafeNormalizeWithFallback(ParticleVelocity, float3(0,0,1));
		float3 Right,Up;

		GetTangents(Input, Intermediates, ParticleDirection, Right, Up);
		Intermediates.TangentUp = Up;
		Intermediates.TangentRight = Right;
	}

	float2 UVForPosition;
	float2 UVForTexturing;
	float2 UVForTexturingUnflipped;
	ComputeBillboardUVs(Input, Intermediates, UVForPosition, UVForTexturing, UVForTexturingUnflipped);

	const float2 UVScale = GetNiagaraUVScale(ParticleID);
	UVForTexturing.xy = float2(0.5f, 0.5f) + (UVForTexturing.xy - float2(0.5f, 0.5f) ) *  UVScale.xy; 
	const float2 Size = abs(Intermediates.SizeRotSubImage.xy);

	// Vertex position and prev vertex position.
	{
		// Do we need the hack that forces particles at the camera origin to be *really* behind the camera origin?
		const float3 CameraOffset = SafeNormalize(ResolvedView.WorldCameraOrigin - Intermediates.Position) * GetNiagaraCameraOffset(ParticleID);

		const float2x3 Tangents = float2x3(Intermediates.TangentRight, Intermediates.TangentUp);
		const float3 VertexOffset = CameraOffset + mul(Size * (UVForPosition + NiagaraSpriteVF.PivotOffset), Tangents);

		Intermediates.VertexWorldPosition = Intermediates.Position + VertexOffset;
		Intermediates.PreviousVertexWorldPosition = GetNiagaraParticlePrevPosition(ParticleID) + VertexOffset + ParticleVelocity * NiagaraSpriteVF.DeltaSeconds;

#if USE_PARTICLE_POSITION
		// Do we really want the camera offset here ? What about when GENERATE_SPHERICAL_PARTICLE_NORMALS
		Intermediates.TranslatedWorldPositionAndSize.xyz = Intermediates.Position + CameraOffset + ResolvedView.PreViewTranslation;
		Intermediates.TranslatedWorldPositionAndSize.w = .5f * min(Size.x, Size.y);
#if GENERATE_SPHERICAL_PARTICLE_NORMALS
		// Recenter the particle position for GENERATE_SPHERICAL_PARTICLE_NORMALS to use the right center.
		Intermediates.TranslatedWorldPositionAndSize.xyz += mul(Size * (float2(.5, .5) + NiagaraSpriteVF.PivotOffset), Tangents);
#endif // GENERATE_SPHERICAL_PARTICLE_NORMALS
#endif // USE_PARTICLE_POSITION
	}
	
	// SubUV.
	float SubImageIndex = Intermediates.SizeRotSubImage.w;
	float SubImageLerp = frac(SubImageIndex);
	float SubImageA = SubImageIndex - SubImageLerp;
	float SubImageB = SubImageA + 1;
	float SubImageAH = fmod( SubImageA, NiagaraSpriteVF.SubImageSize.x );
	float SubImageBH = fmod( SubImageB, NiagaraSpriteVF.SubImageSize.x );
	float SubImageAV = floor( SubImageA * NiagaraSpriteVF.SubImageSize.z );
	float SubImageBV = floor( SubImageB * NiagaraSpriteVF.SubImageSize.z );
	Intermediates.TexCoord.xy = (float2( SubImageAH, SubImageAV ) + UVForTexturing) * NiagaraSpriteVF.SubImageSize.zw;
	Intermediates.TexCoord.zw = (float2(SubImageBH, SubImageBV) + UVForTexturing) * NiagaraSpriteVF.SubImageSize.zw;
#if NUM_MATERIAL_TEXCOORDS >= 3
	Intermediates.TexCoord_Unflipped.xy = (float2(SubImageAH, SubImageAV) + UVForTexturingUnflipped) * NiagaraSpriteVF.SubImageSize.zw;
	Intermediates.TexCoord_Unflipped.zw = (float2(SubImageBH, SubImageBV) + UVForTexturingUnflipped) * NiagaraSpriteVF.SubImageSize.zw;
#endif
	Intermediates.SubImageLerp = (NiagaraSpriteVF.SubImageBlendMode == 1) ? SubImageLerp : 0.0f;

#if USE_PARTICLE_VELOCITY
	{
		const float3 DirectionVector = NiagaraSpriteVFLooseParameters.ParticleAlignmentMode == ALIGNMENT_MODE_CUSTOMALIGNMENT ? Intermediates.CustomAlignmentVector : ParticleVelocity;
		Intermediates.ParticleVelocity.xyz = normalize(DirectionVector);
		Intermediates.ParticleVelocity.w = length(DirectionVector);
	}
#endif

#if USE_PARTICLE_TIME
	Intermediates.RelativeTime = GetNiagaraNormalizedAge(ParticleID);
#endif

#if USE_PARTICLE_RANDOM
	Intermediates.ParticleRandom = GetNiagaraParticleRandom(ParticleID);
#endif

	Intermediates.TangentToLocal = CalcTangentBasis(Intermediates);

#if USE_PARTICLE_LIGHTING_OFFSET && USE_PARTICLE_RANDOM
	// Hash function based on the particle ID to generate a uniformly distributed 3d offset
	float3 RandomParticleOffset = frac(Square(Intermediates.ParticleRandom * 47 + 10) * float3(1361.456345, 2333.578, 3623.983)) * 2 - 1;
	Intermediates.LightingPositionOffset = .5f * View.TranslucencyLightingVolumeInvSize[0].w * RandomParticleOffset;
#endif

#if USE_PARTICLE_SIZE
	Intermediates.ParticleSize = Size;
#endif

	return Intermediates;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(Intermediates.VertexWorldPosition + ResolvedView.PreViewTranslation, 1);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return CalcTangentBasis(Intermediates)[2].xyz;
}

float4 VertexFactoryGetRasterizedWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float4 TranslatedWorldPosition)
{
#if SPHERICAL_PARTICLE_OPACITY
	// For particles using spherical opacity, move the quad toward the viewer so that it lies in front of the sphere defined by the particle
	// This avoids opaque objects intersecting the particle from causing clipping artifacts due to depth testing
	// The downside is that the particle will clip the near plane sooner

	float Radius = .5f * min(Intermediates.SizeRotSubImage.x, Intermediates.SizeRotSubImage.y);
	return ReprojectPosition(TranslatedWorldPosition, Radius);
#else
	return TranslatedWorldPosition;
#endif
}

float3 VertexFactoryGetPositionForVertexLighting(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 TranslatedWorldPosition)
{
#if (TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
	// Do per-vertex lighting with particle position instead of vertex position when we're using SubUV cutouts, since the vertex positions vary per-frame which would cause popping
	return NiagaraSpriteVFLooseParameters.NumCutoutVerticesPerFrame > 0 ? (Intermediates.Position + ResolvedView.PreViewTranslation.xyz) : TranslatedWorldPosition;
#else
	return TranslatedWorldPosition;
#endif
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants;

	// Initialize the whole struct to 0
	Interpolants = (FVertexFactoryInterpolantsVSToPS)0;

#if NUM_TEX_COORD_INTERPOLATORS
	float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
	GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
	GetCustomInterpolators(VertexParameters, CustomizedUVs);

	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		SetUV(Interpolants, CoordinateIndex, CustomizedUVs[CoordinateIndex]);
	}
#endif

#if LIGHTMAP_UV_ACCESS
	Interpolants.LightMapUVs = Intermediates.TexCoord.xy;
#endif

#if USE_PARTICLE_SUBUVS
	Interpolants.ParticleSubUVs.xy = VertexParameters.Particle.SubUVCoords[0];
	Interpolants.ParticleSubUVs.zw = VertexParameters.Particle.SubUVCoords[1];
#endif

	// Calculate the transform from tangent to world space.
	// Note that "local" space for particles is actually oriented in world space! Therefore no rotation is needed.
	float3x3 TangentToWorld = Intermediates.TangentToLocal;

	Interpolants.TangentToWorld0AndInterp_Sizer.xyz = TangentToWorld[0];
	Interpolants.TangentToWorld0AndInterp_Sizer.w = Intermediates.SubImageLerp;
	Interpolants.TangentToWorld2 = float4(TangentToWorld[2], sign(determinant(Intermediates.TangentToLocal)));

#if NEEDS_PARTICLE_COLOR
	Interpolants.Color = Intermediates.Color;
#endif

#if (DYNAMIC_PARAMETERS_MASK & 1)
	Interpolants.DynamicParameter = Intermediates.DynamicParameter;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	Interpolants.DynamicParameter1 = Intermediates.DynamicParameter1;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	Interpolants.DynamicParameter2 = Intermediates.DynamicParameter2;
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	Interpolants.DynamicParameter3 = Intermediates.DynamicParameter3;
#endif

#if USE_PARTICLE_POSITION
	Interpolants.ParticleTranslatedWorldPositionAndSize = Intermediates.TranslatedWorldPositionAndSize;
#endif

#if USE_PARTICLE_VELOCITY
	Interpolants.ParticleVelocity = Intermediates.ParticleVelocity;
#endif

#if USE_PARTICLE_TIME
	Interpolants.RelativeTime = Intermediates.RelativeTime;
#endif

#if USE_PARTICLE_LIGHTING_OFFSET
	Interpolants.LightingPositionOffset = Intermediates.LightingPositionOffset;
#endif

#if USE_PARTICLE_SIZE
	Interpolants.ParticleSize = Intermediates.ParticleSize;
#endif

#if USE_PARTICLE_RANDOM
	Interpolants.ParticleRandom = Intermediates.ParticleRandom;
#endif


#if INSTANCED_STEREO
	Interpolants.EyeIndex = 0;
#endif

	return Interpolants;
}

#if RAYHITGROUPSHADER
struct FVertexFactoryInterpolantsVSToDS
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
};

FVertexFactoryInterpolantsVSToDS VertexFactoryGetInterpolantsVSToDS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToDS Interpolants;
	
	Interpolants.InterpolantsVSToPS = VertexFactoryGetInterpolantsVSToPS(Input, Intermediates, VertexParameters);
	
	return Interpolants;
}

float2 VertexFactoryGetTextureCoordinateDS(FVertexFactoryInterpolantsVSToDS Interpolants)
{
#if NUM_MATERIAL_TEXCOORDS
	return Interpolants.InterpolantsVSToPS.TexCoords[0].xy;
#else // #if NUM_MATERIAL_TEXCOORDS
	return float2(0, 0);
#endif // #if NUM_MATERIAL_TEXCOORDS
}

FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
{
	FVertexFactoryInterpolantsVSToDS O;

#if LIGHTMAP_UV_ACCESS
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LightMapUVs);
#endif

#if NUM_TEX_COORD_INTERPOLATORS
	UNROLL
	for(int tc = 0; tc < (NUM_TEX_COORD_INTERPOLATORS+1)/2; ++tc)
	{
		TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TexCoords[tc]);
	}
#endif

#if USE_PARTICLE_SUBUVS
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.ParticleSubUVs);
#endif

	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld0AndInterp_Sizer);
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld2);

#if NEEDS_PARTICLE_COLOR
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.Color);
#endif

#if (DYNAMIC_PARAMETERS_MASK & 1)
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.DynamicParameter);
#endif
#if (DYNAMIC_PARAMETERS_MASK & 2)
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.DynamicParameter1);
#endif
#if (DYNAMIC_PARAMETERS_MASK & 4)
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.DynamicParameter2);
#endif
#if (DYNAMIC_PARAMETERS_MASK & 8)
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.DynamicParameter3);
#endif

#if USE_PARTICLE_POSITION
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.ParticleTranslatedWorldPositionAndSize);
#endif

#if USE_PARTICLE_VELOCITY
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.ParticleVelocity);
#endif

#if USE_PARTICLE_TIME
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.RelativeTime);
#endif

#if USE_PARTICLE_LIGHTING_OFFSET
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LightingPositionOffset);
#endif

#if USE_PARTICLE_SIZE
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.ParticleSize);
#endif

#if USE_PARTICLE_RANDOM
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.ParticleRandom);
#endif

	return O;
}

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
{
	return Input.InterpolantsVSToPS;
}
#endif

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(Intermediates.PreviousVertexWorldPosition + ResolvedView.PrevPreViewTranslation, 1.0f);
}

/**
* Get the 3x3 tangent basis vectors for this vertex factory
*
* @param Input - vertex input stream structure
* @return 3x3 matrix
*/
float3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToLocal;
}

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
#if USE_PARTICLE_POSITION
	return Interpolants.ParticleTranslatedWorldPositionAndSize;
#else
	return 0;
#endif
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
