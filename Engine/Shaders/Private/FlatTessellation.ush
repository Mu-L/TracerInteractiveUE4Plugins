// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	FlatTessellation.usf: Shader fragments for flat tessellation
=============================================================================*/

#if DISPLACEMENT_ANTICRACK
#define IN_CONTROL_POINTS 12
#else
#define IN_CONTROL_POINTS 3
#endif



struct FHullShaderConstantOutput
{
	// Tess factor for the FF HW block
	float TessFactor[3]    : SV_TessFactor;
	float InsideTessFactor : SV_InsideTessFactor;
};

struct FFlatTessellationHSToDS
{
	FPassSpecificVSToDS PassSpecificData;

	// scale factors in tangent space
	float3 DisplacementScale : Flat_DisplacementScales;

	// Tessellation multiplier and World displacement falloff multiplier.
	float2 TessellationAndWorldDisplacementMultiplier : Flat_TessellationAndWorldDisplacementMultiplier;

#if DISPLACEMENT_ANTICRACK
	// dominant edge and vertex data used to avoid cracking when displacing
	FHullShaderConstantDominantEdgeAndVertexData DominantEdgeAndVertex : Flat_DominantEdgeAndVertex;
#endif
};

// GLSL needs those on the domain shader, HLSL on the hull shader, so we replicate them for both
#define TESSELLATION_ATTRIBUTES [partitioning("fractional_odd")][outputtopology("triangle_cw")]

#if HULLSHADER

	FHullShaderConstantOutput HS_FlatTrianglesConstant( const OutputPatch<FFlatTessellationHSToDS, 3> I )
	{
		FHullShaderConstantOutput O = (FHullShaderConstantOutput)0;

		#if INSTANCED_STEREO
			ResolvedView = ResolveView(I[0].PassSpecificData.FactoryInterpolants.InterpolantsVSToPS.EyeIndex);
		#else
			ResolvedView = ResolveView();
		#endif
	    
#if DISABLE_TESSELLATION_OVERRIDE
		O.TessFactor[0] = 1.0f; // 1->2 edge
		O.TessFactor[1] = 1.0f; // 2->0 edge
		O.TessFactor[2] = 1.0f; // 0->1 edge
		O.InsideTessFactor = 1.0f;
#else // #if DISABLE_TESSELLATION_OVERRIDE
		float3 WorldPostion0 = I[0].PassSpecificData.Position.xyz;
		float3 WorldPostion1 = I[1].PassSpecificData.Position.xyz;
		float3 WorldPostion2 = I[2].PassSpecificData.Position.xyz;

		float4 TessellationMultipliers;
		TessellationMultipliers.x = 0.5 * (I[1].TessellationAndWorldDisplacementMultiplier.x + I[2].TessellationAndWorldDisplacementMultiplier.x);
		TessellationMultipliers.y = 0.5 * (I[2].TessellationAndWorldDisplacementMultiplier.x + I[0].TessellationAndWorldDisplacementMultiplier.x);
		TessellationMultipliers.z = 0.5 * (I[0].TessellationAndWorldDisplacementMultiplier.x + I[1].TessellationAndWorldDisplacementMultiplier.x);
		TessellationMultipliers.w = 0.333 * (I[0].TessellationAndWorldDisplacementMultiplier.x + I[1].TessellationAndWorldDisplacementMultiplier.x + I[2].TessellationAndWorldDisplacementMultiplier.x);

		//@todo: This should be vectorized and done in the MainHull shader.
		float4 CompositeTessellationFactors = TessellationMultipliers * CalculateCompositeTessellationFactors(WorldPostion0,WorldPostion1,WorldPostion2);
		CompositeTessellationFactors = clamp( CompositeTessellationFactors, 1, 15 );

		O.TessFactor[0] = CompositeTessellationFactors.x; // 1->2 edge
		O.TessFactor[1] = CompositeTessellationFactors.y; // 2->0 edge
		O.TessFactor[2] = CompositeTessellationFactors.z; // 0->1 edge
		O.InsideTessFactor = CompositeTessellationFactors.w;
#endif // #if DISABLE_TESSELLATION_OVERRIDE

		return O;
	}

	[domain("tri")]
	[patchconstantfunc("HS_FlatTrianglesConstant")]
	[outputcontrolpoints(3)]
	[maxtessfactor(15)]
	TESSELLATION_ATTRIBUTES
	FFlatTessellationHSToDS MainHull( InputPatch<FPassSpecificVSToDS, IN_CONTROL_POINTS> I, uint ControlPointID : SV_OutputControlPointID )
	{
		#if INSTANCED_STEREO
			ResolvedView = ResolveView(I[0].FactoryInterpolants.InterpolantsVSToPS.EyeIndex);
		#else
			ResolvedView = ResolveView();
		#endif

		FFlatTessellationHSToDS O = (FFlatTessellationHSToDS) 0;
		
		float3x3 TangentToLocal = VertexFactoryGetTangentToLocalDS(I[ControlPointID].FactoryInterpolants);
		O.DisplacementScale = GetTangentSpaceNonUniformScales(TangentToLocal, VertexFactoryGetPrimitiveId(I[ControlPointID].FactoryInterpolants.InterpolantsVSToPS));

		const uint NextControlPointID = ControlPointID < 2 ? ControlPointID + 1 : 0; // (ControlPointID + 1) % 3

		O.PassSpecificData = I[ControlPointID];
		O.TessellationAndWorldDisplacementMultiplier.x = GetTessellationMultiplier( I[ControlPointID] );
		O.TessellationAndWorldDisplacementMultiplier.y = GetTessellationWorldDisplacementMultiplier(I[ControlPointID], O.TessellationAndWorldDisplacementMultiplier.x);

#if DISPLACEMENT_ANTICRACK
		// NextControlPointID is first opposite edge vert
		// NextNextControlPointID is second opposite edge vert
		const uint NextNextControlPointID = NextControlPointID < 2 ? NextControlPointID + 1 : 0;

		// We also need the neghbors of the opposite edge verts
		const uint NextNeighborControlPointID = 3 + 2 * NextControlPointID;	// neighbor for first opposite edge vert
		const uint NextNeighborNextControlPointID = NextNeighborControlPointID + 1; // neighbor for second opposite edge vert

		// Dominant vertex is provided explicitly
		// we need the other verts from each prim to generate the edges, clock wise winding
		const uint DominantVertexControlPointID = 9 + ControlPointID;
		O.DominantEdgeAndVertex = GenerateDominantEdgeAndVertexData(
			I[DominantVertexControlPointID],
			I[NextControlPointID],
			I[NextNextControlPointID],
			I[NextNeighborControlPointID],
			I[NextNeighborNextControlPointID]
		);
#endif	// DISPLACEMENT_ANTICRACK
		
		return O;
	}
#endif

#if DOMAINSHADER
	[domain("tri")]
	TESSELLATION_ATTRIBUTES
	FPassSpecificVSToPS MainDomain(
		FHullShaderConstantOutput HSConstantData,
		const OutputPatch<FFlatTessellationHSToDS, 3> I,
		float3 BarycentricCoords : SV_DomainLocation 
#if USE_GLOBAL_CLIP_PLANE
		, out float OutGlobalClipPlaneDistance : SV_ClipDistance
#endif
#if INSTANCED_STEREO && !MULTI_VIEW
		, out float OutClipDistance : SV_ClipDistance1
#endif
		)
	{
		#if INSTANCED_STEREO
			ResolvedView = ResolveView(I[0].PassSpecificData.FactoryInterpolants.InterpolantsVSToPS.EyeIndex);
			#if !MULTI_VIEW
				OutClipDistance = 0.0;
			#endif
		#else
			ResolvedView = ResolveView();
		#endif

		// Get the barycentric coords
		float U = BarycentricCoords.x;
		float V = BarycentricCoords.y;
		float W = BarycentricCoords.z;
		
		// Interpolate world position according to our tessellation scheme
		float4 WorldPosition = I[0].PassSpecificData.Position * U + I[1].PassSpecificData.Position * V + I[2].PassSpecificData.Position * W;
		
		// Interp remaining attributes (construct barycentric interp from bilerp primitives)
		// NB: the HLSL compiler resolves the 1.f to something efficient (i.e. no-op)
		FPassSpecificVSToDS Interp = PassInterpolate(
			PassInterpolate( I[0].PassSpecificData, U, I[1].PassSpecificData, V ), 1.f,
			I[2].PassSpecificData, W );
							
		// Forward the eye index along	
		#if INSTANCED_STEREO
		Interp.FactoryInterpolants.InterpolantsVSToPS.EyeIndex = I[0].PassSpecificData.FactoryInterpolants.InterpolantsVSToPS.EyeIndex;
		#endif
																		
		FMaterialTessellationParameters MaterialParameters = GetMaterialTessellationParameters(Interp.FactoryInterpolants, WorldPosition.xyz);

#if DISPLACEMENT_ANTICRACK

		float2 DisplacementTexCoords = 0;
#if NUM_MATERIAL_TEXCOORDS
		DisplacementTexCoords = GetTextureCoordinateDS( Interp );
#endif
		
		FMaterialTessellationParameters DisplacementMaterialParameters = MaterialParameters;
		
		float3x3 TangentToLocal = VertexFactoryGetTangentToLocalDS(Interp.FactoryInterpolants);

		// Override to dominant data if along edge or at control vert.  This is necessary to avoid cracks caused by primitives
		// from disjoint locations in UV space abutting each other.
		ApplyDominantData(
			DisplacementTexCoords, DisplacementMaterialParameters.TangentToWorld,
			GetNormalDS( TangentToLocal ), GetTangentDS( TangentToLocal ),
			U, V, W,
			I[0].DominantEdgeAndVertex, I[1].DominantEdgeAndVertex, I[2].DominantEdgeAndVertex );
							
		// Override texture coordinate 0.
#if NUM_MATERIAL_TEXCOORDS
		DisplacementMaterialParameters.TexCoords[0].xy = DisplacementTexCoords.xy;
#endif

#else

		FMaterialTessellationParameters DisplacementMaterialParameters = MaterialParameters;

#endif	// DISPLACEMENT_ANTICRACK

		// tangent space displacement scaling
		DisplacementMaterialParameters.TangentToWorldPreScale = I[0].DisplacementScale*U + I[1].DisplacementScale*V + I[2].DisplacementScale*W;

		// world space displacement value.  This will likely use the tangent2world transform.
		float3 WorldDisplacement = GetMaterialWorldDisplacement(DisplacementMaterialParameters);
		float WorldDisplacementMultiplier = I[0].TessellationAndWorldDisplacementMultiplier.y*U + I[1].TessellationAndWorldDisplacementMultiplier.y*V + I[2].TessellationAndWorldDisplacementMultiplier.y*W;

		WorldPosition.xyz += WorldDisplacement * WorldDisplacementMultiplier;

		#if USE_GLOBAL_CLIP_PLANE
			OutGlobalClipPlaneDistance = dot(ResolvedView.GlobalClippingPlane, float4(WorldPosition.xyz - ResolvedView.PreViewTranslation.xyz, 1));
		#endif

		FPassSpecificVSToPS Result = PassFinalizeTessellationOutput(Interp, WorldPosition,MaterialParameters);

		#if INSTANCED_STEREO && !MULTI_VIEW
		BRANCH
		if (IsInstancedStereo())
		{
			const uint EyeIndex = I[0].PassSpecificData.FactoryInterpolants.InterpolantsVSToPS.EyeIndex;

			// Clip at the center of the screen
			OutClipDistance = dot(Result.Position, EyeClipEdge[EyeIndex]);
			
			// Scale to the width of a single eye viewport
			Result.Position.x *= 0.5 * ResolvedView.HMDEyePaddingOffset;

			// Shift to the eye viewport
			Result.Position.x += (EyeOffsetScale[EyeIndex] * Result.Position.w) * (1.0f - 0.5 * ResolvedView.HMDEyePaddingOffset);
		}
		#endif

		return Result;
	}
#endif
