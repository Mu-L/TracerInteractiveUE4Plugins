// Copyright Epic Games, Inc. All Rights Reserved.

#include "SSDDefinitions.ush"


//------------------------------------------------------- ENUM VALUES

/** What signal should be outputed. */
	#define REJECTION_INPUT_MODE_1UNNORMALIZED 0
	#define REJECTION_INPUT_MODE_2PRETRANSFORMED_MOMMENTS 1

/** What set of sample should be used for history rejection. */
	#define REJECTION_SAMPLE_SET_BOX 0
	// [ Sobek 2018, "Real-time Reflections_in Mafia III" ]
	#define REJECTION_SAMPLE_SET_SOBEK2018 1


/** How to perform history rejection. */
	#define HISTORY_REJECTION_DISABLED 0
	#define HISTORY_REJECTION_MINMAX_BOUNDARIES 1
	#define HISTORY_REJECTION_VAR_BOUNDARIES 2
	#define HISTORY_REJECTION_ADAPTIVE_INTEGRATION 3


//------------------------------------------------------- CONFIGS

#define TILE_PIXEL_SIZE 8


#define CONFIG_SIGNAL_PROCESSING DIM_SIGNAL_PROCESSING
#define CONFIG_SIGNAL_BATCH_SIZE DIM_SIGNAL_BATCH_SIZE



#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SHADOW_VISIBILITY_MASK
	#define MAX_SIGNAL_BATCH_SIZE CONFIG_SIGNAL_BATCH_SIZE
	#define SIGNAL_ARRAY_SIZE CONFIG_SIGNAL_BATCH_SIZE

	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_MONOCHROMATIC_PENUMBRA
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_MONOCHROMATIC_PENUMBRA
	#define CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN 1

	#define CONFIG_SIGNAL_INPUT_TEXTURE_TYPE SIGNAL_TEXTURE_TYPE_FLOAT4
	#define CONFIG_SIGNAL_OUTPUT_TEXTURE_TYPE SIGNAL_TEXTURE_TYPE_FLOAT4

	#define CONFIG_INPUT_TEXTURE_COUNT CONFIG_SIGNAL_BATCH_SIZE
	#define CONFIG_HISTORY_TEXTURE_COUNT CONFIG_SIGNAL_BATCH_SIZE

	#define CONFIG_SIGNAL_INPUT_LAYOUT   SIGNAL_BUFFER_LAYOUT_PENUMBRA_RECONSTRUCTION
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_PENUMBRA_HISTORY

	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_VAR_BOUNDARIES

	// Uses nearest to not leak informations on geometric edges by bilateral. This is OK because just blury greyscale details.
	// TODO(Denoiser): a bit hacky, need find better solution.
	// TODO(Denoiser): cause a regression on spot light for some reasons.
	//#define CONFIG_USE_NEAREST_HISTORY 1

	#if DIM_SIGNAL_BATCH_SIZE > 1
		#define CONFIG_CLAMP_UV_PER_SIGNAL 1
	#endif

#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_POLYCHROMATIC_PENUMBRA_HARMONIC
	// Denoise diffuse and specular harmonics at the same time.
	#define MAX_SIGNAL_BATCH_SIZE 2
	#define SIGNAL_ARRAY_SIZE 2
	#undef CONFIG_SIGNAL_BATCH_SIZE
	#define CONFIG_SIGNAL_BATCH_SIZE 2

	#define COMPILE_SIGNAL_COLOR 1

	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_POLYCHROMATIC_PENUMBRA
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_POLYCHROMATIC_PENUMBRA
	#define CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN 2

	// Input and output layout.
	#define CONFIG_SIGNAL_INPUT_LAYOUT  SIGNAL_BUFFER_LAYOUT_POLYCHROMATIC_PENUMBRA_HISTORY
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_POLYCHROMATIC_PENUMBRA_HISTORY
	#define CONFIG_INPUT_TEXTURE_COUNT 2
	#define CONFIG_HISTORY_TEXTURE_COUNT 2

	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_VAR_BOUNDARIES

#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_REFLECTIONS
	#define COMPILE_SIGNAL_COLOR 1

	#define MAX_SIGNAL_BATCH_SIZE 1
	#define SIGNAL_ARRAY_SIZE 2 // First and Second moment in rejection pre convolution.

	// Input and output layout.
	#define CONFIG_SIGNAL_INPUT_LAYOUT   SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_REFLECTIONS_HISTORY

	#define CONFIG_INPUT_TEXTURE_COUNT 2
	#define CONFIG_HISTORY_TEXTURE_COUNT 2

	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_REFLECTIONS_TAA
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_REFLECTIONS_TAA

	// Use variance based rejection.
	#define CONFIG_HISTORY_REJECTION             HISTORY_REJECTION_VAR_BOUNDARIES
	#define CONFIG_HISTORY_REJECTION_COLOR_SPACE REFLECTIONS_REJECTION_COLOR_SPACE

	// Use pre transformed rejection buffer that contains pre transformed momment 1 & 2.
	#if 1
		#define CONFIG_USE_REJECTION_BUFFER               1
		#define CONFIG_SIGNAL_HISTORY_REJECTION_LAYOUT    SIGNAL_BUFFER_LAYOUT_REFLECTIONS_REJECTION
		
		#define CONFIG_REJECTION_TEXTURE_COUNT 3 

		#define CONFIG_REJECTION_BUFFER_COLOR_SPACE       REFLECTIONS_REJECTION_COLOR_SPACE
		#define CONFIG_REJECTION_INPUT_MODE               REJECTION_INPUT_MODE_2PRETRANSFORMED_MOMMENTS
		#define CONFIG_REJECTION_SAMPLE_SET               REJECTION_SAMPLE_SET_SOBEK2018
	#endif

#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_AO
	#define MAX_SIGNAL_BATCH_SIZE 1
	#define SIGNAL_ARRAY_SIZE 2 // First and Second moment in rejection pre convolution.

	// Input and output layout.
	#define CONFIG_SIGNAL_INPUT_LAYOUT   SIGNAL_BUFFER_LAYOUT_AO_HISTORY
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_AO_HISTORY

	#define CONFIG_INPUT_TEXTURE_COUNT 1
	#define CONFIG_HISTORY_TEXTURE_COUNT 1

	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_VAR_BOUNDARIES

	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_DIFFUSE
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_DIFFUSE

	// Use pre transformed rejection buffer that contains pre transformed momment 1 & 2.
	#if 1
		#define CONFIG_USE_REJECTION_BUFFER               1
		#define CONFIG_SIGNAL_HISTORY_REJECTION_LAYOUT    SIGNAL_BUFFER_LAYOUT_AO_REJECTION
		#define CONFIG_REJECTION_TEXTURE_COUNT            1

		#define CONFIG_REJECTION_INPUT_MODE               REJECTION_INPUT_MODE_2PRETRANSFORMED_MOMMENTS
		#define CONFIG_REJECTION_SAMPLE_SET               REJECTION_SAMPLE_SET_SOBEK2018
	#endif

#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_DIFFUSE_INDIRECT_AND_AO
	#define MAX_SIGNAL_BATCH_SIZE 1
	#define SIGNAL_ARRAY_SIZE 1

	#define COMPILE_SIGNAL_COLOR 1

	// Input and output layout.
	#define CONFIG_SIGNAL_INPUT_LAYOUT   SIGNAL_BUFFER_LAYOUT_DIFFUSE_INDIRECT_AND_AO_RECONSTRUCTION
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_DIFFUSE_INDIRECT_AND_AO_HISTORY

	#define CONFIG_INPUT_TEXTURE_COUNT 2
	#define CONFIG_HISTORY_TEXTURE_COUNT 2

	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_MINMAX_BOUNDARIES
	//#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_ADAPTIVE_INTEGRATION
	#define CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN 3

	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_DIFFUSE
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_DIFFUSE

#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_DIFFUSE_SPHERICAL_HARMONIC
	#define MAX_SIGNAL_BATCH_SIZE 1
	#define SIGNAL_ARRAY_SIZE 1

	#define COMPILE_SIGNAL_COLOR_SH 1

	// Input and output layout.
	#define CONFIG_SIGNAL_INPUT_LAYOUT   SIGNAL_BUFFER_LAYOUT_DIFFUSE_INDIRECT_HARMONIC
	#define CONFIG_SIGNAL_INPUT_TEXTURE_TYPE   SIGNAL_TEXTURE_TYPE_UINT2
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_DIFFUSE_INDIRECT_HARMONIC
	#define CONFIG_SIGNAL_OUTPUT_TEXTURE_TYPE   SIGNAL_TEXTURE_TYPE_UINT2

	#define CONFIG_INPUT_TEXTURE_COUNT 4
	#define CONFIG_HISTORY_TEXTURE_COUNT 4

	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_MINMAX_BOUNDARIES
	//#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_ADAPTIVE_INTEGRATION
	#define CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN 4

	// Given it's a spherical harmonic that store directionality, only need position based rejection.
	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_SPHERICAL_HARMONIC
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_SPHERICAL_HARMONIC

#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SSGI
	#define MAX_SIGNAL_BATCH_SIZE 1
	#define SIGNAL_ARRAY_SIZE 1

	#define COMPILE_SIGNAL_COLOR 1
	#define CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN 1

	// Input and output layout.
	#define CONFIG_SIGNAL_INPUT_LAYOUT   SIGNAL_BUFFER_LAYOUT_SSGI_HISTORY_R11G11B10
	#define CONFIG_SIGNAL_HISTORY_LAYOUT SIGNAL_BUFFER_LAYOUT_SSGI_HISTORY_R11G11B10

	#define CONFIG_INPUT_TEXTURE_COUNT 2
	#define CONFIG_HISTORY_TEXTURE_COUNT 2

	// SSGI doesn't have any bilateral distance computed from hitT, so allow to blur spatially by about the size of the kernel.
	#define CONFIG_BILATERAL_DISTANCE_MULTIPLIER 3.0

	// Stocastically sample history to speed up the reprojection.
	#define CONFIG_HISTORY_KERNEL SAMPLE_SET_2X2_STOCASTIC

	// Reject using variance to smooth highlights further on history rejections.
	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_VAR_BOUNDARIES

	// Use position and normal based rejection ideal for diffuse.
	#define CONFIG_BILATERAL_PRESET BILATERAL_PRESET_DIFFUSE
	#define CONFIG_HISTORY_BILATERAL_PRESET BILATERAL_PRESET_DIFFUSE

#else
	#error Unimplemented signal processing.
#endif


//------------------------------------------------------- CONFIG DISABLED DEFAULTS

/** Whether should clamp the UV individually per texture. */
#ifndef CONFIG_CLAMP_UV_PER_SIGNAL
	#define CONFIG_CLAMP_UV_PER_SIGNAL 0
#endif

/** Whether this pass make use of a tile classification. */
#ifndef CONFIG_USE_TILE_CLASSIFICATION
	#define CONFIG_USE_TILE_CLASSIFICATION 0
#endif

/** Whether this pass uses custom rejection buffer. */
#ifndef CONFIG_USE_REJECTION_BUFFER
	#define CONFIG_USE_REJECTION_BUFFER 0
	#define CONFIG_SIGNAL_HISTORY_REJECTION_LAYOUT CONFIG_SIGNAL_INPUT_LAYOUT
#endif

/** Input mode of the rejection signals. */
#ifndef CONFIG_REJECTION_INPUT_MODE
	#define CONFIG_REJECTION_INPUT_MODE REJECTION_INPUT_MODE_1UNNORMALIZED
#endif

/** Sample set to use for history rejection. */
#ifndef CONFIG_REJECTION_SAMPLE_SET
	#define CONFIG_REJECTION_SAMPLE_SET REJECTION_SAMPLE_SET_BOX
#endif

/** The color space to use for history rejection. */
#ifndef CONFIG_REJECTION_BUFFER_COLOR_SPACE
	#define CONFIG_REJECTION_BUFFER_COLOR_SPACE STANDARD_BUFFER_COLOR_SPACE
#endif

/** The number of signal that should be processed per signal domain. */
#ifndef CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN
	#define CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN SIGNAL_ARRAY_SIZE
#endif

/** Whether can use a nearest sampler when sampling the history */
#ifndef CONFIG_HISTORY_KERNEL
	#define CONFIG_HISTORY_KERNEL SAMPLE_SET_2X2_BILINEAR
#endif

/** Adds a multiplier on how the distance should be computed. */
#ifndef CONFIG_BILATERAL_DISTANCE_MULTIPLIER
	#define CONFIG_BILATERAL_DISTANCE_MULTIPLIER 1.0
#endif


//------------------------------------------------------- CONFIG ENABLED DEFAULTS

/** Whether should do history rejection. */
#ifndef CONFIG_HISTORY_REJECTION
	#define CONFIG_HISTORY_REJECTION HISTORY_REJECTION_DISABLED
#endif

/** The color space to use for history rejection. */
#ifndef CONFIG_HISTORY_REJECTION_COLOR_SPACE
	#define CONFIG_HISTORY_REJECTION_COLOR_SPACE STANDARD_BUFFER_COLOR_SPACE
#endif

/** The color space to use for history blending. */
#ifndef CONFIG_HISTORY_BLENDING_COLOR_SPACE
	#define CONFIG_HISTORY_BLENDING_COLOR_SPACE STANDARD_BUFFER_COLOR_SPACE
#endif


//------------------------------------------------------- COMPILATION WHITE LISTING

#define COMPILE_BOX_KERNEL 1

// Moment 1 needed for previous frame sampling.
#define COMPILE_MOMENT1_ACCUMULATOR 1

#if CONFIG_HISTORY_REJECTION != HISTORY_REJECTION_DISABLED
	#define COMPILE_MININVFREQ_ACCUMULATOR 1
#endif

#if CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_MINMAX_BOUNDARIES
	#define COMPILE_MINMAX_ACCUMULATOR 1
#elif CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_VAR_BOUNDARIES && CONFIG_REJECTION_INPUT_MODE == REJECTION_INPUT_MODE_1UNNORMALIZED
	#define COMPILE_MOMENT2_ACCUMULATOR 1
#endif


//------------------------------------------------------- INCLUDES

#include "SSDSignalFramework.ush"
#include "SSDSignalArray.ush"
#include "SSDSpatialKernel.ush"
#include "../Random.ush"


//------------------------------------------------------- PARAMETERS

int bCameraCut[MAX_SIGNAL_BATCH_SIZE];

float HistoryPreExposureCorrection;

float4 HistoryBufferUVMinMax[CONFIG_SIGNAL_BATCH_SIZE];


#if !defined(CONFIG_INPUT_TEXTURE_COUNT)
	#error Missing CONFIG_INPUT_TEXTURE_COUNT
#endif

FSSDTexture2D SignalInput_Textures_0;

#if CONFIG_INPUT_TEXTURE_COUNT > 1
FSSDTexture2D SignalInput_Textures_1;
#else
#define SignalInput_Textures_1 SignalInput_Textures_0
#endif

#if CONFIG_INPUT_TEXTURE_COUNT > 2
FSSDTexture2D SignalInput_Textures_2;
#else
#define SignalInput_Textures_2 SignalInput_Textures_0
#endif

#if CONFIG_INPUT_TEXTURE_COUNT > 3
FSSDTexture2D SignalInput_Textures_3;
#else
#define SignalInput_Textures_3 SignalInput_Textures_0
#endif


#if CONFIG_USE_REJECTION_BUFFER
	#if !defined(CONFIG_REJECTION_TEXTURE_COUNT)
		#error Missing CONFIG_REJECTION_TEXTURE_COUNT
	#endif

	FSSDTexture2D HistoryRejectionSignal_Textures_0;

	#if CONFIG_REJECTION_TEXTURE_COUNT > 1
	FSSDTexture2D HistoryRejectionSignal_Textures_1;
	#else
	#define HistoryRejectionSignal_Textures_1 HistoryRejectionSignal_Textures_0
	#endif

	#if CONFIG_REJECTION_TEXTURE_COUNT > 2
	FSSDTexture2D HistoryRejectionSignal_Textures_2;
	#else
	#define HistoryRejectionSignal_Textures_2 HistoryRejectionSignal_Textures_0
	#endif

	#if CONFIG_REJECTION_TEXTURE_COUNT > 3
	FSSDTexture2D HistoryRejectionSignal_Textures_3;
	#else
	#define HistoryRejectionSignal_Textures_3 HistoryRejectionSignal_Textures_0
	#endif
#endif // CONFIG_USE_REJECTION_BUFFER


#if !defined(CONFIG_HISTORY_TEXTURE_COUNT)
	#error Missing CONFIG_HISTORY_TEXTURE_COUNT
#endif

FSSDTexture2D PrevHistory_Textures_0;
FSSDRWTexture2D	SignalHistoryOutput_UAVs_0;

#if CONFIG_HISTORY_TEXTURE_COUNT > 1
FSSDTexture2D PrevHistory_Textures_1;
FSSDRWTexture2D	SignalHistoryOutput_UAVs_1;
#else
#define PrevHistory_Textures_1 PrevHistory_Textures_0
#define SignalHistoryOutput_UAVs_1 SignalHistoryOutput_UAVs_0
#endif

#if CONFIG_HISTORY_TEXTURE_COUNT > 2
FSSDTexture2D PrevHistory_Textures_2;
FSSDRWTexture2D	SignalHistoryOutput_UAVs_2;
#else
#define PrevHistory_Textures_2 PrevHistory_Textures_0
#define SignalHistoryOutput_UAVs_2 SignalHistoryOutput_UAVs_0
#endif

#if CONFIG_HISTORY_TEXTURE_COUNT > 3
FSSDTexture2D PrevHistory_Textures_3;
FSSDRWTexture2D	SignalHistoryOutput_UAVs_3;
#else
#define PrevHistory_Textures_3 PrevHistory_Textures_0
#define SignalHistoryOutput_UAVs_3 SignalHistoryOutput_UAVs_0
#endif


//------------------------------------------------------- FUNCTIONS

FSSDSignalSample TransformInputBufferForPreRejection(FSSDSignalSample Sample)
{
	return TransformSignal(
		Sample,
		/* SrcConfig = */ STANDARD_BUFFER_COLOR_SPACE,
		/* DestConfig = */ CONFIG_HISTORY_REJECTION_COLOR_SPACE);
}

FSSDSignalSample TransformSignalForPostRejection(FSSDSignalSample Sample)
{
	return TransformSignal(
		Sample,
		/* SrcConfig = */ CONFIG_HISTORY_REJECTION_COLOR_SPACE,
		/* DestConfig = */ STANDARD_BUFFER_COLOR_SPACE);
}

/** Temporally accumulate the input. */
void TemporallyAccumulate(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	// Find out scene buffer UV.
	float2 SceneBufferUV = DispatchThreadId * ThreadIdToBufferUV.xy + ThreadIdToBufferUV.zw;
	if (true)
	{
		SceneBufferUV = clamp(SceneBufferUV, BufferBilinearUVMinMax.xy, BufferBilinearUVMinMax.zw);
	}

	// Reproject to previous frame.
	float2 HistoryScreenPosition = DenoiserBufferUVToScreenPosition(SceneBufferUV);
	if (1)
	{
		float DeviceZ = SceneDepthBuffer.SampleLevel(GlobalPointClampedSampler, SceneBufferUV, 0).r;

		float4 ThisClip = float4(HistoryScreenPosition, DeviceZ, 1);
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
		float2 PrevScreen = PrevClip.xy / PrevClip.w;
		float2 Velocity = HistoryScreenPosition - PrevScreen;

		if (1)
		{
			float2 VelocityN = SceneVelocityBuffer.SampleLevel(GlobalPointClampedSampler, SceneBufferUV, 0).xy;
			bool DynamicN = VelocityN.x > 0.0;
			if (DynamicN)
			{
				Velocity = DecodeVelocityFromTexture(VelocityN);
			}
		}

		HistoryScreenPosition -= Velocity;
	}


	// Sample current frame data.
	FSSDCompressedSceneInfos CompressedRefSceneMetadata = SampleCompressedSceneMetadata(
		/* bPrevFrame = */ false,
		SceneBufferUV, BufferUVToBufferPixelCoord(SceneBufferUV));

	FSSDSignalArray CurrentFrameSamples = SampleMultiplexedSignals(
		SignalInput_Textures_0,
		SignalInput_Textures_1,
		SignalInput_Textures_2,
		SignalInput_Textures_3,
		GlobalPointClampedSampler,
		CONFIG_SIGNAL_INPUT_LAYOUT,
		/* MultiplexedSampleId = */ 0,
		/* bNormalizeSample = */ false,
		SceneBufferUV,
		/* MipLevel = */ 0);


	float WorldBluringRadius;
	float TargetedSampleCount;
	{
		float2 ScreenPosition = DenoiserBufferUVToScreenPosition(SceneBufferUV);
	
		FSSDSampleSceneInfos RefSceneMetadata = UncompressSampleSceneInfo(
			CONFIG_METADATA_BUFFER_LAYOUT, /* bPrevFrame = */ false,
			ScreenPosition, CompressedRefSceneMetadata);

		// Use the diameter, because that is the distance between two pixel.
		float PixelWorldBluringRadius = ComputeWorldBluringRadiusCausedByPixelSize(RefSceneMetadata);
		WorldBluringRadius = WorldBluringRadiusToBilateralWorldDistance(PixelWorldBluringRadius);
	
		TargetedSampleCount = TARGETED_SAMPLE_COUNT;

		#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_REFLECTIONS
		{
			float SignalPixelBluringRadius = ComputeInfinityBluringRadius(RefSceneMetadata) * View.ViewSizeAndInvSize.x;

			TargetedSampleCount = PI * SignalPixelBluringRadius * SignalPixelBluringRadius;

			// TODO(Denoiser): try to make this better? * 0.125 to avoid banding caused by floating point precision.
			TargetedSampleCount = clamp(TargetedSampleCount, 1, TARGETED_SAMPLE_COUNT);
		}
		#else
		{
			TargetedSampleCount = TARGETED_SAMPLE_COUNT;
		}
		#endif
	}

	// Sample the history buffer.
	FSSDSignalArray HistorySamples = CreateSignalArrayFromScalarValue(0.0);
	{
		float2 HistoryBufferUV = HistoryScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		float2 ClampedHistoryBufferUV = clamp(HistoryBufferUV, BufferBilinearUVMinMax.xy, BufferBilinearUVMinMax.zw);
		bool bIsPreviousFrameOffscreen = any(HistoryBufferUV != ClampedHistoryBufferUV);

		// TODO(Denoiser): global camera cut to save perf that is going to be required for panic post filtering.
		BRANCH
		if (!bIsPreviousFrameOffscreen)
		{
			FSSDKernelConfig KernelConfig = CreateKernelConfig();

			#if DEBUG_OUTPUT
			{
				KernelConfig.DebugPixelPosition = DispatchThreadId;
				KernelConfig.DebugEventCounter = 0;
			}
			#endif
			
			// compile time configuration of the kernel.
			KernelConfig.SampleSet = CONFIG_HISTORY_KERNEL;
			//KernelConfig.SampleSet = SAMPLE_SET_1X1;
			KernelConfig.bSampleKernelCenter = true;
			KernelConfig.BufferLayout = CONFIG_SIGNAL_HISTORY_LAYOUT;
			KernelConfig.MultiplexedSignalsPerSignalDomain = CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN;
			KernelConfig.bUnroll = true;
			KernelConfig.bPreviousFrameMetadata = true;
			KernelConfig.BilateralDistanceComputation = SIGNAL_WORLD_FREQUENCY_MIN_METADATA;
			KernelConfig.bClampUVPerMultiplexedSignal = CONFIG_CLAMP_UV_PER_SIGNAL != 0;

			// Allow a little bit of error when doing bilateral rejection of the history, to forgive per frame TAA jitter.
			KernelConfig.WorldBluringDistanceMultiplier = max(CONFIG_BILATERAL_DISTANCE_MULTIPLIER, 3.0);
			
			SetBilateralPreset(CONFIG_HISTORY_BILATERAL_PRESET, /* inout */ KernelConfig);

			// SGPR configuration of the kernel.
			KernelConfig.BufferSizeAndInvSize = BufferSizeAndInvSize;
			KernelConfig.BufferBilinearUVMinMax = BufferBilinearUVMinMax;
			
			#if CONFIG_CLAMP_UV_PER_SIGNAL
			{
				UNROLL_N(CONFIG_SIGNAL_BATCH_SIZE)
				for (uint BatchedSignalId = 0; BatchedSignalId < CONFIG_SIGNAL_BATCH_SIZE; BatchedSignalId++)
				{
					uint MultiplexId = BatchedSignalId / CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN;
					KernelConfig.PerSignalUVMinMax[MultiplexId] = HistoryBufferUVMinMax[MultiplexId];
				}
			}
			#endif
			
			// VGPR configuration of the kernel.
			KernelConfig.BufferUV = HistoryBufferUV + BufferUVBilinearCorrection;
			{
				KernelConfig.CompressedRefSceneMetadata = CompressedRefSceneMetadata;
				KernelConfig.RefBufferUV = SceneBufferUV;
				KernelConfig.RefSceneMetadataLayout = CONFIG_METADATA_BUFFER_LAYOUT;
			}

			// Compute random signals.
			ISOLATE
			{
				KernelConfig.Randoms[0] = InterleavedGradientNoise(SceneBufferUV * BufferUVToOutputPixelPosition, View.StateFrameIndexMod8);
			}
			
			FSSDSignalAccumulatorArray SignalAccumulators = CreateSignalAccumulatorArray();
			FSSDCompressedSignalAccumulatorArray UnusedCompressedAccumulators = CreateUninitialisedCompressedAccumulatorArray();

			AccumulateKernel(
				KernelConfig,
				PrevHistory_Textures_0,
				PrevHistory_Textures_1,
				PrevHistory_Textures_2,
				PrevHistory_Textures_3,
				/* inout */ SignalAccumulators,
				/* inout */ UnusedCompressedAccumulators);
		
			// Exports the history sample from accumulator.
			UNROLL_N(CONFIG_SIGNAL_BATCH_SIZE)
			for (uint BatchedSignalId = 0; BatchedSignalId < CONFIG_SIGNAL_BATCH_SIZE; BatchedSignalId++)
			{
				HistorySamples.Array[BatchedSignalId] = SignalAccumulators.Array[BatchedSignalId].Moment1;
				BRANCH
				if (bCameraCut[BatchedSignalId])
				{
					HistorySamples.Array[BatchedSignalId] = CreateSignalSampleFromScalarValue(0.0);
				}
			}

			UNROLL_N(CONFIG_SIGNAL_BATCH_SIZE)
			for (uint BatchedSignalId = 0; BatchedSignalId < CONFIG_SIGNAL_BATCH_SIZE; BatchedSignalId++)
			{
				FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
				FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];

				// Override the previous frame's inverse frequency with the current frame's one, because don't know how much it changed.
				HistorySamples.Array[BatchedSignalId].WorldBluringRadius = (
					HistorySample.SampleCount *
					CurrentFrameSample.WorldBluringRadius *
					SafeRcp(CurrentFrameSample.SampleCount));

				// Applies correction when pre exposure change happen.
				#if COMPILE_SIGNAL_COLOR
					HistorySamples.Array[BatchedSignalId].SceneColor.rgb *= HistoryPreExposureCorrection;
				#endif
			} // for (uint BatchedSignalId = 0; BatchedSignalId < CONFIG_SIGNAL_BATCH_SIZE; BatchedSignalId++)
		} // if (!bIsPreviousFrameOffscreen)
	}
	
	#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_DIFFUSE_INDIRECT_AND_AO && 0
		DebugOutput[DispatchThreadId] = float4(
			HistorySamples.Array[0].SampleCount / 4096,
			0,
			0,
			0);
	#endif
	
	const bool bPostRejectionBlending = true;

	// History rejection.
	#if (CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_MINMAX_BOUNDARIES || CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_VAR_BOUNDARIES)
	{
		FSSDKernelConfig KernelConfig = CreateKernelConfig();
		
		#if DEBUG_OUTPUT
		{
			KernelConfig.DebugPixelPosition = DispatchThreadId;
			KernelConfig.DebugEventCounter = 0;
		}
		#endif

		// compile time configuration of the kernel.
		{
			KernelConfig.bSampleKernelCenter = CONFIG_USE_REJECTION_BUFFER != 0;
		
			// History rejection is already fudge factor by how reprojection. Want to prioritize rejection stability with more sample
			// than accuracy, so only take the blur distance of the reference sample that depends on depth and pixel size of the current frame.
			KernelConfig.BilateralDistanceComputation = SIGNAL_WORLD_FREQUENCY_REF_METADATA_ONLY;
			KernelConfig.NeighborToRefComputation = NEIGHBOR_TO_REF_LOWEST_VGPR_PRESSURE;

			// TODO(Denoiser): Should be done for all signals.
			// TODO(Denoiser): Should also take into account the world bluring radius du to size of the pixel.
			if (CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SHADOW_VISIBILITY_MASK)
				KernelConfig.BilateralDistanceComputation = SIGNAL_WORLD_FREQUENCY_PRECOMPUTED_BLURING_RADIUS;
			KernelConfig.WorldBluringDistanceMultiplier = CONFIG_BILATERAL_DISTANCE_MULTIPLIER;
			
			#if CONFIG_REJECTION_SAMPLE_SET == REJECTION_SAMPLE_SET_SOBEK2018
			{
				KernelConfig.SampleSet = SAMPLE_SET_3X3_SOBEK2018;
				//KernelConfig.SampleSet = SAMPLE_SET_NXN;
				//KernelConfig.BoxKernelRadius = 3;
				KernelConfig.bUnroll = true;
			}
			#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SSGI
			{
				KernelConfig.SampleSet = SAMPLE_SET_3X3_PLUS;
				KernelConfig.bUnroll = true;
			}
			#else
			{
				KernelConfig.SampleSet = CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SHADOW_VISIBILITY_MASK ? SAMPLE_SET_3X3 : SAMPLE_SET_NXN;
				KernelConfig.BoxKernelRadius = 3;
				KernelConfig.bUnroll = false;
			}
			#endif

			if (CONFIG_USE_REJECTION_BUFFER)
			{
				// History rejection have two moments of the signal being denoised.
				KernelConfig.MultiplexedSignalsPerSignalDomain = 2;
				
				KernelConfig.BufferLayout = CONFIG_SIGNAL_HISTORY_REJECTION_LAYOUT;
				KernelConfig.bNormalizeSample = false;
			
				for (uint MultiplexId = 0; MultiplexId < SIGNAL_ARRAY_SIZE; MultiplexId++)
				{
					KernelConfig.BufferColorSpace[MultiplexId] = CONFIG_REJECTION_BUFFER_COLOR_SPACE;
					KernelConfig.AccumulatorColorSpace[MultiplexId] = CONFIG_HISTORY_REJECTION_COLOR_SPACE;
				}

				// Force to sample the kernel center because will contain two momments for matching scene meta data.
				KernelConfig.bForceKernelCenterAccumulation = true;
			}
			else
			{
				KernelConfig.MultiplexedSignalsPerSignalDomain = CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN;
				KernelConfig.BufferLayout = CONFIG_SIGNAL_INPUT_LAYOUT;
				KernelConfig.bNormalizeSample = true;
			
				for (uint MultiplexId = 0; MultiplexId < SIGNAL_ARRAY_SIZE; MultiplexId++)
				{
					KernelConfig.AccumulatorColorSpace[MultiplexId] = CONFIG_HISTORY_REJECTION_COLOR_SPACE;
				}
			
				if (MAX_SIGNAL_BATCH_SIZE == 1)
				{
					// TODO(Denoiser): missing && abs(PixelOffset.x) <= 1 && abs(PixelOffset.y) <= 1;
					KernelConfig.bForceAllAccumulation = CurrentFrameSamples.Array[0].SampleCount == 0;
				}
			}
			
			SetBilateralPreset(CONFIG_BILATERAL_PRESET, /* inout */ KernelConfig);
		}

		// SGPR configuration of the kernel.
		{
			KernelConfig.BufferSizeAndInvSize = BufferSizeAndInvSize;
			KernelConfig.BufferBilinearUVMinMax = BufferBilinearUVMinMax;
		}

		// VGPR configuration of the kernel.
		{
			KernelConfig.BufferUV = SceneBufferUV;
			{
				KernelConfig.CompressedRefSceneMetadata = CompressedRefSceneMetadata;
				KernelConfig.RefBufferUV = SceneBufferUV;
				KernelConfig.RefSceneMetadataLayout = CONFIG_METADATA_BUFFER_LAYOUT;
			}
		}

		// Accumulate the current frame to save perf with unecessary bilateral evaluation.
		FSSDSignalAccumulatorArray SignalAccumulators = CreateSignalAccumulatorArray();
		{
			FSSDSampleSceneInfos RefSceneMetadata = UncompressRefSceneMetadata(KernelConfig);
			
			FSSDCompressedSignalAccumulatorArray UnusedCompressedAccumulators = CreateUninitialisedCompressedAccumulatorArray();

			AccumulateRefSampleAsKernelCenter(
				KernelConfig,
				/* inout */ SignalAccumulators,
				/* inout */ UnusedCompressedAccumulators,
				KernelConfig.RefBufferUV,
				RefSceneMetadata,
				NormalizeToOneSampleArray(CurrentFrameSamples));
		}

		{
			FSSDCompressedSignalAccumulatorArray UnusedCompressedAccumulators = CreateUninitialisedCompressedAccumulatorArray();

			#if CONFIG_USE_REJECTION_BUFFER
				AccumulateKernel(
					KernelConfig,
					HistoryRejectionSignal_Textures_0,
					HistoryRejectionSignal_Textures_1,
					HistoryRejectionSignal_Textures_2,
					HistoryRejectionSignal_Textures_3,
					/* inout */ SignalAccumulators,
					/* inout */ UnusedCompressedAccumulators);
			#else
				AccumulateKernel(
					KernelConfig,
					SignalInput_Textures_0,
					SignalInput_Textures_1,
					SignalInput_Textures_2,
					SignalInput_Textures_3,
					/* inout */ SignalAccumulators,
					/* inout */ UnusedCompressedAccumulators);
			#endif
		}

		// Clamp history
		UNROLL_N(CONFIG_SIGNAL_BATCH_SIZE)
		for (uint BatchedSignalId = 0; BatchedSignalId < CONFIG_SIGNAL_BATCH_SIZE; BatchedSignalId++)
		{
			FSSDSignalSample NeighborMoment1 = CreateSignalSampleFromScalarValue(0.0);
			FSSDSignalSample NeighborMoment2 = CreateSignalSampleFromScalarValue(0.0);
			#if CONFIG_REJECTION_INPUT_MODE == REJECTION_INPUT_MODE_1UNNORMALIZED
			{
				float NormalizeFactor = SafeRcp(SignalAccumulators.Array[BatchedSignalId].Moment1.SampleCount);
				NeighborMoment1 = MulSignal(SignalAccumulators.Array[BatchedSignalId].Moment1, NormalizeFactor);
				
				#if COMPILE_MOMENT2_ACCUMULATOR
					NeighborMoment2 = MulSignal(SignalAccumulators.Array[BatchedSignalId].Moment2, NormalizeFactor);
				#endif
			}
			#elif CONFIG_REJECTION_INPUT_MODE == REJECTION_INPUT_MODE_2PRETRANSFORMED_MOMMENTS
			{
				#if SIGNAL_ARRAY_SIZE != 2 * MAX_SIGNAL_BATCH_SIZE
					#error Invalid signal array size.
				#endif

				float NormalizeFactor = SafeRcp(SignalAccumulators.Array[BatchedSignalId * 2 + 0].Moment1.SampleCount);
				NeighborMoment1 = MulSignal(SignalAccumulators.Array[BatchedSignalId * 2 + 0].Moment1, NormalizeFactor);
				NeighborMoment2 = MulSignal(SignalAccumulators.Array[BatchedSignalId * 2 + 1].Moment1, NormalizeFactor);
			}
			#else
				#error NOrmalized samples. 
			#endif
		
			#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_REFLECTIONS && 0
				FSSDSignalSample Temp = TransformSignalForPostRejection(NeighborMoment1);
				DebugOutput[DispatchThreadId] = float4(
					Temp.SceneColor.rgb,
					0);
			#endif
				
			FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
			FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];

			// Clamp the history.
			#if CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_VAR_BOUNDARIES
			{
				const float StdDevMultiplier = 1.25;

				// StdDev = sqrt(abs(NeighborSquareAvg - NeighborAvg * NeighborAvg));
				FSSDSignalSample StdDev = SqrtSignal(AbsSignal(SubtractSignal(NeighborMoment2, PowerSignal(NeighborMoment1, 2))));
				FSSDSignalSample NeighborMin = AddSignal(NeighborMoment1, MulSignal(StdDev, -StdDevMultiplier));
				FSSDSignalSample NeighborMax = AddSignal(NeighborMoment1, MulSignal(StdDev,  StdDevMultiplier));

				if (0)
				{
					FSSDSignalSample QuantizationErrorMin = MulSignal(NeighborMoment1, 1 - SafeRcp(HistorySample.SampleCount));
					FSSDSignalSample QuantizationErrorMax = MulSignal(NeighborMoment1, 1 + SafeRcp(HistorySample.SampleCount));

					NeighborMin = MinSignal(NeighborMin, QuantizationErrorMin);
					NeighborMax = MaxSignal(NeighborMax, QuantizationErrorMax);
				}

				// Transform the history so that it in correct component spaces, and normalized as the clamping box.
				FSSDSignalSample NormalizedHistorySample = NormalizeToOneSample(HistorySample);
				FSSDSignalSample TransformedHistorySample = TransformInputBufferForPreRejection(NormalizedHistorySample);

				// Clamp the history.
				FSSDSignalSample ClampedTransformedHistorySample = ClampSignal(TransformedHistorySample, NeighborMin, NeighborMax);

				// Transform the history back to linear component spaces.
				FSSDSignalSample ClampedHistorySample = TransformSignalForPostRejection(ClampedTransformedHistorySample);

				// Reweight the anti ghosted history.
				{
					FSSDSignalSample RejectedDiff = AbsSignal(SubtractSignal(ClampedTransformedHistorySample, TransformedHistorySample));

					// Compute how much this history get changed.
					float RejectionFactor = 0.0;
					#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_REFLECTIONS && (CONFIG_HISTORY_REJECTION_COLOR_SPACE & COLOR_SPACE_LCOCG)
					{
						#if !COMPILE_SIGNAL_COLOR
							#error Need to compile signal color.
						#endif
						RejectionFactor = abs(
							Luma_To_LumaLog(ClampedTransformedHistorySample.SceneColor.x) -
							Luma_To_LumaLog(TransformedHistorySample.SceneColor.x));
				
						RejectionFactor = max(RejectionFactor, 1 * max(RejectedDiff.SceneColor.y, RejectedDiff.SceneColor.z));
						RejectionFactor = max(RejectionFactor, 1 * RejectedDiff.SceneColor.a);
					}
					#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SHADOW_VISIBILITY_MASK || CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_POLYCHROMATIC_PENUMBRA_HARMONIC || CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_AO || CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_DIFFUSE_INDIRECT_AND_AO
					{
						RejectionFactor = abs(ClampedTransformedHistorySample.MissCount - TransformedHistorySample.MissCount);
					}
					#elif CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SSGI
					{
						//float4 ColorDiff = abs(ClampedTransformedHistorySample.SceneColor - TransformedHistorySample.SceneColor) / ClampedTransformedHistorySample.SceneColor;
						//
						//ColorDiff = -min(-ColorDiff, 0.0);
						//
						//RejectionFactor = saturate(max(max(ColorDiff.x, ColorDiff.y), ColorDiff.z));
						RejectionFactor = abs(ClampedTransformedHistorySample.MissCount - TransformedHistorySample.MissCount);
					}
					#else
						#error Unsupported signal rejection.
					#endif
			
					// Compute an initial history weight as if we had removed sample.
					float FinalHistoryWeight = HistorySample.SampleCount * saturate(1 - RejectionFactor);

					// When doing the accumulation before rejection, need to make sure the input weight get through.
					if (!bPostRejectionBlending)
					{
						FinalHistoryWeight = max(FinalHistoryWeight, CurrentFrameSample.SampleCount);
					}

					// When doing upscaling, may have an invalid input sample.
					FinalHistoryWeight = max(FinalHistoryWeight, NeighborMoment1.SampleCount * 0.1);
			
					// Apply the history weight.
					HistorySample = MulSignal(ClampedHistorySample, FinalHistoryWeight);
					HistorySample.SampleCount = FinalHistoryWeight;
				}
			}
			#elif CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_MINMAX_BOUNDARIES
			{
				FSSDSignalSample NeighborMin = SignalAccumulators.Array[BatchedSignalId].Min;
				FSSDSignalSample NeighborMax = SignalAccumulators.Array[BatchedSignalId].Max;
		
				float RejectedSampleCount = 0;
				HistorySample = MulSignal(TransformSignalForPostRejection(ClampSignal(TransformInputBufferForPreRejection(NormalizeToOneSample(HistorySample)), NeighborMin, NeighborMax)), HistorySample.SampleCount - RejectedSampleCount);
			}
			#endif

			// Dilate the smallest inv frequency.
			if (1)
			{
				float NeightborMinBluringRadius = SignalAccumulators.Array[BatchedSignalId].MinInvFrequency;
				CurrentFrameSample.WorldBluringRadius = min(CurrentFrameSample.WorldBluringRadius, NeightborMinBluringRadius * CurrentFrameSample.SampleCount); 
			
				#if CONFIG_SIGNAL_PROCESSING == SIGNAL_PROCESSING_SHADOW_VISIBILITY_MASK && 0
					DebugOutput[DispatchThreadId] = float4(
						NeightborMinBluringRadius,
						NeightborMinBluringRadius == WORLD_RADIUS_MISS,
						0,
						0);
				#endif
			}
			
			HistorySamples.Array[BatchedSignalId] = HistorySample;
			CurrentFrameSamples.Array[BatchedSignalId] = CurrentFrameSample;
		} // for (uint BatchedSignalId = 0; BatchedSignalId < CONFIG_SIGNAL_BATCH_SIZE; BatchedSignalId++)
	}
	#endif // CONFIG_HISTORY_REJECTION > 0
	
	// Blends the current and history together.
	#if CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_ADAPTIVE_INTEGRATION
	{
		#if CONFIG_SIGNAL_BATCH_SIZE != 1
			#error Unsupported.
		#endif
	
		#if !COMPILE_SIGNAL_COLOR
			#error Need to compile signal color.
		#endif

		const uint BatchedSignalId = 0;
	
		FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
		FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];

		// Construct the current frame sample of the temporal analysis.
		FSSDSignalArray CurrentTemporalAnalysis = CreateSignalArrayFromScalarValue(0.0);
		{
			float Luma = GetSignalLuma4(CurrentFrameSample, STANDARD_BUFFER_COLOR_SPACE);
			float SampleCount = CurrentFrameSample.SampleCount; // TODO(Denoiser): 1 instead?

			CurrentTemporalAnalysis.Array[1].SampleCount = SampleCount;
			CurrentTemporalAnalysis.Array[1].SceneColor.x = Luma * SampleCount;
			CurrentTemporalAnalysis.Array[2].SampleCount = SampleCount;
			CurrentTemporalAnalysis.Array[2].SceneColor.x = (Luma * Luma) * SampleCount;
		}

		// Update the temporal analysis.
		FSSDSignalArray TemporalAnalysis;
		{
			const float MinimumAnalasisHisteresis = 0.3; // TODO(Denoiser): expose cvar

			float PreviousFrameWeight = min(HistorySample.SampleCount, HistorySamples.Array[1].SampleCount * rcp(MinimumAnalasisHisteresis) - CurrentFrameSample.SampleCount);
			float PreviousFrameMultiplier = HistorySample.SampleCount > 0 ? PreviousFrameWeight / HistorySample.SampleCount : 0;
			
			UNROLL
			for (uint SignalMultiplexId = 1; SignalMultiplexId < 3; SignalMultiplexId++)
			{
				TemporalAnalysis.Array[SignalMultiplexId] = Add(Mul(HistorySamples.Array[SignalMultiplexId], PreviousFrameMultiplier), CurrentTemporalAnalysis.Array[SignalMultiplexId]);
			}
		}

		// Compute the histeresis of the main signal.
		float MainHisteresiss = 0;
		{
			float InvSampleCount = rcp(TemporalAnalysis.Array[1].SampleCount);

			float AvgLuma = TemporalAnalysis.Array[2].SceneColor.x * InvSampleCount;
			float VarianceLuma = TemporalAnalysis.Array[2].SceneColor.x * InvSampleCount - AvgLuma * AvgLuma;
			float StdDevLuma = sqrt(VarianceLuma);

			float LikelyNess = 0.5 * sqrt(StdDevLuma * HistorySample.SceneColor.x) / (StdDevLuma + HistorySample.SceneColor.x);

			MainHisteresiss = 0.3 / max(LikelyNess * StdDevLuma, 0.3); 
		}

		// Accumulate the actual history.
		{
			float PreviousFrameWeight = min(HistorySample.SampleCount, CurrentFrameSample.SampleCount * rcp(MainHisteresiss) - CurrentFrameSample.SampleCount);
			float PreviousFrameMultiplier = HistorySample.SampleCount > 0 ? PreviousFrameWeight / HistorySample.SampleCount : 0;
			
			HistorySample = AddSignal(MulSignal(HistorySample, PreviousFrameMultiplier), CurrentFrameSample);
		}
		
		HistorySamples.Array[BatchedSignalId] = HistorySample;

		// Copy the temporal analysis into the history sample.
		UNROLL
		for (uint SignalMultiplexId = 1; SignalMultiplexId < 3; SignalMultiplexId++)
		{
			HistorySamples.Array[SignalMultiplexId] = TemporalAnalysis.Array[SignalMultiplexId];
		}
	}
	#else // CONFIG_HISTORY_REJECTION != HISTORY_REJECTION_ADAPTIVE_INTEGRATION
	{
		UNROLL
		for (uint BatchedSignalId = 0; BatchedSignalId < MAX_SIGNAL_BATCH_SIZE; BatchedSignalId++)
		{
			FSSDSignalSample CurrentFrameSample = CurrentFrameSamples.Array[BatchedSignalId];
			FSSDSignalSample HistorySample = HistorySamples.Array[BatchedSignalId];

			float PreviousFrameWeight = min(HistorySample.SampleCount, TargetedSampleCount - CurrentFrameSample.SampleCount);
			float PreviousFrameMultiplier = HistorySample.SampleCount > 0 ? PreviousFrameWeight / HistorySample.SampleCount : 0;

			// TODO(Denoiser): use WeightedLerp instead for VALU perf.
			// Pre transformation of the signal.
			HistorySample = TransformSignal(
				HistorySample,
				/* SrcBasis = */ STANDARD_BUFFER_COLOR_SPACE,
				/* DestBasis = */ CONFIG_HISTORY_BLENDING_COLOR_SPACE);
			CurrentFrameSample = TransformSignal(
				CurrentFrameSample,
				/* SrcBasis = */ STANDARD_BUFFER_COLOR_SPACE,
				/* DestBasis = */ CONFIG_HISTORY_BLENDING_COLOR_SPACE);

			// Blending.
			HistorySample = AddSignal(MulSignal(HistorySample, PreviousFrameMultiplier), CurrentFrameSample);
		
			// Post transformation of the signal.
			HistorySample = TransformSignal(
				HistorySample,
				/* SrcBasis = */ CONFIG_HISTORY_BLENDING_COLOR_SPACE,
				/* DestBasis = */ STANDARD_BUFFER_COLOR_SPACE);
			
			// Ignore the bluring radius of previous frame frequencies as it gets clamped anyway, just take the current frame.
			HistorySample.WorldBluringRadius = (
				CurrentFrameSample.WorldBluringRadius *
				SafeRcp(CurrentFrameSample.SampleCount) *
				HistorySample.SampleCount);

			if (View.GeneralPurposeTweak > 0.5)
			HistorySamples.Array[BatchedSignalId] = HistorySample;
		}
	}
	#endif

	// Romoves NaN and negative numbers
	// HistorySample = Minus(Min(Minus(HistorySample), CreateSignalSampleFromScalarValue(0.0)));
	
	// Whitelists what should be outputed to ensure the compiler compiles out evreything that ends up unneeded.
	uint MultiplexCount = 1;
	FSSDSignalArray OutputSamples = CreateSignalArrayFromScalarValue(0.0);
	{
		#if CONFIG_HISTORY_REJECTION == HISTORY_REJECTION_ADAPTIVE_INTEGRATION
		{
			MultiplexCount = CONFIG_MULTIPLEXED_SIGNALS_PER_SIGNAL_DOMAIN;
		}
		#elif 1
		{
			MultiplexCount = CONFIG_SIGNAL_BATCH_SIZE;
		}
		#else
			#error Unknown output mode.
		#endif
		
		UNROLL
		for (uint BatchedSignalId = 0; BatchedSignalId < MultiplexCount; BatchedSignalId++)
		{
			OutputSamples.Array[BatchedSignalId] = HistorySamples.Array[BatchedSignalId];
		}
	}
	
	// No need to keep DispatchThreadId, while SceneBufferUV is arround at highest VGPR peak because center of the kernel.
	uint2 OutputPixelPostion = BufferUVToBufferPixelCoord(SceneBufferUV);
		
	BRANCH
	if (all(OutputPixelPostion < ViewportMax))
	{
		OutputMultiplexedSignal(
			SignalHistoryOutput_UAVs_0,
			SignalHistoryOutput_UAVs_1,
			SignalHistoryOutput_UAVs_2,
			SignalHistoryOutput_UAVs_3,
			CONFIG_SIGNAL_HISTORY_LAYOUT, MultiplexCount,
			OutputPixelPostion, OutputSamples.Array);
	}
} // TemporallyAccumulate


//------------------------------------------------------- ENTRY POINT

[numthreads(TILE_PIXEL_SIZE, TILE_PIXEL_SIZE, 1)]
void MainCS(
	uint2 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	TemporallyAccumulate(DispatchThreadId, GroupId, GroupThreadId, GroupThreadIndex);
}
