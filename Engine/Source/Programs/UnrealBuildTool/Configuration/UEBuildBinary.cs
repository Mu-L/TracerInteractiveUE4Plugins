// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
using System.Globalization;
using Tools.DotNETCommon;

namespace UnrealBuildTool
{
	/// <summary>
	/// All binary types generated by UBT
	/// </summary>
	enum UEBuildBinaryType
	{
		/// <summary>
		/// An executable
		/// </summary>
		Executable,

		/// <summary>
		/// A dynamic library (.dll, .dylib, or .so)
		/// </summary>
		DynamicLinkLibrary,

		/// <summary>
		/// A static library (.lib or .a)
		/// </summary>
		StaticLibrary,

		/// <summary>
		/// An object file (.obj or .o)
		/// </summary>
		Object,

		/// <summary>
		/// A precompiled header (.pch or .gch)
		/// </summary>
		PrecompiledHeader
	}

	/// <summary>
	/// UEBuildBinary configuration
	/// Configuration class for a UEBuildBinary.
	/// Exposes the configuration values of the BuildBinary class without exposing the functions.
	/// </summary>
	class UEBuildBinaryConfiguration
	{
		/// <summary>
		/// The type of binary to build
		/// </summary>
		public UEBuildBinaryType Type;

		/// <summary>
		/// The output file path. This must be set before a binary can be built using it.
		/// </summary>
		public List<FileReference> OutputFilePaths = new List<FileReference>();

		/// <summary>
		/// Returns the OutputFilePath if there is only one entry in OutputFilePaths
		/// </summary>
		public FileReference OutputFilePath
		{
			get
			{
				if (OutputFilePaths.Count != 1)
				{
					throw new BuildException("Attempted to use UEBuildBinaryConfiguration.OutputFilePath property, but there are multiple (or no) OutputFilePaths. You need to handle multiple in the code that called this (size = {0})", OutputFilePaths.Count);
				}
				return OutputFilePaths[0];
			}
		}

		/// <summary>
		/// Original output filepath. This is the original binary name before hot-reload suffix has been appended to it.
		/// </summary>
		public List<FileReference> OriginalOutputFilePaths;

		/// <summary>
		/// Returns the OriginalOutputFilePath if there is only one entry in OriginalOutputFilePaths
		/// </summary>
		public FileReference OriginalOutputFilePath
		{
			get
			{
				if (OriginalOutputFilePaths.Count != 1)
				{
					throw new BuildException("Attempted to use UEBuildBinaryConfiguration.OriginalOutputFilePath property, but there are multiple (or no) OriginalOutputFilePaths. You need to handle multiple in the code that called this (size = {0})", OriginalOutputFilePaths.Count);
				}
				return OriginalOutputFilePaths[0];
			}
		}

		/// <summary>
		/// The intermediate directory for this binary. Modules should create separate intermediate directories below this. Must be set before a binary can be built using it.
		/// </summary>
		public DirectoryReference IntermediateDirectory;

		/// <summary>
		/// If true, build exports lib
		/// </summary>
		public bool bAllowExports = false;

		/// <summary>
		/// If true, create a separate import library
		/// </summary>
		public bool bCreateImportLibrarySeparately = false;

		/// <summary>
		/// If true, include dependent libraries in the static library being built
		/// </summary>
		public bool bIncludeDependentLibrariesInLibrary = false;

		/// <summary>
		/// If false, this binary will not be compiled and it is only used to set up link environments
		/// </summary>
		public bool bAllowCompilation = true;

		/// <summary>
		/// True if this binary has any Build.cs files, if not this is probably a binary-only plugins
		/// </summary>
		public bool bHasModuleRules = true;

		/// <summary>
		/// For most binaries, this is false. If this is a cross-platform binary build for a specific platform (for example XB1 DLL for a windows editor) this will be true.
		/// </summary>
		public bool bIsCrossTarget = false;

		/// <summary>
		/// This binary is only being created because UBT is being run with the -precompile option; it is not linked into the target.
		/// </summary>
		public bool bPrecompileOnly = false;

		/// <summary>
		/// If true, creates an additional console application. Hack for Windows, where it's not possible to conditionally inherit a parent's console Window depending on how
		/// the application is invoked; you have to link the same executable with a different subsystem setting.
		/// </summary>
		public bool bBuildAdditionalConsoleApp = false;

		/// <summary>
		/// The projectfile path
		/// </summary>
		public FileReference ProjectFilePath;

		/// <summary>
		/// List of modules to link together into this executable
		/// </summary>
		public List<string> ModuleNames = new List<string>();

		/// <summary>
		/// The configuration class for a binary build.
		/// </summary>
		/// <param name="InType"></param>
		/// <param name="InOutputFilePaths"></param>
		/// <param name="InIntermediateDirectory"></param>
		/// <param name="bInAllowExports"></param>
		/// <param name="bInCreateImportLibrarySeparately"></param>
		/// <param name="bInIncludeDependentLibrariesInLibrary"></param>
		/// <param name="bInAllowCompilation"></param>
		/// <param name="bInHasModuleRules"></param>
		/// <param name="bInIsCrossTarget">For most binaries, this is false. If this is a cross-platform binary build for a specific platform (for example XB1 DLL for a windows editor) this will be true.</param>
		/// <param name="bInPrecompileOnly"></param>
		/// <param name="InProjectFilePath"></param>
		/// <param name="InModuleNames"></param>
		public UEBuildBinaryConfiguration(
				UEBuildBinaryType InType,
				IEnumerable<FileReference> InOutputFilePaths = null,
				DirectoryReference InIntermediateDirectory = null,
				bool bInAllowExports = false,
				bool bInCreateImportLibrarySeparately = false,
				bool bInIncludeDependentLibrariesInLibrary = false,
				bool bInAllowCompilation = true,
				bool bInHasModuleRules = true,
				bool bInIsCrossTarget = false,
				bool bInPrecompileOnly = false,
				FileReference InProjectFilePath = null,
				IEnumerable<string> InModuleNames = null
			)
		{
			Type = InType;
			if (InOutputFilePaths != null)
			{
				OutputFilePaths.AddRange(InOutputFilePaths);
			}
			IntermediateDirectory = InIntermediateDirectory;
			bAllowExports = bInAllowExports;
			bCreateImportLibrarySeparately = bInCreateImportLibrarySeparately;
			bIncludeDependentLibrariesInLibrary = bInIncludeDependentLibrariesInLibrary;
			bAllowCompilation = bInAllowCompilation;
			bHasModuleRules = bInHasModuleRules;
			bIsCrossTarget = bInIsCrossTarget;
			bPrecompileOnly = bInPrecompileOnly;
			ProjectFilePath = InProjectFilePath;
			if (InModuleNames != null)
			{
				ModuleNames.AddRange(InModuleNames);
			}
		}
	}

	/// <summary>
	/// A binary built by UBT.
	/// </summary>
	class UEBuildBinary
	{
		/// <summary>
		/// The build binary configuration data
		/// </summary>
		public UEBuildBinaryConfiguration Config;

		public readonly List<UEBuildModule> Modules = new List<UEBuildModule>();
		private bool bCreateImportLibrarySeparately;
		private bool bIncludeDependentLibrariesInLibrary;
		private List<string> DependentLinkLibraries;

		/// <summary>
		/// Create an instance of the class with the given configuration data
		/// </summary>
		/// <param name="InConfig">The build binary configuration to initialize the class with</param>
		public UEBuildBinary(UEBuildBinaryConfiguration InConfig)
		{
			Debug.Assert(InConfig.OutputFilePath != null && InConfig.IntermediateDirectory != null);
			Config = InConfig;
			bCreateImportLibrarySeparately = InConfig.bCreateImportLibrarySeparately;
			bIncludeDependentLibrariesInLibrary = InConfig.bIncludeDependentLibrariesInLibrary;
		}

		/// <summary>
		/// Creates all the modules referenced by this target.
		/// </summary>
		public void CreateAllDependentModules(UEBuildModule.CreateModuleDelegate CreateModule)
		{
			if (Config.bHasModuleRules)
			{
				foreach (UEBuildModule Module in Modules)
				{
					Module.RecursivelyCreateModules(CreateModule, "Target");
				}
			}
		}

		/// <summary>
		/// Builds the binary.
		/// </summary>
		/// <param name="Target">Rules for the target being built</param>
		/// <param name="ToolChain">The toolchain which to use for building</param>
		/// <param name="CompileEnvironment">The environment to compile the binary in</param>
		/// <param name="LinkEnvironment">The environment to link the binary in</param>
		/// <param name="SharedPCHs">List of templates for shared PCHs</param>
		/// <param name="WorkingSet">The working set of source files</param>
		/// <param name="ActionGraph">Graph to add build actions to</param>
		/// <returns>Set of built products</returns>
		public IEnumerable<FileItem> Build(ReadOnlyTargetRules Target, UEToolChain ToolChain, CppCompileEnvironment CompileEnvironment, LinkEnvironment LinkEnvironment, List<PrecompiledHeaderTemplate> SharedPCHs, ISourceFileWorkingSet WorkingSet, ActionGraph ActionGraph)
		{
			// Setup linking environment.
			LinkEnvironment BinaryLinkEnvironment = SetupBinaryLinkEnvironment(Target, ToolChain, LinkEnvironment, CompileEnvironment, SharedPCHs, WorkingSet, ActionGraph);

			// If we're generating projects, we only need include paths and definitions, there is no need to run the linking logic.
			if (ProjectFileGenerator.bGenerateProjectFiles)
			{
				return BinaryLinkEnvironment.InputFiles;
			}

			// If linking is disabled, our build products are just the compiled object files
			if (Target.bDisableLinking)
			{
				return BinaryLinkEnvironment.InputFiles;
			}

			// Return linked files.
			return SetupOutputFiles(ToolChain, CompileEnvironment, BinaryLinkEnvironment, ActionGraph);
		}


		/// <summary>
		/// Called to allow the binary to modify the link environment of a different binary containing 
		/// a module that depends on a module in this binary.
		/// </summary>
		/// <param name="DependentLinkEnvironment">The link environment of the dependency</param>
		public void SetupDependentLinkEnvironment(LinkEnvironment DependentLinkEnvironment)
		{
			// Cache the list of libraries in the dependent link environment between calls. We typically run this code path many times for each module.
			if (DependentLinkLibraries == null)
			{
				DependentLinkLibraries = new List<string>();
				foreach (FileReference OutputFilePath in Config.OutputFilePaths)
				{
					FileReference LibraryFileName;
					if (Config.Type == UEBuildBinaryType.StaticLibrary || DependentLinkEnvironment.Platform == CppPlatform.Mac || DependentLinkEnvironment.Platform == CppPlatform.Linux)
					{
						LibraryFileName = OutputFilePath;
					}
					else
					{
						LibraryFileName = FileReference.Combine(Config.IntermediateDirectory, OutputFilePath.GetFileNameWithoutExtension() + ".lib");
					}
					DependentLinkLibraries.Add(LibraryFileName.FullName);
				}
			}
			DependentLinkEnvironment.AdditionalLibraries.AddRange(DependentLinkLibraries);
		}

		/// <summary>
		/// Called to allow the binary to to determine if it matches the Only module "short module name".
		/// </summary>
		/// <param name="OnlyModules"></param>
		/// <returns>The OnlyModule if found, null if not</returns>
		public OnlyModule FindOnlyModule(List<OnlyModule> OnlyModules)
		{
			foreach (UEBuildModule Module in Modules)
			{
				foreach (OnlyModule OnlyModule in OnlyModules)
				{
					if (OnlyModule.OnlyModuleName.ToLower() == Module.Name.ToLower())
					{
						return OnlyModule;
					}
				}
			}
			return null;
		}

		/// <summary>
		/// Called to allow the binary to find game modules.
		/// </summary>
		/// <returns>The OnlyModule if found, null if not</returns>
		public List<UEBuildModule> FindGameModules()
		{
			List<UEBuildModule> GameModules = new List<UEBuildModule>();
			foreach (UEBuildModule Module in Modules)
			{
				if (!UnrealBuildTool.IsUnderAnEngineDirectory(Module.ModuleDirectory))
				{
					GameModules.Add(Module);
				}
			}
			return GameModules;
		}

		/// <summary>
		/// Generates a list of all modules referenced by this binary
		/// </summary>
		/// <param name="bIncludeDynamicallyLoaded">True if dynamically loaded modules (and all of their dependent modules) should be included.</param>
		/// <param name="bForceCircular">True if circular dependencies should be process</param>
		/// <returns>List of all referenced modules</returns>
		public List<UEBuildModule> GetAllDependencyModules(bool bIncludeDynamicallyLoaded, bool bForceCircular)
		{
			List<UEBuildModule> ReferencedModules = new List<UEBuildModule>();
			HashSet<UEBuildModule> IgnoreReferencedModules = new HashSet<UEBuildModule>();

			foreach (UEBuildModule Module in Modules)
			{
				if (!IgnoreReferencedModules.Contains(Module))
				{
					IgnoreReferencedModules.Add(Module);

					Module.GetAllDependencyModules(ReferencedModules, IgnoreReferencedModules, bIncludeDynamicallyLoaded, bForceCircular, bOnlyDirectDependencies: false);

					ReferencedModules.Add(Module);
				}
			}

			return ReferencedModules;
		}

		/// <summary>
		/// Generates a list of all modules referenced by this binary
		/// </summary>
		/// <param name="ReferencedBy">Map of module to the module that referenced it</param>
		/// <returns>List of all referenced modules</returns>
		public void FindModuleReferences(Dictionary<UEBuildModule, UEBuildModule> ReferencedBy)
		{
			List<UEBuildModule> ReferencedModules = new List<UEBuildModule>();
			foreach(UEBuildModule Module in Modules)
			{
				ReferencedModules.Add(Module);
				ReferencedBy.Add(Module, null);
			}

			List<UEBuildModule> DirectlyReferencedModules = new List<UEBuildModule>();
			HashSet<UEBuildModule> VisitedModules = new HashSet<UEBuildModule>();
			for(int Idx = 0; Idx < ReferencedModules.Count; Idx++)
			{
				UEBuildModule SourceModule = ReferencedModules[Idx];

				// Find all the direct references from this module
				DirectlyReferencedModules.Clear();
				SourceModule.GetAllDependencyModules(DirectlyReferencedModules, VisitedModules, false, false, true);

				// Set up the references for all the new modules
				foreach(UEBuildModule DirectlyReferencedModule in DirectlyReferencedModules)
				{
					if(!ReferencedBy.ContainsKey(DirectlyReferencedModule))
					{
						ReferencedBy.Add(DirectlyReferencedModule, SourceModule);
						ReferencedModules.Add(DirectlyReferencedModule);
					}
				}
			}
		}

		/// <summary>
		/// Sets whether to create a separate import library to resolve circular dependencies for this binary
		/// </summary>
		/// <param name="bInCreateImportLibrarySeparately">True to create a separate import library</param>
		public void SetCreateImportLibrarySeparately(bool bInCreateImportLibrarySeparately)
		{
			bCreateImportLibrarySeparately = bInCreateImportLibrarySeparately;
		}

		/// <summary>
		/// Sets whether to include dependent libraries when building a static library
		/// </summary>
		/// <param name="bInIncludeDependentLibrariesInLibrary">True to include dependent libraries</param>
		public void SetIncludeDependentLibrariesInLibrary(bool bInIncludeDependentLibrariesInLibrary)
		{
			bIncludeDependentLibrariesInLibrary = bInIncludeDependentLibrariesInLibrary;
		}

		/// <summary>
		/// Adds a module to the binary.
		/// </summary>
		/// <param name="Module">The module to add</param>
		public void AddModule(UEBuildModule Module)
		{
			if (!Modules.Contains(Module))
			{
				Modules.Add(Module);
			}
		}

		/// <summary>
		/// Gets all build products produced by this binary
		/// </summary>
		/// <param name="Target">The target being built</param>
		/// <param name="ToolChain">The platform toolchain</param>
		/// <param name="BuildProducts">Mapping of produced build product to type</param>
		/// <param name="bCreateDebugInfo">Whether debug info is enabled for this binary</param>
		public void GetBuildProducts(ReadOnlyTargetRules Target, UEToolChain ToolChain, Dictionary<FileReference, BuildProductType> BuildProducts, bool bCreateDebugInfo)
		{
			// Get the type of build products we're creating
			BuildProductType Type = BuildProductType.RequiredResource;
			switch (Config.Type)
			{
				case UEBuildBinaryType.Executable:
					Type = BuildProductType.Executable;
					break;
				case UEBuildBinaryType.DynamicLinkLibrary:
					Type = BuildProductType.DynamicLibrary;
					break;
				case UEBuildBinaryType.StaticLibrary:
					Type = BuildProductType.StaticLibrary;
					break;
			}

			// Add the primary build products
			string DebugExtension = UEBuildPlatform.GetBuildPlatform(Target.Platform).GetDebugInfoExtension(Target, Config.Type);
			foreach (FileReference OutputFilePath in Config.OutputFilePaths)
			{
				AddBuildProductAndDebugFile(OutputFilePath, Type, DebugExtension, BuildProducts, ToolChain, bCreateDebugInfo);
			}

			// Add the console app, if there is one
			if (Config.Type == UEBuildBinaryType.Executable && Config.bBuildAdditionalConsoleApp)
			{
				foreach (FileReference OutputFilePath in Config.OutputFilePaths)
				{
					AddBuildProductAndDebugFile(GetAdditionalConsoleAppPath(OutputFilePath), Type, DebugExtension, BuildProducts, ToolChain, bCreateDebugInfo);
				}
			}

			// Add any additional build products from the modules in this binary, including additional bundle resources/dylibs on Mac.
			List<string> Libraries = new List<string>();
			List<UEBuildBundleResource> BundleResources = new List<UEBuildBundleResource>();
			GatherAdditionalResources(Libraries, BundleResources);

			// Add any extra files from the toolchain
			ToolChain.ModifyBuildProducts(Target, this, Libraries, BundleResources, BuildProducts);
		}

		/// <summary>
		/// Adds a build product and its associated debug file to a receipt.
		/// </summary>
		/// <param name="OutputFile">Build product to add</param>
		/// <param name="OutputType">The type of built product</param>
		/// <param name="DebugExtension">Extension for the matching debug file (may be null).</param>
		/// <param name="BuildProducts">Map of build products to their type</param>
		/// <param name="ToolChain">The toolchain used to build these binaries</param>
		/// <param name="bCreateDebugInfo">Whether creating debug info is enabled</param>
		static void AddBuildProductAndDebugFile(FileReference OutputFile, BuildProductType OutputType, string DebugExtension, Dictionary<FileReference, BuildProductType> BuildProducts, UEToolChain ToolChain, bool bCreateDebugInfo)
		{
			BuildProducts.Add(OutputFile, OutputType);

			if (!String.IsNullOrEmpty(DebugExtension) && ToolChain.ShouldAddDebugFileToReceipt(OutputFile, OutputType) && bCreateDebugInfo)
			{
				BuildProducts.Add(OutputFile.ChangeExtension(DebugExtension), BuildProductType.SymbolFile);
			}
		}

		/// <summary>
		/// Enumerates resources which the toolchain may need may produced additional build products from. Some platforms (eg. Mac, Linux) can link directly 
		/// against .so/.dylibs, but they are also copied to the output folder by the toolchain.
		/// </summary>
		/// <param name="Libraries">List to which libraries required by this module are added</param>
		/// <param name="BundleResources">List of bundle resources required by this module</param>
		public void GatherAdditionalResources(List<string> Libraries, List<UEBuildBundleResource> BundleResources)
		{
			foreach(UEBuildModule Module in Modules)
			{
				Module.GatherAdditionalResources(Libraries, BundleResources);
			}
		}

		/// <summary>
		/// Helper function to get the console app BinaryName-Cmd.exe filename based on the binary filename.
		/// </summary>
		/// <param name="BinaryPath">Full path to the binary exe.</param>
		/// <returns></returns>
		public static FileReference GetAdditionalConsoleAppPath(FileReference BinaryPath)
		{
			return FileReference.Combine(BinaryPath.Directory, BinaryPath.GetFileNameWithoutExtension() + "-Cmd" + BinaryPath.GetExtension());
		}

		/// <summary>
		/// Checks whether the binary output paths are appropriate for the distribution
		/// level of its direct module dependencies
		/// </summary>
		public bool CheckRestrictedFolders(DirectoryReference ProjectDir, Dictionary<UEBuildModule, Dictionary<RestrictedFolder, DirectoryReference>> ModuleRestrictedFolderCache)
		{
			// Find all the modules we depend on
			Dictionary<UEBuildModule, UEBuildModule> ModuleReferencedBy = new Dictionary<UEBuildModule, UEBuildModule>();
			FindModuleReferences(ModuleReferencedBy);

			// Loop through each of the output binaries and check them separately
			bool bResult = true;
			foreach (FileReference OutputFilePath in Config.OutputFilePaths)
			{
				// Find the base directory for this binary
				DirectoryReference BaseDir;
				if(OutputFilePath.IsUnderDirectory(UnrealBuildTool.EngineDirectory))
				{
					BaseDir = UnrealBuildTool.EngineDirectory;
				}
				else if(ProjectDir != null && OutputFilePath.IsUnderDirectory(ProjectDir))
				{
					BaseDir = ProjectDir;
				}
				else
				{
					continue;
				}

				// Find the restricted folders under the base directory
				List<RestrictedFolder> BinaryFolders = RestrictedFolders.FindRestrictedFolders(BaseDir, OutputFilePath.Directory);

				// Check all the dependent modules
				foreach(UEBuildModule Module in ModuleReferencedBy.Keys)
				{
					// Find the restricted folders for this module
					Dictionary<RestrictedFolder, DirectoryReference> ModuleRestrictedFolders;
					if (!ModuleRestrictedFolderCache.TryGetValue(Module, out ModuleRestrictedFolders))
					{
						ModuleRestrictedFolders = Module.FindRestrictedFolderReferences(ProjectDir);
						ModuleRestrictedFolderCache.Add(Module, ModuleRestrictedFolders);
					}

					// Write errors for any missing paths in the output files
					foreach(KeyValuePair<RestrictedFolder, DirectoryReference> Pair in ModuleRestrictedFolders)
					{
						if(!BinaryFolders.Contains(Pair.Key))
						{
							List<string> ReferenceChain = new List<string>();
							for(UEBuildModule ReferencedModule = Module; ReferencedModule != null; ReferencedModule = ModuleReferencedBy[ReferencedModule])
							{
								ReferenceChain.Insert(0, ReferencedModule.Name);
							}
							Log.TraceError("ERROR: Output binary \"{0}\" is not in a {1} folder, but references \"{2}\" via {3}.", OutputFilePath, Pair.Key.ToString(), Pair.Value, String.Join(" -> ", ReferenceChain));
							bResult = false;
						}
					}
				}
			}
			return bResult;
		}

		/// <summary>
		/// Write information about this binary to a JSON file
		/// </summary>
		/// <param name="Writer">Writer for this binary's data</param>
		public virtual void ExportJson(JsonWriter Writer)
		{
			Writer.WriteValue("File", Config.OutputFilePath.FullName);
			Writer.WriteValue("Type", Config.Type.ToString());

			Writer.WriteArrayStart("Modules");
			foreach(string ModuleName in Config.ModuleNames)
			{
				Writer.WriteValue(ModuleName);
			}
			Writer.WriteArrayEnd();
		}

		// UEBuildBinary interface.

		bool IsBuildingDll(UEBuildBinaryType Type)
		{
			return Type == UEBuildBinaryType.DynamicLinkLibrary;
		}

		bool IsBuildingLibrary(UEBuildBinaryType Type)
		{
			return Type == UEBuildBinaryType.StaticLibrary;
		}

		private LinkEnvironment SetupBinaryLinkEnvironment(ReadOnlyTargetRules Target, UEToolChain ToolChain, LinkEnvironment LinkEnvironment, CppCompileEnvironment CompileEnvironment, List<PrecompiledHeaderTemplate> SharedPCHs, ISourceFileWorkingSet WorkingSet, ActionGraph ActionGraph)
		{
			LinkEnvironment BinaryLinkEnvironment = new LinkEnvironment(LinkEnvironment);
			HashSet<UEBuildModule> LinkEnvironmentVisitedModules = new HashSet<UEBuildModule>();
			List<UEBuildBinary> BinaryDependencies = new List<UEBuildBinary>();
			CompileEnvironment.bIsBuildingDLL = IsBuildingDll(Config.Type);
			CompileEnvironment.bIsBuildingLibrary = IsBuildingLibrary(Config.Type);

			CppCompileEnvironment BinaryCompileEnvironment = new CppCompileEnvironment(CompileEnvironment);

			// @todo: This should be in some Windows code somewhere...
			// Set the original file name macro; used in PCLaunch.rc to set the binary metadata fields.
			string OriginalFilename = (Config.OriginalOutputFilePaths != null) ?
				Config.OriginalOutputFilePaths[0].GetFileName() :
				Config.OutputFilePaths[0].GetFileName();
			BinaryCompileEnvironment.Definitions.Add("ORIGINAL_FILE_NAME=\"" + OriginalFilename + "\"");

			foreach (UEBuildModule Module in Modules)
			{
				List<FileItem> LinkInputFiles;
				if (Module.Binary == null || Module.Binary == this)
				{
					// Compile each module.
					Log.TraceVerbose("Compile module: " + Module.Name);
					LinkInputFiles = Module.Compile(Target, ToolChain, BinaryCompileEnvironment, SharedPCHs, WorkingSet, ActionGraph);

					// NOTE: Because of 'Shared PCHs', in monolithic builds the same PCH file may appear as a link input
					// multiple times for a single binary.  We'll check for that here, and only add it once.  This avoids
					// a linker warning about redundant .obj files. 
					foreach (FileItem LinkInputFile in LinkInputFiles)
					{
						if (!BinaryLinkEnvironment.InputFiles.Contains(LinkInputFile))
						{
							BinaryLinkEnvironment.InputFiles.Add(LinkInputFile);
						}
					}
				}
				else
				{
					BinaryDependencies.Add(Module.Binary);
				}

				// Allow the module to modify the link environment for the binary.
				Module.SetupPrivateLinkEnvironment(this, BinaryLinkEnvironment, BinaryDependencies, LinkEnvironmentVisitedModules);
			}


			// Allow the binary dependencies to modify the link environment.
			foreach (UEBuildBinary BinaryDependency in BinaryDependencies)
			{
				BinaryDependency.SetupDependentLinkEnvironment(BinaryLinkEnvironment);
			}

			// Remove the default resource file on Windows (PCLaunch.rc) if the user has specified their own
			if (BinaryLinkEnvironment.InputFiles.Select(Item => Path.GetFileName(Item.AbsolutePath).ToLower()).Any(Name => Name.EndsWith(".res") && !Name.EndsWith(".inl.res") && Name != "pclaunch.rc.res"))
			{
				BinaryLinkEnvironment.InputFiles.RemoveAll(x => Path.GetFileName(x.AbsolutePath).ToLower() == "pclaunch.rc.res");
			}

			// Set the link output file.
			BinaryLinkEnvironment.OutputFilePaths = Config.OutputFilePaths.ToList();

			// Set whether the link is allowed to have exports.
			BinaryLinkEnvironment.bHasExports = Config.bAllowExports;

			// Set the output folder for intermediate files
			BinaryLinkEnvironment.IntermediateDirectory = Config.IntermediateDirectory;

			// Put the non-executable output files (PDB, import library, etc) in the same directory as the production
			BinaryLinkEnvironment.OutputDirectory = Config.OutputFilePaths[0].Directory;

			// Setup link output type
			BinaryLinkEnvironment.bIsBuildingDLL = IsBuildingDll(Config.Type);
			BinaryLinkEnvironment.bIsBuildingLibrary = IsBuildingLibrary(Config.Type);

			BinaryLinkEnvironment.ProjectFile = Target.ProjectFile;

			// If we don't have any resource file, use the default or compile a custom one for this module
			if(BinaryLinkEnvironment.Platform == CppPlatform.Win32 || BinaryLinkEnvironment.Platform == CppPlatform.Win64)
			{
				if (!BinaryLinkEnvironment.InputFiles.Any(x => x.Reference.HasExtension(".res")))
				{
					if(BinaryLinkEnvironment.DefaultResourceFiles.Count > 0)
					{
						// Use the default resource file if possible
						BinaryLinkEnvironment.InputFiles.AddRange(BinaryLinkEnvironment.DefaultResourceFiles);
					}
					else
					{
						// Otherwise compile the default resource file per-binary, so that it gets the correct ORIGINAL_FILE_NAME macro.
						CppCompileEnvironment BinaryResourceCompileEnvironment = new CppCompileEnvironment(BinaryCompileEnvironment);
						BinaryResourceCompileEnvironment.OutputDirectory = DirectoryReference.Combine(BinaryResourceCompileEnvironment.OutputDirectory, Modules.First().Name);

						FileItem DefaultResourceFile = FileItem.GetItemByFileReference(FileReference.Combine(UnrealBuildTool.EngineSourceDirectory, "Runtime", "Launch", "Resources", "Windows", "PCLaunch.rc"));
						CPPOutput DefaultResourceOutput = ToolChain.CompileRCFiles(BinaryResourceCompileEnvironment, new List<FileItem> { DefaultResourceFile }, ActionGraph);
						BinaryLinkEnvironment.InputFiles.AddRange(DefaultResourceOutput.ObjectFiles);
					}
				}
			}

			// Add all the common resource files
			BinaryLinkEnvironment.InputFiles.AddRange(BinaryLinkEnvironment.CommonResourceFiles);

			return BinaryLinkEnvironment;
		}

		private List<FileItem> SetupOutputFiles(UEToolChain ToolChain, CppCompileEnvironment BinaryCompileEnvironment, LinkEnvironment BinaryLinkEnvironment, ActionGraph ActionGraph)
		{
			//
			// Regular linking action.
			//
			List<FileItem> OutputFiles = new List<FileItem>();
			if (bCreateImportLibrarySeparately)
			{
				// Mark the link environment as cross-referenced.
				BinaryLinkEnvironment.bIsCrossReferenced = true;

				if (BinaryLinkEnvironment.Platform != CppPlatform.Mac && BinaryLinkEnvironment.Platform != CppPlatform.Linux)
				{
					// Create the import library.
					OutputFiles.AddRange(ToolChain.LinkAllFiles(BinaryLinkEnvironment, true, ActionGraph));
				}
			}

			BinaryLinkEnvironment.bIncludeDependentLibrariesInLibrary = bIncludeDependentLibrariesInLibrary;

			// Link the binary.
			FileItem[] Executables = ToolChain.LinkAllFiles(BinaryLinkEnvironment, false, ActionGraph);
			OutputFiles.AddRange(Executables);

			// Produce additional console app if requested
			if (Config.bBuildAdditionalConsoleApp)
			{
				// Produce additional binary but link it as a console app
				LinkEnvironment ConsoleAppLinkEvironment = new LinkEnvironment(BinaryLinkEnvironment);
				ConsoleAppLinkEvironment.bIsBuildingConsoleApplication = true;
				ConsoleAppLinkEvironment.WindowsEntryPointOverride = "WinMainCRTStartup";		// For WinMain() instead of "main()" for Launch module
				ConsoleAppLinkEvironment.OutputFilePaths = ConsoleAppLinkEvironment.OutputFilePaths.Select(Path => GetAdditionalConsoleAppPath(Path)).ToList();

				// Link the console app executable
				OutputFiles.AddRange(ToolChain.LinkAllFiles(ConsoleAppLinkEvironment, false, ActionGraph));
			}

			foreach (FileItem Executable in Executables)
			{
				OutputFiles.AddRange(ToolChain.PostBuild(Executable, BinaryLinkEnvironment, ActionGraph));
			}

			return OutputFiles;
		}

		/// <summary>
		/// ToString implementation
		/// </summary>
		/// <returns>Returns the OutputFilePath for this binary</returns>
		public override string ToString()
		{
			return Config.OutputFilePath.FullName;
		}
	}
}
