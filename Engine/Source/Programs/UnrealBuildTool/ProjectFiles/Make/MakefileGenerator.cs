// Copyright Epic Games, Inc. All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Tools.DotNETCommon;

namespace UnrealBuildTool
{
	/// <summary>
	/// Represents a folder within the master project (e.g. Visual Studio solution)
	/// </summary>
	class MakefileFolder : MasterProjectFolder
	{
		/// <summary>
		/// Constructor
		/// </summary>
		public MakefileFolder(ProjectFileGenerator InitOwnerProjectFileGenerator, string InitFolderName)
			: base(InitOwnerProjectFileGenerator, InitFolderName)
		{
		}
	}

	class MakefileProjectFile : ProjectFile
	{
		public MakefileProjectFile(FileReference InitFilePath)
			: base(InitFilePath)
		{
		}
	}

	/// <summary>
	/// Makefile project file generator implementation
	/// </summary>
	class MakefileGenerator : ProjectFileGenerator
	{
		/// True if intellisense data should be generated (takes a while longer)
		/// Now this is needed for project target generation.
		bool bGenerateIntelliSenseData = true;

		/// Default constructor
		public MakefileGenerator(FileReference InOnlyGameProject)
			: base(InOnlyGameProject)
		{
		}

		/// True if we should include IntelliSense data in the generated project files when possible
		override public bool ShouldGenerateIntelliSenseData()
		{
			return bGenerateIntelliSenseData;
		}

		/// File extension for project files we'll be generating (e.g. ".vcxproj")
		override public string ProjectFileExtension
		{
			get
			{
				return ".mk";
			}
		}

		protected override bool WriteMasterProjectFile(ProjectFile UBTProject, PlatformProjectGeneratorCollection PlatformProjectGenerators)
		{
			bool bSuccess = true;
			return bSuccess;
		}

		private bool WriteMakefile()
		{
			string GameProjectFile = "";
			string BuildCommand = "";
			string ProjectBuildCommand = "";

			string MakeGameProjectFile = "";

			string UnrealRootPath = UnrealBuildTool.RootDirectory.FullName;

			if (!String.IsNullOrEmpty(GameProjectName))
			{
				GameProjectFile = OnlyGameProject.FullName;
				MakeGameProjectFile = "GAMEPROJECTFILE =" + GameProjectFile + "\n";
				ProjectBuildCommand = "PROJECTBUILD = bash \"$(UNREALROOTPATH)/Engine/Build/BatchFiles/Linux/RunMono.sh\" \"$(UNREALROOTPATH)/Engine/Binaries/DotNET/UnrealBuildTool.exe\"\n";
			}

			BuildCommand = "BUILD = bash \"$(UNREALROOTPATH)/Engine/Build/BatchFiles/Linux/Build.sh\"\n";

			string FileName = "Makefile"; // MasterProjectName + ".mk";
			StringBuilder MakefileContent = new StringBuilder();
			MakefileContent.Append(
				"# Makefile generated by MakefileGenerator.cs\n" +
				"# *DO NOT EDIT*\n\n" +
				"UNREALROOTPATH = " + UnrealRootPath + "\n" +
				MakeGameProjectFile + "\n" +
				"TARGETS ="
			);
			String MakeProjectCmdArg = "";
			String MakeBuildCommand = "";
			foreach (ProjectFile Project in GeneratedProjectFiles)
			{
				foreach (ProjectTarget TargetFile in Project.ProjectTargets)
				{
					if (TargetFile.TargetFilePath == null)
					{
						continue;
					}

					string TargetFileName = TargetFile.TargetFilePath.GetFileNameWithoutExtension();
					string Basename = TargetFileName.Substring(0, TargetFileName.LastIndexOf(".Target", StringComparison.InvariantCultureIgnoreCase));

					foreach (UnrealTargetConfiguration CurConfiguration in Enum.GetValues(typeof(UnrealTargetConfiguration)))
					{
						if (CurConfiguration != UnrealTargetConfiguration.Unknown && CurConfiguration != UnrealTargetConfiguration.Development)
						{
							if (InstalledPlatformInfo.IsValidConfiguration(CurConfiguration, EProjectType.Code))
							{
								string Confname = Enum.GetName(typeof(UnrealTargetConfiguration), CurConfiguration);
								MakefileContent.Append(String.Format(" \\\n\t{0}-Linux-{1} ", Basename, Confname));
							}
						}
					}
					MakefileContent.Append(" \\\n\t" + Basename);
				}
			}
			MakefileContent.Append("\\\n\tconfigure");

			MakefileContent.Append("\n\n" + BuildCommand + ProjectBuildCommand + "\n" +
				"all: StandardSet\n\n" +
				"RequiredTools: CrashReportClient-Linux-Shipping CrashReportClientEditor-Linux-Shipping ShaderCompileWorker UnrealLightmass\n\n" +
				"StandardSet: RequiredTools UnrealFrontend UE4Editor UnrealInsights\n\n" +
				"DebugSet: RequiredTools UnrealFrontend-Linux-Debug UE4Editor-Linux-Debug\n\n"
			);

			foreach (ProjectFile Project in GeneratedProjectFiles)
			{
				foreach (ProjectTarget TargetFile in Project.ProjectTargets)
				{
					if (TargetFile.TargetFilePath == null)
					{
						continue;
					}

					string TargetFileName = TargetFile.TargetFilePath.GetFileNameWithoutExtension();
					string Basename = TargetFileName.Substring(0, TargetFileName.LastIndexOf(".Target", StringComparison.InvariantCultureIgnoreCase));

					if (Basename == GameProjectName || Basename == (GameProjectName + "Editor"))
					{
						MakeProjectCmdArg = " -project=\"$(GAMEPROJECTFILE)\"";
						MakeBuildCommand = "$(PROJECTBUILD)";
					}
					else
					{
						MakeBuildCommand = "$(BUILD)";
					}

					foreach (UnrealTargetConfiguration CurConfiguration in Enum.GetValues(typeof(UnrealTargetConfiguration)))
					{
						if (Basename == GameProjectName || Basename == (GameProjectName + "Editor"))
						{
							MakeProjectCmdArg = " -project=\"$(GAMEPROJECTFILE)\"";
							MakeBuildCommand = "$(PROJECTBUILD)";
						}
						else
						{
							MakeBuildCommand = "$(BUILD)";
						}

						if (CurConfiguration != UnrealTargetConfiguration.Unknown && CurConfiguration != UnrealTargetConfiguration.Development)
						{
							if (InstalledPlatformInfo.IsValidConfiguration(CurConfiguration, EProjectType.Code))
							{
								string Confname = Enum.GetName(typeof(UnrealTargetConfiguration), CurConfiguration);
								MakefileContent.Append(String.Format("\n{1}-Linux-{2}:\n\t {0} {1} Linux {2} {3} $(ARGS)\n", MakeBuildCommand, Basename, Confname, MakeProjectCmdArg));
							}
						}
					}
					MakefileContent.Append(String.Format("\n{1}:\n\t {0} {1} Linux Development {2} $(ARGS)\n", MakeBuildCommand, Basename, MakeProjectCmdArg));
				}
			}

			MakefileContent.Append("\nconfigure:\n");
			if (!String.IsNullOrEmpty(GameProjectName))
			{
				// Make sure UBT is updated.
				MakefileContent.Append("\txbuild /property:Configuration=Development /verbosity:quiet /nologo ");
				MakefileContent.Append("\"$(UNREALROOTPATH)/Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool.csproj\"\n");
				MakefileContent.Append("\t$(PROJECTBUILD) -projectfiles -project=\"\\\"$(GAMEPROJECTFILE)\\\"\" -game -engine \n");
			}
			else
			{
				MakefileContent.Append("\tbash \"$(UNREALROOTPATH)/GenerateProjectFiles.sh\" \n");
			}

			MakefileContent.Append("\n.PHONY: $(TARGETS)\n");
			FileReference FullFileName = FileReference.Combine(MasterProjectPath, FileName);
			return WriteFileIfChanged(FullFileName.FullName, MakefileContent.ToString());
		}

		/// ProjectFileGenerator interface
		//protected override bool WriteMasterProjectFile( ProjectFile UBTProject )
		protected override bool WriteProjectFiles(PlatformProjectGeneratorCollection PlatformProjectGenerators)
		{
			return WriteMakefile();
		}

		/// ProjectFileGenerator interface
		public override MasterProjectFolder AllocateMasterProjectFolder(ProjectFileGenerator InitOwnerProjectFileGenerator, string InitFolderName)
		{
			return new MakefileFolder(InitOwnerProjectFileGenerator, InitFolderName);
		}

		/// ProjectFileGenerator interface
		/// <summary>
		/// Allocates a generator-specific project file object
		/// </summary>
		/// <param name="InitFilePath">Path to the project file</param>
		/// <returns>The newly allocated project file object</returns>
		protected override ProjectFile AllocateProjectFile(FileReference InitFilePath)
		{
			return new MakefileProjectFile(InitFilePath);
		}

		/// ProjectFileGenerator interface
		public override void CleanProjectFiles(DirectoryReference InMasterProjectDirectory, string InMasterProjectName, DirectoryReference InIntermediateProjectFilesDirectory)
		{
		}
	}
}
