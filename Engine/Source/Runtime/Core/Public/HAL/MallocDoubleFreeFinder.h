// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreTypes.h"
#include "HAL/CriticalSection.h"
#include "HAL/PlatformTLS.h"
#include "HAL/MemoryBase.h"
#include "Containers/Array.h"
#include "Containers/Map.h"

class CORE_API FMallocDoubleFreeFinder final : public FMalloc
{
	/** Malloc we're based on, aka using under the hood												*/
	FMalloc*								UsedMalloc;
	bool									Initialized;

public:
	FMallocDoubleFreeFinder(FMalloc* InMalloc);

	/**
	 * Malloc
	 */
	virtual void* Malloc(SIZE_T Count, uint32 Alignment = DEFAULT_ALIGNMENT) override;

	/**
	 * Realloc
	 */
	virtual void* Realloc(void* Original, SIZE_T Count, uint32 Alignment = DEFAULT_ALIGNMENT)  override;

	/**
	 * Free
	 */
	virtual void Free(void* Original) override;

	/**
	* For some allocators this will return the actual size that should be requested to eliminate
	* internal fragmentation. The return value will always be >= Count. This can be used to grow
	* and shrink containers to optimal sizes.
	* This call is always fast and thread safe with no locking.
	*/
	virtual SIZE_T QuantizeSize(SIZE_T Count, uint32 Alignment)  override
	{
		return UsedMalloc->QuantizeSize(Count, Alignment);
	}

	/**
	* If possible determine the size of the memory allocated at the given address
	*
	* @param Original - Pointer to memory we are checking the size of
	* @param SizeOut - If possible, this value is set to the size of the passed in pointer
	* @return true if succeeded
	*/
	virtual bool GetAllocationSize(void *Original, SIZE_T &SizeOut)  override
	{
		return UsedMalloc->GetAllocationSize(Original, SizeOut);
	}

	/**
	* Releases as much memory as possible. Must be called from the main thread.
	*/
	virtual void Trim(bool bTrimThreadCaches) override
	{
		UsedMalloc->Trim(bTrimThreadCaches);
	}

	/**
	* Set up TLS caches on the current thread. These are the threads that we can trim.
	*/
	virtual void SetupTLSCachesOnCurrentThread() override
	{
		UsedMalloc->SetupTLSCachesOnCurrentThread();
	}

	/**
	* Clears the TLS caches on the current thread and disables any future caching.
	*/
	virtual void ClearAndDisableTLSCachesOnCurrentThread() override
	{
		UsedMalloc->ClearAndDisableTLSCachesOnCurrentThread();
	}

	/**
	*	Initializes stats metadata. We need to do this as soon as possible, but cannot be done in the constructor
	*	due to the FName::StaticInit
	*/
	virtual void InitializeStatsMetadata() override
	{
		UsedMalloc->InitializeStatsMetadata();
	}

	/**
	 * Handles any commands passed in on the command line
	 */
	virtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) override;

	/** Called once per frame, gathers and sets all memory allocator statistics into the corresponding stats. MUST BE THREAD SAFE. */
	virtual void UpdateStats() override
	{
		UsedMalloc->UpdateStats();
	}

	/** Writes allocator stats from the last update into the specified destination. */
	virtual void GetAllocatorStats(FGenericMemoryStats& out_Stats) override
	{
		UsedMalloc->GetAllocatorStats(out_Stats);
	}

	/** Dumps current allocator stats to the log. */
	virtual void DumpAllocatorStats(class FOutputDevice& Ar) override
	{
		UsedMalloc->DumpAllocatorStats(Ar);
	}

	/**
	 * Returns if the allocator is guaranteed to be thread-safe and therefore
	 * doesn't need a unnecessary thread-safety wrapper around it.
	 */
	virtual bool IsInternallyThreadSafe() const override
	{
		return true;
	}

	/**
	 * Validates the allocator's heap
	 */
	virtual bool ValidateHeap() override
	{
		return UsedMalloc->ValidateHeap();
	}

	/**
	 * Gets descriptive name for logging purposes.
	 *
	 * @return pointer to human-readable malloc name
	 */
	virtual const TCHAR* GetDescriptiveName() override
	{
		return UsedMalloc->GetDescriptiveName();
	}

	static const SIZE_T MallocDoubleFreeFinderMaxCallStackDepth = 64;
	static const SIZE_T MallocDoubleFreeFinderCallStackEntriesToSkipCount = 2;

	struct FCallStackInfoDoublleFreeFinder
	{
		uint32 Count;
		uint64 FramePointers[MallocDoubleFreeFinderMaxCallStackDepth];
	};

	/** Used as a key in our current allocations/freed allocations maps*/
	struct FCallStackMapKey
	{
		uint32 CRC; /* Generated by the platforms capture call stack function, if the platform you are working with doesn't generate this for you crc32 the call stack array manually */
		uint64 *CallStack;

		FCallStackMapKey(uint32 InCRC, uint64* InCallStack)
			: CRC(InCRC),
			CallStack(InCallStack)
		{
		}

		friend bool operator==(const FCallStackMapKey& A, const FCallStackMapKey& B)
		{
			if (A.CRC != B.CRC)
			{
				return false;
			}
			for (int i = 0; i < MallocDoubleFreeFinderMaxCallStackDepth; ++i)
			{
				uint64 APtr = A.CallStack[i];
				uint64 BPtr = B.CallStack[i];
				if (APtr != BPtr)
				{
					return false;
				}
				if (APtr == 0)
					break;
			}
			return true;
		}

		friend inline uint32 GetTypeHash(const FCallStackMapKey& InKey)
		{
			return InKey.CRC;
		}
	};

	/**
	 * If you get an allocation/memory error outside of the allocator you can call this directly
	 * It will dump a callstack of the last allocator free most likely to have caused the problem to the log, if you have symbols loaded
	 * Might be useful to pass an access violation ptr to this!
	 */
	void TrackSpecial(void* Ptr);

	void Init();
	void DumpStackTraceToLog(int32 StackIndex);


	static FMalloc* OverrideIfEnabled(FMalloc*InUsedAlloc);

	friend class FMallocDoubleFreeFinder;
	friend class FScopeDisableDoubleFreeFinder;

protected:
	FCriticalSection CriticalSection;
	uint32 DisabledTLS;

	FORCEINLINE void IncDisabled()
	{
		uint64_t DisabledCount = (uint64_t)FPlatformTLS::GetTlsValue(DisabledTLS);
		++DisabledCount;
		FPlatformTLS::SetTlsValue(DisabledTLS, (void*)DisabledCount);
	}

	FORCEINLINE void DecDisabled()
	{
		uint64_t DisabledCount = (uint64_t)FPlatformTLS::GetTlsValue(DisabledTLS);
		--DisabledCount;
		FPlatformTLS::SetTlsValue(DisabledTLS, (void*)DisabledCount);
	}
	bool IsDisabled()
	{
		return FPlatformTLS::GetTlsValue(DisabledTLS) != 0;
	}
	void TrackMalloc(void* Ptr, uint32 Size, int32 CallStackIndex);
	void TrackFree(void* Ptr, uint32 OldSize, int32 CallStackIndex);
	void TrackRealloc(void* OldPtr, void* NewPtr, uint32 NewSize, uint32 OldSize, int32 CallStackIndex);

	FRWLock RWLock;

	TMap<FCallStackMapKey, int32> CallStackMapKeyToCallStackIndexMap;
	TArray<FCallStackInfoDoublleFreeFinder> CallStackInfoArray;


	struct TrackedAllocationData
	{
		SIZE_T Size;
		int32 CallStackIndex;
		TrackedAllocationData() :
			Size(0),
			CallStackIndex(-1)
		{
		};
		TrackedAllocationData(SIZE_T InRequestedSize, int32 InCallStackIndex)
		{
			Size = InRequestedSize;
			CallStackIndex = InCallStackIndex;
		};
		~TrackedAllocationData()
		{
			Size = 0;
			CallStackIndex = -1;
		};
	};
	TMap<const void* const, TrackedAllocationData> TrackedCurrentAllocations;	// Pointer as a key to a call stack for all the current allocations we known about
	TMap<const void* const, TrackedAllocationData> TrackedFreeAllocations;		// Pointer as a key to a call stack for all allocations that have been freed

	int32 GetCallStackIndex();
};

extern CORE_API FMallocDoubleFreeFinder* GMallocDoubleFreeFinder;
extern CORE_API bool GMallocDoubleFreeFinderEnabled;


/**
 * Disables the double free finder for the current thread
 * Need to do this as we might allocate memory for the allocators tracking data, that can't be tracked!
 */

class FScopeDisableDoubleFreeFinder
{
public:

	FScopeDisableDoubleFreeFinder()
	{
		GMallocDoubleFreeFinder->IncDisabled();
	}

	~FScopeDisableDoubleFreeFinder()
	{
		GMallocDoubleFreeFinder->DecDisabled();
	}
};


