// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	AnimBlueprintGeneratedClass.cpp: The object generated by compiling a AnimBlueprint
=============================================================================*/ 

#include "Animation/AnimBlueprintGeneratedClass.h"
#include "Serialization/ObjectWriter.h"
#include "Serialization/ObjectReader.h"
#include "ObjectEditorUtils.h"
#include "BonePose.h"
#include "Animation/AnimNodeBase.h"
#include "Animation/AnimInstance.h"
#include "UObject/AnimObjectVersion.h"
#include "UObject/ReleaseObjectVersion.h"
#include "Animation/AnimNode_LinkedAnimGraph.h"
#include "Animation/AnimNode_Root.h"
#include "Animation/AnimNode_LinkedInputPose.h"
#include "Animation/AnimNode_LinkedAnimLayer.h"
#include "Animation/AnimNode_AssetPlayerBase.h"
#include "Animation/AnimNode_StateMachine.h"
#include "EdGraph/EdGraphNode.h"
#include "Algo/Reverse.h"

/////////////////////////////////////////////////////
// FStateMachineDebugData

UEdGraphNode* FStateMachineDebugData::FindNodeFromStateIndex(int32 StateIndex) const
{
	if (const TWeakObjectPtr<UEdGraphNode>* pResult = NodeToStateIndex.FindKey(StateIndex))
	{
		return pResult->Get();
	}
	return NULL;
}

UEdGraphNode* FStateMachineDebugData::FindNodeFromTransitionIndex(int32 TransitionIndex) const
{
	if (const TWeakObjectPtr<UEdGraphNode>* pResult = NodeToTransitionIndex.FindKey(TransitionIndex))
	{
		return pResult->Get();
	}
	return NULL;
}

/////////////////////////////////////////////////////
// FAnimBlueprintDebugData

#if WITH_EDITORONLY_DATA

void FAnimBlueprintDebugData::TakeSnapshot(UAnimInstance* Instance)
{
	checkSlow(&(CastChecked<UAnimBlueprintGeneratedClass>((UObject*)(Instance->GetClass()))->GetAnimBlueprintDebugData()) == this);

	if (SnapshotBuffer == NULL)
	{
		SnapshotBuffer = new TSimpleRingBuffer<FAnimationFrameSnapshot>(30*30);
	}

	SnapshotBuffer->WriteNewElementInitialized().InitializeFromInstance(Instance);
}

void FAnimBlueprintDebugData::ResetSnapshotBuffer()
{
	if (SnapshotBuffer != NULL)
	{
		delete SnapshotBuffer;
		SnapshotBuffer = NULL;
	}
}

float FAnimBlueprintDebugData::GetSnapshotLengthInSeconds()
{
	if (SnapshotBuffer != NULL)
	{
		//@TODO: Shouldn't use hardcoded snapshot length; ideally we actually use timestamps, etc...
		return SnapshotBuffer->Num() * 1.0f / 30.0f;
	}

	return 0.0f;
}

int32 FAnimBlueprintDebugData::GetSnapshotLengthInFrames()
{
	if (SnapshotBuffer != NULL)
	{
		//@TODO: Shouldn't use hardcoded snapshot length; ideally we actually use timestamps, etc...
		return SnapshotBuffer->Num();
	}

	return 0;
}

void FAnimBlueprintDebugData::SetSnapshotIndex(UAnimInstance* Instance, int32 NewIndex)
{
	if (SnapshotBuffer != NULL)
	{
		int32 SavedIndex = SnapshotIndex;
		int32 ClampedIndex = FMath::Clamp<int32>(NewIndex, 0, SnapshotBuffer->Num() - 1);
		SnapshotIndex = (NewIndex == INDEX_NONE) ? INDEX_NONE : ClampedIndex;

		// Apply the desired snapshot (or the most recent one if free-running was selected)
		if ((SnapshotIndex != SavedIndex) && (SnapshotBuffer->Num() > 0))
		{
			(*SnapshotBuffer)(ClampedIndex).CopyToInstance(Instance);
		}
	}
}

void FAnimBlueprintDebugData::SetSnapshotIndexByTime(UAnimInstance* Instance, double TargetTime)
{
	const int32 SavedIndex = SnapshotIndex;

	int32 NewIndex = INDEX_NONE;

	if ((SnapshotBuffer != NULL) && (SnapshotBuffer->Num() > 0))
	{
		if ((TargetTime < (*SnapshotBuffer)(0).TimeStamp) && (TargetTime >= (*SnapshotBuffer)(SnapshotBuffer->Num()-1).TimeStamp))
		{
			for (NewIndex = SnapshotBuffer->Num() - 1; NewIndex > 0; --NewIndex)
			{
				if (TargetTime < (*SnapshotBuffer)(NewIndex-1).TimeStamp)
				{
					break;
				}
			}
		}
	}

	// Determine which snapshot to use
	SetSnapshotIndex(Instance, NewIndex);

	// Stomp on the time that was played back from the snapshot since we were given an exact one
	Instance->CurrentLifeTimerScrubPosition = TargetTime;
}

void FAnimBlueprintDebugData::ResetNodeVisitSites()
{
	UpdatedNodesThisFrame.Empty(UpdatedNodesThisFrame.Num());
	StateData.Empty(StateData.Num());
	NodeValuesThisFrame.Empty(NodeValuesThisFrame.Num());
	SequencePlayerRecordsThisFrame.Empty(SequencePlayerRecordsThisFrame.Num());
	BlendSpacePlayerRecordsThisFrame.Empty(BlendSpacePlayerRecordsThisFrame.Num());
}

void FAnimBlueprintDebugData::RecordNodeVisit(int32 TargetNodeIndex, int32 SourceNodeIndex, float BlendWeight)
{
	UpdatedNodesThisFrame.Emplace(SourceNodeIndex, TargetNodeIndex, BlendWeight);
}

void FAnimBlueprintDebugData::RecordNodeVisitArray(const TArray<FNodeVisit>& Nodes)
{
	UpdatedNodesThisFrame.Append(Nodes);
}

void FAnimBlueprintDebugData::RecordStateData(int32 StateMachineIndex, int32 StateIndex, float Weight, float ElapsedTime)
{
	StateData.Emplace(StateMachineIndex, StateIndex, Weight, ElapsedTime);
}

void FAnimBlueprintDebugData::RecordNodeValue(int32 InNodeID, const FString& InText)
{
	NodeValuesThisFrame.Emplace(InText, InNodeID);
}

void FAnimBlueprintDebugData::RecordSequencePlayer(int32 InNodeID, float InPosition, float InLength, int32 InFrameCount)
{
	SequencePlayerRecordsThisFrame.Emplace(InNodeID, InPosition, InLength, InFrameCount);
}

void FAnimBlueprintDebugData::RecordBlendSpacePlayer(int32 InNodeID, UBlendSpaceBase* InBlendSpace, float InPositionX, float InPositionY, float InPositionZ)
{
	BlendSpacePlayerRecordsThisFrame.Emplace(InNodeID, InBlendSpace, InPositionX, InPositionY, InPositionZ);
}

void FAnimBlueprintDebugData::AddPoseWatch(int32 NodeID, FColor Color)
{
	for (FAnimNodePoseWatch& PoseWatch : AnimNodePoseWatch)
	{
		if (PoseWatch.NodeID == NodeID)
		{
			PoseWatch.PoseDrawColour = Color;
			return;
		}
	}

	//Not found so make new one
	AnimNodePoseWatch.Add(FAnimNodePoseWatch());
	FAnimNodePoseWatch& NewAnimNodePoseWatch = AnimNodePoseWatch.Last();
	NewAnimNodePoseWatch.NodeID = NodeID;
	NewAnimNodePoseWatch.PoseDrawColour = Color;
	NewAnimNodePoseWatch.PoseInfo = MakeShareable(new FCompactHeapPose());
	NewAnimNodePoseWatch.Object = nullptr;
}

void FAnimBlueprintDebugData::RemovePoseWatch(int32 NodeID)
{
	for (int32 PoseWatchIdx = 0; PoseWatchIdx < AnimNodePoseWatch.Num(); ++PoseWatchIdx)
	{
		if (AnimNodePoseWatch[PoseWatchIdx].NodeID == NodeID)
		{
			AnimNodePoseWatch.RemoveAtSwap(PoseWatchIdx);
			return;
		}
	}
}

void FAnimBlueprintDebugData::UpdatePoseWatchColour(int32 NodeID, FColor Color)
{
	for (FAnimNodePoseWatch& PoseWatch : AnimNodePoseWatch)
	{
		if (PoseWatch.NodeID == NodeID)
		{
			PoseWatch.PoseDrawColour = Color;
			return;
		}
	}
}
/////////////////////////////////////////////////////
// FBinaryObjectWriter

class FBinaryObjectWriter : public FObjectWriter
{
public:
	FBinaryObjectWriter(UObject* Obj, TArray<uint8>& InBytes)
		: FObjectWriter(InBytes)
	{
		this->SetWantBinaryPropertySerialization(true);
		Obj->Serialize(*this);
	}
};

/////////////////////////////////////////////////////
// FBinaryObjectReader

class FBinaryObjectReader : public FObjectReader
{
public:
	FBinaryObjectReader(UObject* Obj, TArray<uint8>& InBytes)
		: FObjectReader(InBytes)
	{
		this->SetWantBinaryPropertySerialization(true);
		Obj->Serialize(*this);
	}
};

/////////////////////////////////////////////////////
// FAnimationFrameSnapshot

void FAnimationFrameSnapshot::InitializeFromInstance(UAnimInstance* Instance)
{
	FBinaryObjectWriter Writer(Instance, SerializedData);
	TimeStamp = Instance->LifeTimer;
}

void FAnimationFrameSnapshot::CopyToInstance(UAnimInstance* Instance)
{
	FBinaryObjectReader Reader(Instance, SerializedData);
	Instance->CurrentLifeTimerScrubPosition = TimeStamp;
}

#endif

/////////////////////////////////////////////////////
// UAnimBlueprintGeneratedClas

UAnimBlueprintGeneratedClass::UAnimBlueprintGeneratedClass(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UAnimBlueprintGeneratedClass::Serialize(FArchive& Ar)
{
	Ar.UsingCustomVersion(FAnimObjectVersion::GUID);
	Ar.UsingCustomVersion(FReleaseObjectVersion::GUID);

	Super::Serialize(Ar);
}

void UAnimBlueprintGeneratedClass::Link(FArchive& Ar, bool bRelinkExistingProperties)
{
	Super::Link(Ar, bRelinkExistingProperties);

	// @TODO: Shouldn't be necessary to clear these, but currently the class gets linked twice during compilation
	AnimNodeProperties.Empty();
	LinkedAnimGraphNodeProperties.Empty();
	LinkedAnimLayerNodeProperties.Empty();
	PreUpdateNodeProperties.Empty();
	DynamicResetNodeProperties.Empty();
	StateMachineNodeProperties.Empty();
	InitializationNodeProperties.Empty();

#if WITH_EDITORONLY_DATA
	for (FExposedValueHandler& Handler : EvaluateGraphExposedInputs)
	{
		// handle potential renames of the class package
		Handler.ValueHandlerNodeProperty.ResolveWithRenamedStructPackage(this);
		check(Handler.ValueHandlerNodeProperty.Get() || Handler.ValueHandlerNodeProperty.IsPathToFieldEmpty());
	}
#endif // WITH_EDITORONLY_DATA

#if WITH_EDITOR
	// This relies on the entire class being fully loaded, this is not the case with EDL async-loading, in which case the functions are generated in PostLoad
	GenerateAnimationBlueprintFunctions();
#endif // WITH_EDITOR

	// Initialize the various tracked node arrays & fix up function internals
	for (TFieldIterator<FProperty> It(this); It; ++It)
	{
		if (FStructProperty* StructProp = CastField<FStructProperty>(*It))
		{
			if (StructProp->Struct->IsChildOf(FAnimNode_Base::StaticStruct()))
			{
				if(StructProp->Struct == FAnimNode_LinkedAnimGraph::StaticStruct())
				{
					LinkedAnimGraphNodeProperties.Add(StructProp);
				}
				else if(StructProp->Struct == FAnimNode_LinkedAnimLayer::StaticStruct())
				{
					LinkedAnimLayerNodeProperties.Add(StructProp);
				}
				else if(StructProp->Struct->IsChildOf(FAnimNode_StateMachine::StaticStruct()))
				{
					StateMachineNodeProperties.Add(StructProp);
				}
				AnimNodeProperties.Add(StructProp);
			}
		}
	}
}

void UAnimBlueprintGeneratedClass::PurgeClass(bool bRecompilingOnLoad)
{
	Super::PurgeClass(bRecompilingOnLoad);

	AnimNotifies.Empty();
	TargetSkeleton = NULL;
#if WITH_EDITORONLY_DATA
	AnimBlueprintDebugData = FAnimBlueprintDebugData();
#endif

	BakedStateMachines.Empty();
}

uint8* UAnimBlueprintGeneratedClass::GetPersistentUberGraphFrame(UObject* Obj, UFunction* FuncToCheck) const
{
	if(!IsInGameThread())
	{
		// we cant use the persistent frame if we are executing in parallel (as we could potentially thunk to BP)
		return nullptr;
	}

	return Super::GetPersistentUberGraphFrame(Obj, FuncToCheck);
}

void UAnimBlueprintGeneratedClass::PostLoadDefaultObject(UObject* Object)
{
	Super::PostLoadDefaultObject(Object);

	UAnimBlueprintGeneratedClass* Iter = this;
	while(Iter)
	{
		FExposedValueHandler::ClassInitialization(Iter->EvaluateGraphExposedInputs, Object);
		Iter = Cast<UAnimBlueprintGeneratedClass>(Iter->GetSuperClass());
	}

	LinkFunctionsToDefaultObjectNodes(Object);
}

void UAnimBlueprintGeneratedClass::PostLoad()
{
	Super::PostLoad();
	GenerateAnimationBlueprintFunctions();

	// Post-load property access library
	PropertyAccess::PostLoadLibrary(PropertyAccessLibrary);
}

void UAnimBlueprintGeneratedClass::GenerateAnimationBlueprintFunctions()
{
	AnimBlueprintFunctions.Empty();

	static const FName DefaultAnimGraphName("AnimGraph");
	// Patch up blueprint function info
	for (TFieldIterator<UFunction> It(this); It; ++It)
	{
		bool bFoundOutput = false;
#if WITH_EDITOR
		// In editor we can grab the group from metadata, otherwise we need to wait until CDO post load (LinkFunctionsToDefaultObjectNodes)
		FText CategoryText = FObjectEditorUtils::GetCategoryText(*It);
		FName Group = CategoryText.IsEmpty() ? NAME_None : FName(*CategoryText.ToString());
#endif
		FStructProperty* OutputPoseNodeProperty = nullptr;
		TArray<FName> InputPoseNames;
		TArray<int32> InputPoseNodeIndices;
		TArray<FStructProperty*> InputPoseNodeProperties;
		TArray<FProperty*> InputProperties;

		// grab the input/output poses, their indices will be patched up later once the CDO is loaded in PostLoadDefaultObject
		for (TFieldIterator<FProperty> ItParam(*It); ItParam; ++ItParam)
		{
			if (FStructProperty* StructProperty = CastField<FStructProperty>(*ItParam))
			{
				if (StructProperty->Struct->IsChildOf(FPoseLink::StaticStruct()))
				{
					if (StructProperty->GetPropertyFlags() & CPF_OutParm)
					{
						if (!bFoundOutput)
						{
							OutputPoseNodeProperty = StructProperty;
							bFoundOutput = true;
						}
						else
						{
							// our required signature needs us to have a single post link output, so null it out if we find more than one
							OutputPoseNodeProperty = nullptr;
						}
					}
					else
					{
						InputPoseNames.Add(StructProperty->GetFName());
						InputPoseNodeIndices.Add(INDEX_NONE);
						InputPoseNodeProperties.Add(nullptr);
					}
				}
				else
				{
					InputProperties.Add(*ItParam);
				}
			}
			else
			{
				InputProperties.Add(*ItParam);
			}
		}

		if (OutputPoseNodeProperty)
		{
			// We use the undecorated name here, so trim the postfix
			FAnimBlueprintFunction* AnimBlueprintFunction = nullptr;

			FName FunctionName = It->GetFName();

			// Make sure that the default graph is at index 0
			if (FunctionName == DefaultAnimGraphName)
			{
				AnimBlueprintFunction = &AnimBlueprintFunctions.Insert_GetRef(FAnimBlueprintFunction(FunctionName), 0);
			}
			else
			{
				AnimBlueprintFunction = &AnimBlueprintFunctions.Emplace_GetRef(FunctionName);
			}

#if WITH_EDITOR
			AnimBlueprintFunction->Group = Group;
#endif
			AnimBlueprintFunction->InputPoseNames.Append(MoveTemp(InputPoseNames));
			AnimBlueprintFunction->InputPoseNodeIndices.Append(MoveTemp(InputPoseNodeIndices));
			AnimBlueprintFunction->InputPoseNodeProperties.Append(MoveTemp(InputPoseNodeProperties));
			AnimBlueprintFunction->InputProperties.Append(MoveTemp(InputProperties));
		}
	}
}

void UAnimBlueprintGeneratedClass::LinkFunctionsToDefaultObjectNodes(UObject* DefaultObject)
{
	PreUpdateNodeProperties.Empty();
	DynamicResetNodeProperties.Empty();
	InitializationNodeProperties.Empty();

	// Link functions to their nodes
	for(int32 AnimNodeIndex = 0; AnimNodeIndex < AnimNodeProperties.Num(); ++AnimNodeIndex)
	{
		FStructProperty* StructProperty = AnimNodeProperties[AnimNodeIndex];
		if (StructProperty->Struct->IsChildOf(FAnimNode_Root::StaticStruct()))
		{
			FAnimNode_Root* RootNode = StructProperty->ContainerPtrToValuePtr<FAnimNode_Root>(DefaultObject);
			if(FAnimBlueprintFunction* FoundFunction = AnimBlueprintFunctions.FindByPredicate([RootNode](const FAnimBlueprintFunction& InFunction){ return InFunction.Name == RootNode->Name; }))
			{
				FoundFunction->Group = RootNode->Group;
				FoundFunction->OutputPoseNodeIndex = AnimNodeIndex;
				FoundFunction->OutputPoseNodeProperty = StructProperty;
			}
		}
		else if(StructProperty->Struct->IsChildOf(FAnimNode_LinkedInputPose::StaticStruct()))
		{
			FAnimNode_LinkedInputPose* LinkedInputPoseNode = StructProperty->ContainerPtrToValuePtr<FAnimNode_LinkedInputPose>(DefaultObject);
			if(FAnimBlueprintFunction* FoundFunction = AnimBlueprintFunctions.FindByPredicate([LinkedInputPoseNode](const FAnimBlueprintFunction& InFunction){ return InFunction.Name == LinkedInputPoseNode->Graph; }))
			{
				for(int32 InputIndex = 0; InputIndex < FoundFunction->InputPoseNames.Num(); ++InputIndex)
				{
					if(FoundFunction->InputPoseNames[InputIndex] == LinkedInputPoseNode->Name)
					{
						FoundFunction->InputPoseNodeIndices[InputIndex] = AnimNodeIndex;
						FoundFunction->InputPoseNodeProperties[InputIndex] = StructProperty;
					}
				}
			}
		}
		else if(StructProperty->Struct->IsChildOf(FAnimNode_Base::StaticStruct()))
		{
			FAnimNode_Base* Node = StructProperty->ContainerPtrToValuePtr<FAnimNode_Base>(DefaultObject);
			if(Node->NeedsDynamicReset())
			{
				DynamicResetNodeProperties.Add(StructProperty);
			}

			if(Node->HasPreUpdate())
			{
				PreUpdateNodeProperties.Add(StructProperty);
			}

			if(Node->NeedsOnInitializeAnimInstance())
			{
				InitializationNodeProperties.Add(StructProperty);
			}
		}
	}

	// Determine whether functions are 'implemented'
	for(FAnimBlueprintFunction& AnimBlueprintFunction : AnimBlueprintFunctions)
	{
		if(AnimBlueprintFunction.OutputPoseNodeProperty)
		{
			FAnimNode_Root* RootNode = AnimBlueprintFunction.OutputPoseNodeProperty->ContainerPtrToValuePtr<FAnimNode_Root>(DefaultObject);
			if(RootNode->Result.LinkID != INDEX_NONE)
			{
				AnimBlueprintFunction.bImplemented = true;
			}
		}
	}

#if DO_CHECK
	if(!(GetClassFlags() | CLASS_Transient))
	{
		// Now verify we fixed up all our functions
		for(const FAnimBlueprintFunction& AnimBlueprintFunction : AnimBlueprintFunctions)
		{
			check(AnimBlueprintFunction.Name != NAME_None);
			check(AnimBlueprintFunction.OutputPoseNodeIndex != INDEX_NONE);
			check(AnimBlueprintFunction.OutputPoseNodeProperty != nullptr);
			check(AnimBlueprintFunction.InputPoseNames.Num() == AnimBlueprintFunction.InputPoseNodeIndices.Num());
			check(AnimBlueprintFunction.InputPoseNames.Num() == AnimBlueprintFunction.InputPoseNodeProperties.Num());

			for(int32 InputIndex = 0; InputIndex < AnimBlueprintFunction.InputPoseNames.Num(); ++InputIndex)
			{
				check(AnimBlueprintFunction.InputPoseNames[InputIndex] != NAME_None);
				check(AnimBlueprintFunction.InputPoseNodeIndices[InputIndex] != INDEX_NONE);
				check(AnimBlueprintFunction.InputPoseNodeProperties[InputIndex] != nullptr);
			}
		}
	}
#endif
}

#if WITH_EDITORONLY_DATA

const int32* UAnimBlueprintGeneratedClass::GetNodePropertyIndexFromGuid(FGuid Guid, EPropertySearchMode::Type SearchMode /*= EPropertySearchMode::OnlyThis*/)
{
	if (SearchMode == EPropertySearchMode::OnlyThis)
	{
		return AnimBlueprintDebugData.NodeGuidToIndexMap.Find(Guid);
	}
	else
	{
		TArray<const UBlueprintGeneratedClass*> BlueprintHierarchy;
		GetGeneratedClassesHierarchy(this, BlueprintHierarchy);

		for (const UBlueprintGeneratedClass* Blueprint : BlueprintHierarchy)
		{
			if (const UAnimBlueprintGeneratedClass* AnimBlueprintClass = Cast<UAnimBlueprintGeneratedClass>(Blueprint))
			{
				const int32* NodeIndex = AnimBlueprintClass->AnimBlueprintDebugData.NodeGuidToIndexMap.Find(Guid);

				if (NodeIndex)
				{
					return NodeIndex;
				}
			}

		}
	}

	return NULL;
}

const UEdGraphNode* UAnimBlueprintGeneratedClass::GetVisualNodeFromNodePropertyIndex(int32 PropertyIndex) const
{
	const int32 ReversedPropertyIndex = AnimNodeProperties.Num() - PropertyIndex - 1;
	const TWeakObjectPtr<const UEdGraphNode>* Node = AnimBlueprintDebugData.NodePropertyIndexToNodeMap.Find(ReversedPropertyIndex);
	return Node ? Node->Get() : nullptr;
}

#endif // WITH_EDITORONLY_DATA
