// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "Chaos/ParticleHandle.h"
#include "Chaos/PBDCollisionConstraints.h"
#include "Chaos/PBDRigidsSOAs.h"
#include "Chaos/EvolutionResimCache.h"

#include <atomic>

namespace Chaos
{
	/**
	 * Consumes lists of contacts generated by an FCollisionDetector (which may be on a separate thread) and
	 * then adds the contacts to the CollisionConstraints in a thread-safe way.
	 */
	class FAsyncCollisionReceiver
	{
	public:

		struct FPerParticleData
		{
			TArray<FRigidBodyPointContactConstraint> Single;
			TArray<FRigidBodySweptPointContactConstraint> SingleSwept;
			TArray<FRigidBodyMultiPointContactConstraint> Multi;

			void Reset()
			{
				Single.Reset();
				SingleSwept.Reset();
				Multi.Reset();
			}
		};

		FAsyncCollisionReceiver(FPBDCollisionConstraints& InCollisionConstraints, FEvolutionResimCache* InResimCache)
			: CollisionConstraints(InCollisionConstraints)
			, ResimCache(InResimCache)
			, NumSingle(0)
			, NumSingleSwept(0)
			, NumMulti(0)
		{
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it finds collisions. This is the whole
		 * collection for the provided particle index and it's never used beyond here so we can move
		 * the whole container over per particle.
		 */
		void ReceiveCollisions(FCollisionConstraintsArray&& Constraints, int32 EntryIndex)
		{
			FPerParticleData& Data = ParticleCache[EntryIndex];

			NumSingle.fetch_add(Constraints.SinglePointConstraints.Num(), std::memory_order_relaxed);
			NumSingleSwept.fetch_add(Constraints.SinglePointSweptConstraints.Num(), std::memory_order_relaxed);
			NumMulti.fetch_add(Constraints.MultiPointConstraints.Num(), std::memory_order_relaxed);

			Data.Single = MoveTemp(Constraints.SinglePointConstraints);
			Data.SingleSwept = MoveTemp(Constraints.SinglePointSweptConstraints);
			Data.Multi = MoveTemp(Constraints.MultiPointConstraints);
		}

		/**
		 * Called by a CollisionDetector (possibly in a task) when it wants to append extra collisions
		 * to an entry. This will be slower than just receiving a full container as above as we will
		 * need to expand the array.
		 * Make sure when calling append it's after all possible calls to Receive for that particle
		 * or the array will be emptied as receive just moves the container into its internal store
		 */
		void AppendCollisions(const FCollisionConstraintsArray& Constraints, int32 EntryIndex)
		{
			FPerParticleData& Data = ParticleCache[EntryIndex];

			NumSingle.fetch_add(Constraints.SinglePointConstraints.Num(), std::memory_order_relaxed);
			NumSingleSwept.fetch_add(Constraints.SinglePointSweptConstraints.Num(), std::memory_order_relaxed);
			NumMulti.fetch_add(Constraints.MultiPointConstraints.Num(), std::memory_order_relaxed);

			Data.Single.Append(Constraints.SinglePointConstraints);
			Data.SingleSwept.Append(Constraints.SinglePointSweptConstraints);
			Data.Multi.Append(Constraints.MultiPointConstraints);
		}

		/**
		 * Add received collisions to the container (on physics thread)
		 */
		void ProcessCollisions()
		{
			FPBDCollisionConstraints::FConstraintAppendScope AppendHelper = CollisionConstraints.BeginAppendScope();

			{
				AppendHelper.ReserveSingle(NumSingle.load(std::memory_order_relaxed));
				AppendHelper.ReserveSingleSwept(NumSingleSwept.load(std::memory_order_relaxed));
				AppendHelper.ReserveMulti(NumMulti.load(std::memory_order_relaxed));
			}

			{
				for(FPerParticleData& Data : ParticleCache)
				{
					AppendHelper.Append(MoveTemp(Data.Single));
					AppendHelper.Append(MoveTemp(Data.SingleSwept));
					AppendHelper.Append(MoveTemp(Data.Multi));
					Data.Reset();
				}
			}

			{
				QUICK_SCOPE_CYCLE_COUNTER(QSTAT_ResetParticleCache);
				ParticleCache.Reset();

				NumSingle.store(0, std::memory_order_relaxed);
				NumSingleSwept.store(0, std::memory_order_relaxed);
				NumMulti.store(0, std::memory_order_relaxed);
			}

			if(ResimCache)
			{
				ResimCache->SaveConstraints(CollisionConstraints.GetConstraintsArray());
			}

			return;
		}

		void Prepare(int32 NumMaxParticles)
		{
			ParticleCache.Reset(NumMaxParticles);
			ParticleCache.SetNum(NumMaxParticles);
		}

		int32 CacheNum() const
		{
			return ParticleCache.Num();
		}

	private:

		FPBDCollisionConstraints& CollisionConstraints;
		FEvolutionResimCache* ResimCache;

		TArray<FPerParticleData> ParticleCache;
		std::atomic<int32> NumSingle;
		std::atomic<int32> NumSingleSwept;
		std::atomic<int32> NumMulti;
	};


	/**
	 * A synchronous collision receiver. This immediately adds collisions to the container as they are received. 
	 * /see FAsyncCollisionReceiver
	 */
	class FSyncCollisionReceiver
	{
	public:
		FSyncCollisionReceiver(FPBDCollisionConstraints& InCollisionConstraints)
			: CollisionConstraints(InCollisionConstraints)
		{
		}

		FCollisionConstraintsArray& GetConstraintsArray()
		{
			return CollisionConstraints.GetConstraintsArray();
		}

		/**
		 * Does nothing - we write directly into the Constraints Container
		 */
		void ReceiveCollisions(const FCollisionConstraintsArray& Constraints)
		{
		}

		/**
		 * Does nothing - we write directly into the Constraints Container
		 */
		void ProcessCollisions()
		{
		}

	private:
		FPBDCollisionConstraints& CollisionConstraints;
	};
}