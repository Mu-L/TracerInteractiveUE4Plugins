// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2017 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "ClothingPhysicalMeshParameters.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace clothing
{

using namespace ClothingPhysicalMeshParametersNS;

const char* const ClothingPhysicalMeshParametersFactory::vptr =
    NvParameterized::getVptr<ClothingPhysicalMeshParameters, ClothingPhysicalMeshParameters::ClassAlignment>();

const uint32_t NumParamDefs = 74;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 35, 43, 52, 53, 54, 62, 71, 72, 73, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 19, 21, 23,
	25, 26, 27, 29, 30, 31, 32, 33, 34, 9, 11, 13, 15, 16, 17, 18, 20, 22, 24, 28, 36,
	37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 55, 56, 57, 58, 59, 60, 61,
	63, 64, 65, 66, 67, 68, 69, 70,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 10 },
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->physicalMesh), CHILDREN(10), 22 }, // physicalMesh
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numVertices), NULL, 0 }, // physicalMesh.numVertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numSimulatedVertices), NULL, 0 }, // physicalMesh.numSimulatedVertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numMaxDistance0Vertices), NULL, 0 }, // physicalMesh.numMaxDistance0Vertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numIndices), NULL, 0 }, // physicalMesh.numIndices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numSimulatedIndices), NULL, 0 }, // physicalMesh.numSimulatedIndices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numBonesPerVertex), NULL, 0 }, // physicalMesh.numBonesPerVertex
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->vertices), CHILDREN(32), 1 }, // physicalMesh.vertices
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.vertices[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->normals), CHILDREN(33), 1 }, // physicalMesh.normals
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.normals[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->skinningNormals), CHILDREN(34), 1 }, // physicalMesh.skinningNormals
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.skinningNormals[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->constrainCoefficients), CHILDREN(35), 1 }, // physicalMesh.constrainCoefficients
	{ TYPE_STRUCT, false, 1 * sizeof(ConstrainCoefficient_Type), CHILDREN(36), 3 }, // physicalMesh.constrainCoefficients[]
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->maxDistance), NULL, 0 }, // physicalMesh.constrainCoefficients[].maxDistance
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->collisionSphereRadius), NULL, 0 }, // physicalMesh.constrainCoefficients[].collisionSphereRadius
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->collisionSphereDistance), NULL, 0 }, // physicalMesh.constrainCoefficients[].collisionSphereDistance
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->boneIndices), CHILDREN(39), 1 }, // physicalMesh.boneIndices
	{ TYPE_U16, false, 1 * sizeof(uint16_t), NULL, 0 }, // physicalMesh.boneIndices[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->boneWeights), CHILDREN(40), 1 }, // physicalMesh.boneWeights
	{ TYPE_F32, false, 1 * sizeof(float), NULL, 0 }, // physicalMesh.boneWeights[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->optimizationData), CHILDREN(41), 1 }, // physicalMesh.optimizationData
	{ TYPE_U8, false, 1 * sizeof(uint8_t), NULL, 0 }, // physicalMesh.optimizationData[]
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->hasNegativeBackstop), NULL, 0 }, // physicalMesh.hasNegativeBackstop
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->isClosed), NULL, 0 }, // physicalMesh.isClosed
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->indices), CHILDREN(42), 1 }, // physicalMesh.indices
	{ TYPE_U32, false, 1 * sizeof(uint32_t), NULL, 0 }, // physicalMesh.indices[]
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->maximumMaxDistance), NULL, 0 }, // physicalMesh.maximumMaxDistance
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->physicalMeshSorting), NULL, 0 }, // physicalMesh.physicalMeshSorting
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->shortestEdgeLength), NULL, 0 }, // physicalMesh.shortestEdgeLength
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->averageEdgeLength), NULL, 0 }, // physicalMesh.averageEdgeLength
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->isTetrahedralMesh), NULL, 0 }, // physicalMesh.isTetrahedralMesh
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->flipNormals), NULL, 0 }, // physicalMesh.flipNormals
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionUpB), CHILDREN(43), 1 }, // transitionUpB
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapB_Type), CHILDREN(44), 6 }, // transitionUpB[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->vtxTetraBary), NULL, 0 }, // transitionUpB[].vtxTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionUpB[].vertexIndexPlusOffset
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->nrmTetraBary), NULL, 0 }, // transitionUpB[].nrmTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->faceIndex0), NULL, 0 }, // transitionUpB[].faceIndex0
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->tetraIndex), NULL, 0 }, // transitionUpB[].tetraIndex
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->submeshIndex), NULL, 0 }, // transitionUpB[].submeshIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionUp), CHILDREN(50), 1 }, // transitionUp
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapD_Type), CHILDREN(51), 7 }, // transitionUp[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexBary), NULL, 0 }, // transitionUp[].vertexBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex0), NULL, 0 }, // transitionUp[].vertexIndex0
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->normalBary), NULL, 0 }, // transitionUp[].normalBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex1), NULL, 0 }, // transitionUp[].vertexIndex1
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->tangentBary), NULL, 0 }, // transitionUp[].tangentBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex2), NULL, 0 }, // transitionUp[].vertexIndex2
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionUp[].vertexIndexPlusOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionUpThickness), NULL, 0 }, // transitionUpThickness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionUpOffset), NULL, 0 }, // transitionUpOffset
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionDownB), CHILDREN(58), 1 }, // transitionDownB
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapB_Type), CHILDREN(59), 6 }, // transitionDownB[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->vtxTetraBary), NULL, 0 }, // transitionDownB[].vtxTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionDownB[].vertexIndexPlusOffset
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->nrmTetraBary), NULL, 0 }, // transitionDownB[].nrmTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->faceIndex0), NULL, 0 }, // transitionDownB[].faceIndex0
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->tetraIndex), NULL, 0 }, // transitionDownB[].tetraIndex
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->submeshIndex), NULL, 0 }, // transitionDownB[].submeshIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionDown), CHILDREN(65), 1 }, // transitionDown
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapD_Type), CHILDREN(66), 7 }, // transitionDown[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexBary), NULL, 0 }, // transitionDown[].vertexBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex0), NULL, 0 }, // transitionDown[].vertexIndex0
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->normalBary), NULL, 0 }, // transitionDown[].normalBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex1), NULL, 0 }, // transitionDown[].vertexIndex1
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->tangentBary), NULL, 0 }, // transitionDown[].tangentBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex2), NULL, 0 }, // transitionDown[].vertexIndex2
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionDown[].vertexIndexPlusOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionDownThickness), NULL, 0 }, // transitionDownThickness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionDownOffset), NULL, 0 }, // transitionDownOffset
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->referenceCount), NULL, 0 }, // referenceCount
};


bool ClothingPhysicalMeshParameters::mBuiltFlag = false;
NvParameterized::MutexType ClothingPhysicalMeshParameters::mBuiltFlagMutex;

ClothingPhysicalMeshParameters::ClothingPhysicalMeshParameters(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ClothingPhysicalMeshParametersFactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ClothingPhysicalMeshParameters::~ClothingPhysicalMeshParameters()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ClothingPhysicalMeshParameters::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ClothingPhysicalMeshParameters();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* ClothingPhysicalMeshParameters::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* ClothingPhysicalMeshParameters::getParameterDefinitionTree(void) const
{
	ClothingPhysicalMeshParameters* tmpParam = const_cast<ClothingPhysicalMeshParameters*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType ClothingPhysicalMeshParameters::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType ClothingPhysicalMeshParameters::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ClothingPhysicalMeshParameters::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ClothingPhysicalMeshParameters::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void ClothingPhysicalMeshParameters::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ClothingPhysicalMeshParameters::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="physicalMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("physicalMesh", TYPE_STRUCT, "PhysicalMesh", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The physical mesh data.", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="physicalMesh.numVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("numVertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of vertices of this mesh", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="physicalMesh.numSimulatedVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("numSimulatedVertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of simulated vertices of this mesh", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="physicalMesh.numMaxDistance0Vertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("numMaxDistance0Vertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of vertices that have max distance set to 0", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="physicalMesh.numIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("numIndices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of indices of this mesh", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="physicalMesh.numSimulatedIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("numSimulatedIndices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of simulated indices of this mesh", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="physicalMesh.numBonesPerVertex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("numBonesPerVertex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of bone weights/indices per vertex", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="physicalMesh.vertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("vertices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Array of vertices", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[8].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="physicalMesh.vertices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("vertices", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Array of vertices", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="physicalMesh.normals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("normals", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals provided by the user. The mesh-mesh skinning will try to restore them as good\nas possible throughout simulation. Note, they can differ from the skinningNormals quite drastically.\n", true);
		HintTable[2].init("shortDescription", "Array of normals", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[10].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="physicalMesh.normals[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("normals", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals provided by the user. The mesh-mesh skinning will try to restore them as good\nas possible throughout simulation. Note, they can differ from the skinningNormals quite drastically.\n", true);
		HintTable[2].init("shortDescription", "Array of normals", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="physicalMesh.skinningNormals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("skinningNormals", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals of the original mesh. They reflect what should come out of physics but the output\ncan be distorted because parts of the simulation mesh are turned off, resulting in wrong normal computation.\nThey are needed for the flags.CorrectSimulationNormals actorflag.\n", true);
		HintTable[2].init("shortDescription", "Array of skinning normals", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[12].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="physicalMesh.skinningNormals[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("skinningNormals", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals of the original mesh. They reflect what should come out of physics but the output\ncan be distorted because parts of the simulation mesh are turned off, resulting in wrong normal computation.\nThey are needed for the flags.CorrectSimulationNormals actorflag.\n", true);
		HintTable[2].init("shortDescription", "Array of skinning normals", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="physicalMesh.constrainCoefficients"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("constrainCoefficients", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are not provided but computed by copying values from the graphical mesh to the physical mesh.\n", true);
		HintTable[2].init("shortDescription", "The clothing constrain coefficients for this mesh.", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[14].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="physicalMesh.constrainCoefficients[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("constrainCoefficients", TYPE_STRUCT, "ConstrainCoefficient", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are not provided but computed by copying values from the graphical mesh to the physical mesh.\n", true);
		HintTable[2].init("shortDescription", "The clothing constrain coefficients for this mesh.", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="physicalMesh.constrainCoefficients[].maxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("maxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Maximum distance this vertex is allowed to travel from its skinned position.", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="physicalMesh.constrainCoefficients[].collisionSphereRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("collisionSphereRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Size of the Backstop collision sphere.", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="physicalMesh.constrainCoefficients[].collisionSphereDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("collisionSphereDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Distance of the Backstop collision sphere.", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="physicalMesh.boneIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("boneIndices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone indices per vertex", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[19].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="physicalMesh.boneIndices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("boneIndices", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone indices per vertex", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="physicalMesh.boneWeights"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("boneWeights", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone weights per vertex", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[21].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="physicalMesh.boneWeights[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("boneWeights", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone weights per vertex", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="physicalMesh.optimizationData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("optimizationData", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Each byte contains info for 2 vertices.\nbits 0-3: number of actual bones for that vertex (with boneWeight > 0)\nbit 4: set if that vertex has a negative backstop\nbits 5-7: same data for next vertex\n", true);
		HintTable[2].init("shortDescription", "Per Vertex Number of boneweights > 0, bool if it has negative collision distance", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[23].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="physicalMesh.optimizationData[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("optimizationData", TYPE_U8, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Each byte contains info for 2 vertices.\nbits 0-3: number of actual bones for that vertex (with boneWeight > 0)\nbit 4: set if that vertex has a negative backstop\nbits 5-7: same data for next vertex\n", true);
		HintTable[2].init("shortDescription", "Per Vertex Number of boneweights > 0, bool if it has negative collision distance", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="physicalMesh.hasNegativeBackstop"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("hasNegativeBackstop", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "True if at least 1 has negative collision distance", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="physicalMesh.isClosed"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("isClosed", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "True if all edges have two adjacent triangles", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="physicalMesh.indices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("indices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The index buffer", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[27].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="physicalMesh.indices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("indices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The index buffer", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="physicalMesh.maximumMaxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("maximumMaxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum max-distance value for all the vertices.", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="physicalMesh.physicalMeshSorting"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("physicalMeshSorting", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Physical mesh sorting", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="physicalMesh.shortestEdgeLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("shortestEdgeLength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mesh statistic, only needed for debug rendering.", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="physicalMesh.averageEdgeLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("averageEdgeLength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mesh statistic, useful for selecting the thickness of the mesh-mesh skinning.", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="physicalMesh.isTetrahedralMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("isTetrahedralMesh", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Are we storing triangles or tetrahedrons in this mesh.", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="physicalMesh.flipNormals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("flipNormals", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "True when the model has been transformed to left-handed space.", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="transitionUpB"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("transitionUpB", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[35].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="transitionUpB[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("transitionUpB", TYPE_STRUCT, "SkinClothMapB", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="transitionUpB[].vtxTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("vtxTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the implicit tetrahedron.", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="transitionUpB[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="transitionUpB[].nrmTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("nrmTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="transitionUpB[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="transitionUpB[].tetraIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("tetraIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Selects which of the 6 implicit tetrahedrons is used for the mapping.", true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="transitionUpB[].submeshIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("submeshIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "This is only needed during the authoring stage and thus does not need to be serialized.", true);
		HintTable[2].init("shortDescription", "Index into which Physical Submesh/LoD this element of the mapping belongs to.", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="transitionUp"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("transitionUp", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[43].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="transitionUp[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("transitionUp", TYPE_STRUCT, "SkinClothMapD", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="transitionUp[].vertexBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("vertexBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the triangle.", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="transitionUp[].vertexIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("vertexIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="transitionUp[].normalBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("normalBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="transitionUp[].vertexIndex1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("vertexIndex1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="transitionUp[].tangentBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("tangentBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (position+tangent). When position is subtracted this will result in the tangent again.", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="transitionUp[].vertexIndex2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("vertexIndex2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="transitionUp[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="transitionUpThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("transitionUpThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The thickness of the transition map", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="transitionUpOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("transitionUpOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The normal offset of the transition map", true);
		ParamDefTable[53].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="transitionDownB"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("transitionDownB", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[54].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="transitionDownB[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("transitionDownB", TYPE_STRUCT, "SkinClothMapB", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="transitionDownB[].vtxTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("vtxTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the implicit tetrahedron.", true);
		ParamDefTable[56].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="transitionDownB[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[57].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="transitionDownB[].nrmTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("nrmTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[58].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="transitionDownB[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[59].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="transitionDownB[].tetraIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("tetraIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Selects which of the 6 implicit tetrahedrons is used for the mapping.", true);
		ParamDefTable[60].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="transitionDownB[].submeshIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("submeshIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "This is only needed during the authoring stage and thus does not need to be serialized.", true);
		HintTable[2].init("shortDescription", "Index into which Physical Submesh/LoD this element of the mapping belongs to.", true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=62, longName="transitionDown"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[62];
		ParamDef->init("transitionDown", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[62].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[62].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=63, longName="transitionDown[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[63];
		ParamDef->init("transitionDown", TYPE_STRUCT, "SkinClothMapD", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[63].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=64, longName="transitionDown[].vertexBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[64];
		ParamDef->init("vertexBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the triangle.", true);
		ParamDefTable[64].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=65, longName="transitionDown[].vertexIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[65];
		ParamDef->init("vertexIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[65].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=66, longName="transitionDown[].normalBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[66];
		ParamDef->init("normalBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[66].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=67, longName="transitionDown[].vertexIndex1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[67];
		ParamDef->init("vertexIndex1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[67].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=68, longName="transitionDown[].tangentBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[68];
		ParamDef->init("tangentBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (position+tangent). When position is subtracted this will result in the tangent again.", true);
		ParamDefTable[68].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=69, longName="transitionDown[].vertexIndex2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[69];
		ParamDef->init("vertexIndex2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[69].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=70, longName="transitionDown[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[70];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[70].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=71, longName="transitionDownThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[71];
		ParamDef->init("transitionDownThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The thickness of the transition map", true);
		ParamDefTable[71].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=72, longName="transitionDownOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[72];
		ParamDef->init("transitionDownOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The normal offset of the transition map", true);
		ParamDefTable[72].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=73, longName="referenceCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[73];
		ParamDef->init("referenceCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("READONLY", uint64_t(1), true);
		ParamDefTable[73].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("READONLY", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Only used internally, do not modify", true);
		ParamDefTable[73].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[10];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(35);
		Children[2] = PDEF_PTR(43);
		Children[3] = PDEF_PTR(52);
		Children[4] = PDEF_PTR(53);
		Children[5] = PDEF_PTR(54);
		Children[6] = PDEF_PTR(62);
		Children[7] = PDEF_PTR(71);
		Children[8] = PDEF_PTR(72);
		Children[9] = PDEF_PTR(73);

		ParamDefTable[0].setChildren(Children, 10);
	}

	// SetChildren for: nodeIndex=1, longName="physicalMesh"
	{
		static Definition* Children[22];
		Children[0] = PDEF_PTR(2);
		Children[1] = PDEF_PTR(3);
		Children[2] = PDEF_PTR(4);
		Children[3] = PDEF_PTR(5);
		Children[4] = PDEF_PTR(6);
		Children[5] = PDEF_PTR(7);
		Children[6] = PDEF_PTR(8);
		Children[7] = PDEF_PTR(10);
		Children[8] = PDEF_PTR(12);
		Children[9] = PDEF_PTR(14);
		Children[10] = PDEF_PTR(19);
		Children[11] = PDEF_PTR(21);
		Children[12] = PDEF_PTR(23);
		Children[13] = PDEF_PTR(25);
		Children[14] = PDEF_PTR(26);
		Children[15] = PDEF_PTR(27);
		Children[16] = PDEF_PTR(29);
		Children[17] = PDEF_PTR(30);
		Children[18] = PDEF_PTR(31);
		Children[19] = PDEF_PTR(32);
		Children[20] = PDEF_PTR(33);
		Children[21] = PDEF_PTR(34);

		ParamDefTable[1].setChildren(Children, 22);
	}

	// SetChildren for: nodeIndex=8, longName="physicalMesh.vertices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(9);

		ParamDefTable[8].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=10, longName="physicalMesh.normals"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(11);

		ParamDefTable[10].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=12, longName="physicalMesh.skinningNormals"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(13);

		ParamDefTable[12].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=14, longName="physicalMesh.constrainCoefficients"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(15);

		ParamDefTable[14].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=15, longName="physicalMesh.constrainCoefficients[]"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(16);
		Children[1] = PDEF_PTR(17);
		Children[2] = PDEF_PTR(18);

		ParamDefTable[15].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=19, longName="physicalMesh.boneIndices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(20);

		ParamDefTable[19].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=21, longName="physicalMesh.boneWeights"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(22);

		ParamDefTable[21].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=23, longName="physicalMesh.optimizationData"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(24);

		ParamDefTable[23].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=27, longName="physicalMesh.indices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(28);

		ParamDefTable[27].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=35, longName="transitionUpB"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(36);

		ParamDefTable[35].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=36, longName="transitionUpB[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(37);
		Children[1] = PDEF_PTR(38);
		Children[2] = PDEF_PTR(39);
		Children[3] = PDEF_PTR(40);
		Children[4] = PDEF_PTR(41);
		Children[5] = PDEF_PTR(42);

		ParamDefTable[36].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=43, longName="transitionUp"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(44);

		ParamDefTable[43].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=44, longName="transitionUp[]"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(45);
		Children[1] = PDEF_PTR(46);
		Children[2] = PDEF_PTR(47);
		Children[3] = PDEF_PTR(48);
		Children[4] = PDEF_PTR(49);
		Children[5] = PDEF_PTR(50);
		Children[6] = PDEF_PTR(51);

		ParamDefTable[44].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=54, longName="transitionDownB"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(55);

		ParamDefTable[54].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=55, longName="transitionDownB[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(56);
		Children[1] = PDEF_PTR(57);
		Children[2] = PDEF_PTR(58);
		Children[3] = PDEF_PTR(59);
		Children[4] = PDEF_PTR(60);
		Children[5] = PDEF_PTR(61);

		ParamDefTable[55].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=62, longName="transitionDown"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(63);

		ParamDefTable[62].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=63, longName="transitionDown[]"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(64);
		Children[1] = PDEF_PTR(65);
		Children[2] = PDEF_PTR(66);
		Children[3] = PDEF_PTR(67);
		Children[4] = PDEF_PTR(68);
		Children[5] = PDEF_PTR(69);
		Children[6] = PDEF_PTR(70);

		ParamDefTable[63].setChildren(Children, 7);
	}

	mBuiltFlag = true;

}
void ClothingPhysicalMeshParameters::initStrings(void)
{
}

void ClothingPhysicalMeshParameters::initDynamicArrays(void)
{
	physicalMesh.vertices.buf = NULL;
	physicalMesh.vertices.isAllocated = true;
	physicalMesh.vertices.elementSize = sizeof(physx::PxVec3);
	physicalMesh.vertices.arraySizes[0] = 0;
	physicalMesh.normals.buf = NULL;
	physicalMesh.normals.isAllocated = true;
	physicalMesh.normals.elementSize = sizeof(physx::PxVec3);
	physicalMesh.normals.arraySizes[0] = 0;
	physicalMesh.skinningNormals.buf = NULL;
	physicalMesh.skinningNormals.isAllocated = true;
	physicalMesh.skinningNormals.elementSize = sizeof(physx::PxVec3);
	physicalMesh.skinningNormals.arraySizes[0] = 0;
	physicalMesh.constrainCoefficients.buf = NULL;
	physicalMesh.constrainCoefficients.isAllocated = true;
	physicalMesh.constrainCoefficients.elementSize = sizeof(ConstrainCoefficient_Type);
	physicalMesh.constrainCoefficients.arraySizes[0] = 0;
	physicalMesh.boneIndices.buf = NULL;
	physicalMesh.boneIndices.isAllocated = true;
	physicalMesh.boneIndices.elementSize = sizeof(uint16_t);
	physicalMesh.boneIndices.arraySizes[0] = 0;
	physicalMesh.boneWeights.buf = NULL;
	physicalMesh.boneWeights.isAllocated = true;
	physicalMesh.boneWeights.elementSize = sizeof(float);
	physicalMesh.boneWeights.arraySizes[0] = 0;
	physicalMesh.optimizationData.buf = NULL;
	physicalMesh.optimizationData.isAllocated = true;
	physicalMesh.optimizationData.elementSize = sizeof(uint8_t);
	physicalMesh.optimizationData.arraySizes[0] = 0;
	physicalMesh.indices.buf = NULL;
	physicalMesh.indices.isAllocated = true;
	physicalMesh.indices.elementSize = sizeof(uint32_t);
	physicalMesh.indices.arraySizes[0] = 0;
	transitionUpB.buf = NULL;
	transitionUpB.isAllocated = true;
	transitionUpB.elementSize = sizeof(SkinClothMapB_Type);
	transitionUpB.arraySizes[0] = 0;
	transitionUp.buf = NULL;
	transitionUp.isAllocated = true;
	transitionUp.elementSize = sizeof(SkinClothMapD_Type);
	transitionUp.arraySizes[0] = 0;
	transitionDownB.buf = NULL;
	transitionDownB.isAllocated = true;
	transitionDownB.elementSize = sizeof(SkinClothMapB_Type);
	transitionDownB.arraySizes[0] = 0;
	transitionDown.buf = NULL;
	transitionDown.isAllocated = true;
	transitionDown.elementSize = sizeof(SkinClothMapD_Type);
	transitionDown.arraySizes[0] = 0;
}

void ClothingPhysicalMeshParameters::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	physicalMesh.numVertices = uint32_t(0);
	physicalMesh.numSimulatedVertices = uint32_t(0);
	physicalMesh.numIndices = uint32_t(0);
	physicalMesh.numSimulatedIndices = uint32_t(0);
	physicalMesh.numBonesPerVertex = uint32_t(0);
	physicalMesh.hasNegativeBackstop = bool(false);
	physicalMesh.isClosed = bool(false);
	physicalMesh.maximumMaxDistance = float(0);
	physicalMesh.physicalMeshSorting = uint32_t(0);
	physicalMesh.shortestEdgeLength = float(0);
	physicalMesh.averageEdgeLength = float(0);
	physicalMesh.isTetrahedralMesh = bool(false);
	physicalMesh.flipNormals = bool(false);
	transitionUpThickness = float(0);
	transitionUpOffset = float(0);
	transitionDownThickness = float(0);
	transitionDownOffset = float(0);
	referenceCount = uint32_t(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ClothingPhysicalMeshParameters::initReferences(void)
{
}

void ClothingPhysicalMeshParameters::freeDynamicArrays(void)
{
	if (physicalMesh.vertices.isAllocated && physicalMesh.vertices.buf)
	{
		mParameterizedTraits->free(physicalMesh.vertices.buf);
	}
	if (physicalMesh.normals.isAllocated && physicalMesh.normals.buf)
	{
		mParameterizedTraits->free(physicalMesh.normals.buf);
	}
	if (physicalMesh.skinningNormals.isAllocated && physicalMesh.skinningNormals.buf)
	{
		mParameterizedTraits->free(physicalMesh.skinningNormals.buf);
	}
	if (physicalMesh.constrainCoefficients.isAllocated && physicalMesh.constrainCoefficients.buf)
	{
		mParameterizedTraits->free(physicalMesh.constrainCoefficients.buf);
	}
	if (physicalMesh.boneIndices.isAllocated && physicalMesh.boneIndices.buf)
	{
		mParameterizedTraits->free(physicalMesh.boneIndices.buf);
	}
	if (physicalMesh.boneWeights.isAllocated && physicalMesh.boneWeights.buf)
	{
		mParameterizedTraits->free(physicalMesh.boneWeights.buf);
	}
	if (physicalMesh.optimizationData.isAllocated && physicalMesh.optimizationData.buf)
	{
		mParameterizedTraits->free(physicalMesh.optimizationData.buf);
	}
	if (physicalMesh.indices.isAllocated && physicalMesh.indices.buf)
	{
		mParameterizedTraits->free(physicalMesh.indices.buf);
	}
	if (transitionUpB.isAllocated && transitionUpB.buf)
	{
		mParameterizedTraits->free(transitionUpB.buf);
	}
	if (transitionUp.isAllocated && transitionUp.buf)
	{
		mParameterizedTraits->free(transitionUp.buf);
	}
	if (transitionDownB.isAllocated && transitionDownB.buf)
	{
		mParameterizedTraits->free(transitionDownB.buf);
	}
	if (transitionDown.isAllocated && transitionDown.buf)
	{
		mParameterizedTraits->free(transitionDown.buf);
	}
}

void ClothingPhysicalMeshParameters::freeStrings(void)
{
}

void ClothingPhysicalMeshParameters::freeReferences(void)
{
}

} // namespace clothing
} // namespace nvidia
