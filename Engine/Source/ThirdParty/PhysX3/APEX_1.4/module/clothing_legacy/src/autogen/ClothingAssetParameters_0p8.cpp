// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2017 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "ClothingAssetParameters_0p8.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace ClothingAssetParameters_0p8NS;

const char* const ClothingAssetParameters_0p8Factory::vptr =
    NvParameterized::getVptr<ClothingAssetParameters_0p8, ClothingAssetParameters_0p8::ClassAlignment>();

const uint32_t NumParamDefs = 53;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 3, 5, 17, 26, 27, 28, 29, 37, 39, 44, 46, 50, 51, 52, 2, 4, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 30, 31, 32, 33, 34, 35, 36, 38,
	40, 41, 42, 43, 45, 47, 48, 49,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 15 },
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->physicalMeshes), CHILDREN(15), 1 }, // physicalMeshes
	{ TYPE_REF, false, 1 * sizeof(NvParameterized::Interface*), NULL, 0 }, // physicalMeshes[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->graphicalLods), CHILDREN(16), 1 }, // graphicalLods
	{ TYPE_REF, false, 1 * sizeof(NvParameterized::Interface*), NULL, 0 }, // graphicalLods[]
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->simulation), CHILDREN(17), 11 }, // simulation
	{ TYPE_U32, false, (size_t)(&((SimulationParams_Type*)0)->hierarchicalLevels), NULL, 0 }, // simulation.hierarchicalLevels
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->thickness), NULL, 0 }, // simulation.thickness
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->selfcollisionThickness), NULL, 0 }, // simulation.selfcollisionThickness
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->virtualParticleDensity), NULL, 0 }, // simulation.virtualParticleDensity
	{ TYPE_VEC3, false, (size_t)(&((SimulationParams_Type*)0)->gravityDirection), NULL, 0 }, // simulation.gravityDirection
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->sleepLinearVelocity), NULL, 0 }, // simulation.sleepLinearVelocity
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->disableCCD), NULL, 0 }, // simulation.disableCCD
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->untangling), NULL, 0 }, // simulation.untangling
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->selfcollision), NULL, 0 }, // simulation.selfcollision
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->twowayInteraction), NULL, 0 }, // simulation.twowayInteraction
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->restLengthScale), NULL, 0 }, // simulation.restLengthScale
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->bones), CHILDREN(28), 1 }, // bones
	{ TYPE_STRUCT, false, 1 * sizeof(BoneEntry_Type), CHILDREN(29), 7 }, // bones[]
	{ TYPE_I32, false, (size_t)(&((BoneEntry_Type*)0)->internalIndex), NULL, 0 }, // bones[].internalIndex
	{ TYPE_I32, false, (size_t)(&((BoneEntry_Type*)0)->externalIndex), NULL, 0 }, // bones[].externalIndex
	{ TYPE_U32, false, (size_t)(&((BoneEntry_Type*)0)->numMeshReferenced), NULL, 0 }, // bones[].numMeshReferenced
	{ TYPE_U32, false, (size_t)(&((BoneEntry_Type*)0)->numRigidBodiesReferenced), NULL, 0 }, // bones[].numRigidBodiesReferenced
	{ TYPE_I32, false, (size_t)(&((BoneEntry_Type*)0)->parentIndex), NULL, 0 }, // bones[].parentIndex
	{ TYPE_MAT34, false, (size_t)(&((BoneEntry_Type*)0)->bindPose), NULL, 0 }, // bones[].bindPose
	{ TYPE_STRING, false, (size_t)(&((BoneEntry_Type*)0)->name), NULL, 0 }, // bones[].name
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->bonesReferenced), NULL, 0 }, // bonesReferenced
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->bonesReferencedByMesh), NULL, 0 }, // bonesReferencedByMesh
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->rootBoneIndex), NULL, 0 }, // rootBoneIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->boneActors), CHILDREN(36), 1 }, // boneActors
	{ TYPE_STRUCT, false, 1 * sizeof(ActorEntry_Type), CHILDREN(37), 6 }, // boneActors[]
	{ TYPE_I32, false, (size_t)(&((ActorEntry_Type*)0)->boneIndex), NULL, 0 }, // boneActors[].boneIndex
	{ TYPE_U32, false, (size_t)(&((ActorEntry_Type*)0)->convexVerticesStart), NULL, 0 }, // boneActors[].convexVerticesStart
	{ TYPE_U32, false, (size_t)(&((ActorEntry_Type*)0)->convexVerticesCount), NULL, 0 }, // boneActors[].convexVerticesCount
	{ TYPE_F32, false, (size_t)(&((ActorEntry_Type*)0)->capsuleRadius), NULL, 0 }, // boneActors[].capsuleRadius
	{ TYPE_F32, false, (size_t)(&((ActorEntry_Type*)0)->capsuleHeight), NULL, 0 }, // boneActors[].capsuleHeight
	{ TYPE_MAT34, false, (size_t)(&((ActorEntry_Type*)0)->localPose), NULL, 0 }, // boneActors[].localPose
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->boneVertices), CHILDREN(43), 1 }, // boneVertices
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // boneVertices[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->boneSpheres), CHILDREN(44), 1 }, // boneSpheres
	{ TYPE_STRUCT, false, 1 * sizeof(BoneSphere_Type), CHILDREN(45), 3 }, // boneSpheres[]
	{ TYPE_I32, false, (size_t)(&((BoneSphere_Type*)0)->boneIndex), NULL, 0 }, // boneSpheres[].boneIndex
	{ TYPE_F32, false, (size_t)(&((BoneSphere_Type*)0)->radius), NULL, 0 }, // boneSpheres[].radius
	{ TYPE_VEC3, false, (size_t)(&((BoneSphere_Type*)0)->localPos), NULL, 0 }, // boneSpheres[].localPos
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->boneSphereConnections), CHILDREN(48), 1 }, // boneSphereConnections
	{ TYPE_U16, false, 1 * sizeof(uint16_t), NULL, 0 }, // boneSphereConnections[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->cookedData), CHILDREN(49), 1 }, // cookedData
	{ TYPE_STRUCT, false, 1 * sizeof(CookedEntry_Type), CHILDREN(50), 2 }, // cookedData[]
	{ TYPE_F32, false, (size_t)(&((CookedEntry_Type*)0)->scale), NULL, 0 }, // cookedData[].scale
	{ TYPE_REF, false, (size_t)(&((CookedEntry_Type*)0)->cookedData), NULL, 0 }, // cookedData[].cookedData
	{ TYPE_BOUNDS3, false, (size_t)(&((ParametersStruct*)0)->boundingBox), NULL, 0 }, // boundingBox
	{ TYPE_REF, false, (size_t)(&((ParametersStruct*)0)->materialLibrary), NULL, 0 }, // materialLibrary
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->materialIndex), NULL, 0 }, // materialIndex
};


bool ClothingAssetParameters_0p8::mBuiltFlag = false;
NvParameterized::MutexType ClothingAssetParameters_0p8::mBuiltFlagMutex;

ClothingAssetParameters_0p8::ClothingAssetParameters_0p8(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ClothingAssetParameters_0p8FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ClothingAssetParameters_0p8::~ClothingAssetParameters_0p8()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ClothingAssetParameters_0p8::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ClothingAssetParameters_0p8();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* ClothingAssetParameters_0p8::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* ClothingAssetParameters_0p8::getParameterDefinitionTree(void) const
{
	ClothingAssetParameters_0p8* tmpParam = const_cast<ClothingAssetParameters_0p8*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType ClothingAssetParameters_0p8::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType ClothingAssetParameters_0p8::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ClothingAssetParameters_0p8::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ClothingAssetParameters_0p8::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */
/* [0] - physicalMeshes (not an array of structs) */
/* [0] - graphicalLods (not an array of structs) */
/* [1,6] - bones.name */
/* [1,1] - cookedData.cookedData */

void ClothingAssetParameters_0p8::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ClothingAssetParameters_0p8::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="physicalMeshes"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("physicalMeshes", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are used for multiple graphical LoDs.", true);
		HintTable[2].init("shortDescription", "An Array of physical meshes", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingPhysicalMeshParameters" };
		ParamDefTable[1].setRefVariantVals((const char**)RefVariantVals, 1);


		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="physicalMeshes[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("physicalMeshes", TYPE_REF, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are used for multiple graphical LoDs.", true);
		HintTable[2].init("shortDescription", "An Array of physical meshes", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingPhysicalMeshParameters" };
		ParamDefTable[2].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="graphicalLods"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("graphicalLods", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		HintTable[1].init("longDescription", "Each LoD contains a graphical mesh and a reference to a physical mesh.", true);
		HintTable[2].init("shortDescription", "An array of graphical Lods.", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingGraphicalLodParameters" };
		ParamDefTable[3].setRefVariantVals((const char**)RefVariantVals, 1);


		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="graphicalLods[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("graphicalLods", TYPE_REF, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		HintTable[1].init("longDescription", "Each LoD contains a graphical mesh and a reference to a physical mesh.", true);
		HintTable[2].init("shortDescription", "An array of graphical Lods.", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingGraphicalLodParameters" };
		ParamDefTable[4].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="simulation"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("simulation", TYPE_STRUCT, "SimulationParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="simulation.hierarchicalLevels"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("hierarchicalLevels", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Corresponds to NxClothMeshDesc::numHierarchyLevels.\nThis is orthogonal to the Hard Stretch Limitation in the Clothing Material.\n", true);
		HintTable[1].init("shortDescription", "The number of cloth hierarhies. Only used to prevent stretching", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="simulation.thickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("thickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each cloth particle will minimaly have as much distance to any collision volume.\nMost stable when this value corresponds roughly half the average edge length.\nCan be increased to prevent penetration artifacts.\n", true);
		HintTable[1].init("shortDescription", "Minimal amount of separation between cloth particles and collision volumes.", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="simulation.selfcollisionThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("selfcollisionThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This feature prevents meshes from self-intersecting. Only works properly when configured properly.", true);
		HintTable[1].init("shortDescription", "Minimal amount of distance particles will keep of each other.", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="simulation.virtualParticleDensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("virtualParticleDensity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "0 will create no virtual particles. 1 will create 3 virtual particles for every triangle. Everything else is in between.", true);
		HintTable[1].init("shortDescription", "Select the amount of virtual particles generated.", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="simulation.gravityDirection"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("gravityDirection", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Direction of gravity for this asset.", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="simulation.sleepLinearVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("sleepLinearVelocity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Most clothing doesn't need it, but it might be useful for smaller assets like flags and the like.", true);
		HintTable[1].init("shortDescription", "Clothing will fall asleep if every vertex is slower than this velocity", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="simulation.disableCCD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("disableCCD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When turning off CCD, cloth particles can tunnel through fast moving collision volumes. But sometimes\nill turning collision volumes can excert large velocities on particles. This can help prevent it.\n", true);
		HintTable[1].init("shortDescription", "Turn off CCD when colliding cloth particles with collision volumes", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="simulation.untangling"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("untangling", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This feature is highly experimental and still rather slow. Only use when self-collision could not\nhelp adequately.\n", true);
		HintTable[1].init("shortDescription", "EXPERIMENTAL: Untangle Cloth when it's entangled.", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="simulation.selfcollision"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("selfcollision", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turn self-collision on/off", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="simulation.twowayInteraction"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("twowayInteraction", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "For clothing this is normally not needed, as clothing should only follow the kinematic shapes. Needed when interacting\nwith dynamic rigid bodies that need to be influenced by clothing.\n", true);
		HintTable[1].init("shortDescription", "Make use of twoway interaction", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="simulation.restLengthScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("restLengthScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Scale for cloth rest lengths.", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="bones"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("bones", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each bone contains a bind pose and reference counters.", true);
		HintTable[1].init("shortDescription", "Array of Bones", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[2] = { 1, 6, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 2);

	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="bones[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("bones", TYPE_STRUCT, "BoneEntry", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each bone contains a bind pose and reference counters.", true);
		HintTable[1].init("shortDescription", "Array of Bones", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="bones[].internalIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("internalIndex", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This usually corresponds to the array position this element is at.", true);
		HintTable[1].init("shortDescription", "The index used internally for this bone.", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="bones[].externalIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("externalIndex", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The index that was given by the application", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="bones[].numMeshReferenced"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("numMeshReferenced", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number of mesh vertices that have a non-zero weight to this bone.", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="bones[].numRigidBodiesReferenced"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("numRigidBodiesReferenced", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number of collision volumes attached to this bone", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="bones[].parentIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("parentIndex", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The (internal) index of the parent bone", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="bones[].bindPose"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("bindPose", TYPE_MAT34, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The matrix this bone has in the default pose", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="bones[].name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("name", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The name of this bone", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="bonesReferenced"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("bonesReferenced", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Any bone in the bones array beyond this number is completely useless.", true);
		HintTable[1].init("shortDescription", "Number of bones actually used by any of the meshes or collision volumes.", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="bonesReferencedByMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("bonesReferencedByMesh", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Bones beyond this index can be used for collision volumes or not at all. This number is smaller or\nequal the 'bonesReferenced' number.\n", true);
		HintTable[1].init("shortDescription", "Number of bones actually used by any of the meshes", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="rootBoneIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("rootBoneIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Internal bone index with either parent=-1 or one bone with minimal distance to root when root is not inside the used bones", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="boneActors"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("boneActors", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each collision volume belongs to a bone and contains a description of its shape.", true);
		HintTable[1].init("shortDescription", "Array of collision volumes", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="boneActors[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("boneActors", TYPE_STRUCT, "ActorEntry", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each collision volume belongs to a bone and contains a description of its shape.", true);
		HintTable[1].init("shortDescription", "Array of collision volumes", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="boneActors[].boneIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("boneIndex", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The (internal) index this collision volume is attached to", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="boneActors[].convexVerticesStart"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("convexVerticesStart", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Index into the boneVertices array where the list of vertices for this shape starts.", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="boneActors[].convexVerticesCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("convexVerticesCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number vertices that make up this convex.", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="boneActors[].capsuleRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("capsuleRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The radius of the capsule that describes this collision volume.", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="boneActors[].capsuleHeight"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("capsuleHeight", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The height of the capsule that describes this collision volume.", true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="boneActors[].localPose"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("localPose", TYPE_MAT34, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The pose this collision volume has relative to the bone.", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="boneVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("boneVertices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "All convexes use the same array but different parts of it.", true);
		HintTable[1].init("shortDescription", "Array of vertices that belong to one or more convex collision volumes", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="boneVertices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("boneVertices", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "All convexes use the same array but different parts of it.", true);
		HintTable[1].init("shortDescription", "Array of vertices that belong to one or more convex collision volumes", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="boneSpheres"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("boneSpheres", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The spheres are connected to tapered capsules by the boneSphereConnections array.", true);
		HintTable[1].init("shortDescription", "Array of spheres that describe the tapered capsules for clothing collision in PhysX3.", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="boneSpheres[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("boneSpheres", TYPE_STRUCT, "BoneSphere", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The spheres are connected to tapered capsules by the boneSphereConnections array.", true);
		HintTable[1].init("shortDescription", "Array of spheres that describe the tapered capsules for clothing collision in PhysX3.", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="boneSpheres[].boneIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("boneIndex", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The (internal) index this collision volume is attached to", true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="boneSpheres[].radius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("radius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The radius of the sphere that describes this collision volume.", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="boneSpheres[].localPos"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("localPos", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The position this collision volume has relative to the bone.", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="boneSphereConnections"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("boneSphereConnections", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This is an array of pairs, so the size must be dividible by 2.", true);
		HintTable[1].init("shortDescription", "Array of indices into the boneSpheres array to describe pairs of spheres that form a capsule.", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="boneSphereConnections[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("boneSphereConnections", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This is an array of pairs, so the size must be dividible by 2.", true);
		HintTable[1].init("shortDescription", "Array of indices into the boneSpheres array to describe pairs of spheres that form a capsule.", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="cookedData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("cookedData", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Various versions of cooked data", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[2] = { 1, 1, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 2);

	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="cookedData[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("cookedData", TYPE_STRUCT, "CookedEntry", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Various versions of cooked data", true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="cookedData[].scale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("scale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="cookedData[].cookedData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("cookedData", TYPE_REF, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Data cooked at runtime", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingCookedParam" };
		ParamDefTable[49].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="boundingBox"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("boundingBox", TYPE_BOUNDS3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This contains the simulated as well as the animated vertices.", true);
		HintTable[1].init("shortDescription", "The Bounding-Box of the Asset", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="materialLibrary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("materialLibrary", TYPE_REF, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("INCLUDED", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The Material Library for this asset", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingMaterialLibraryParameters" };
		ParamDefTable[51].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="materialIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("materialIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Default index for the material in the library", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[15];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(3);
		Children[2] = PDEF_PTR(5);
		Children[3] = PDEF_PTR(17);
		Children[4] = PDEF_PTR(26);
		Children[5] = PDEF_PTR(27);
		Children[6] = PDEF_PTR(28);
		Children[7] = PDEF_PTR(29);
		Children[8] = PDEF_PTR(37);
		Children[9] = PDEF_PTR(39);
		Children[10] = PDEF_PTR(44);
		Children[11] = PDEF_PTR(46);
		Children[12] = PDEF_PTR(50);
		Children[13] = PDEF_PTR(51);
		Children[14] = PDEF_PTR(52);

		ParamDefTable[0].setChildren(Children, 15);
	}

	// SetChildren for: nodeIndex=1, longName="physicalMeshes"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(2);

		ParamDefTable[1].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=3, longName="graphicalLods"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(4);

		ParamDefTable[3].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=5, longName="simulation"
	{
		static Definition* Children[11];
		Children[0] = PDEF_PTR(6);
		Children[1] = PDEF_PTR(7);
		Children[2] = PDEF_PTR(8);
		Children[3] = PDEF_PTR(9);
		Children[4] = PDEF_PTR(10);
		Children[5] = PDEF_PTR(11);
		Children[6] = PDEF_PTR(12);
		Children[7] = PDEF_PTR(13);
		Children[8] = PDEF_PTR(14);
		Children[9] = PDEF_PTR(15);
		Children[10] = PDEF_PTR(16);

		ParamDefTable[5].setChildren(Children, 11);
	}

	// SetChildren for: nodeIndex=17, longName="bones"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(18);

		ParamDefTable[17].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=18, longName="bones[]"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(19);
		Children[1] = PDEF_PTR(20);
		Children[2] = PDEF_PTR(21);
		Children[3] = PDEF_PTR(22);
		Children[4] = PDEF_PTR(23);
		Children[5] = PDEF_PTR(24);
		Children[6] = PDEF_PTR(25);

		ParamDefTable[18].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=29, longName="boneActors"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(30);

		ParamDefTable[29].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=30, longName="boneActors[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(31);
		Children[1] = PDEF_PTR(32);
		Children[2] = PDEF_PTR(33);
		Children[3] = PDEF_PTR(34);
		Children[4] = PDEF_PTR(35);
		Children[5] = PDEF_PTR(36);

		ParamDefTable[30].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=37, longName="boneVertices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(38);

		ParamDefTable[37].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=39, longName="boneSpheres"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(40);

		ParamDefTable[39].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=40, longName="boneSpheres[]"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(41);
		Children[1] = PDEF_PTR(42);
		Children[2] = PDEF_PTR(43);

		ParamDefTable[40].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=44, longName="boneSphereConnections"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(45);

		ParamDefTable[44].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=46, longName="cookedData"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(47);

		ParamDefTable[46].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=47, longName="cookedData[]"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(48);
		Children[1] = PDEF_PTR(49);

		ParamDefTable[47].setChildren(Children, 2);
	}

	mBuiltFlag = true;

}
void ClothingAssetParameters_0p8::initStrings(void)
{
}

void ClothingAssetParameters_0p8::initDynamicArrays(void)
{
	physicalMeshes.buf = NULL;
	physicalMeshes.isAllocated = true;
	physicalMeshes.elementSize = sizeof(NvParameterized::Interface*);
	physicalMeshes.arraySizes[0] = 0;
	graphicalLods.buf = NULL;
	graphicalLods.isAllocated = true;
	graphicalLods.elementSize = sizeof(NvParameterized::Interface*);
	graphicalLods.arraySizes[0] = 0;
	bones.buf = NULL;
	bones.isAllocated = true;
	bones.elementSize = sizeof(BoneEntry_Type);
	bones.arraySizes[0] = 0;
	boneActors.buf = NULL;
	boneActors.isAllocated = true;
	boneActors.elementSize = sizeof(ActorEntry_Type);
	boneActors.arraySizes[0] = 0;
	boneVertices.buf = NULL;
	boneVertices.isAllocated = true;
	boneVertices.elementSize = sizeof(physx::PxVec3);
	boneVertices.arraySizes[0] = 0;
	boneSpheres.buf = NULL;
	boneSpheres.isAllocated = true;
	boneSpheres.elementSize = sizeof(BoneSphere_Type);
	boneSpheres.arraySizes[0] = 0;
	boneSphereConnections.buf = NULL;
	boneSphereConnections.isAllocated = true;
	boneSphereConnections.elementSize = sizeof(uint16_t);
	boneSphereConnections.arraySizes[0] = 0;
	cookedData.buf = NULL;
	cookedData.isAllocated = true;
	cookedData.elementSize = sizeof(CookedEntry_Type);
	cookedData.arraySizes[0] = 0;
}

void ClothingAssetParameters_0p8::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	simulation.hierarchicalLevels = uint32_t(0);
	simulation.thickness = float(0.01);
	simulation.selfcollisionThickness = float(0.01);
	simulation.virtualParticleDensity = float(0.0);
	simulation.gravityDirection = physx::PxVec3(physx::PxVec3(0.0f));
	simulation.sleepLinearVelocity = float(0.0);
	simulation.disableCCD = bool(false);
	simulation.untangling = bool(false);
	simulation.selfcollision = bool(false);
	simulation.twowayInteraction = bool(false);
	simulation.restLengthScale = float(1.0);
	bonesReferenced = uint32_t(0);
	bonesReferencedByMesh = uint32_t(0);
	rootBoneIndex = uint32_t(0);
	boundingBox = physx::PxBounds3(physx::PxVec3(0.0f), physx::PxVec3(0.0f));
	materialIndex = uint32_t(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ClothingAssetParameters_0p8::initReferences(void)
{
	materialLibrary = NULL;

}

void ClothingAssetParameters_0p8::freeDynamicArrays(void)
{
	if (physicalMeshes.isAllocated && physicalMeshes.buf)
	{
		mParameterizedTraits->free(physicalMeshes.buf);
	}
	if (graphicalLods.isAllocated && graphicalLods.buf)
	{
		mParameterizedTraits->free(graphicalLods.buf);
	}
	if (bones.isAllocated && bones.buf)
	{
		mParameterizedTraits->free(bones.buf);
	}
	if (boneActors.isAllocated && boneActors.buf)
	{
		mParameterizedTraits->free(boneActors.buf);
	}
	if (boneVertices.isAllocated && boneVertices.buf)
	{
		mParameterizedTraits->free(boneVertices.buf);
	}
	if (boneSpheres.isAllocated && boneSpheres.buf)
	{
		mParameterizedTraits->free(boneSpheres.buf);
	}
	if (boneSphereConnections.isAllocated && boneSphereConnections.buf)
	{
		mParameterizedTraits->free(boneSphereConnections.buf);
	}
	if (cookedData.isAllocated && cookedData.buf)
	{
		mParameterizedTraits->free(cookedData.buf);
	}
}

void ClothingAssetParameters_0p8::freeStrings(void)
{

	for (int i = 0; i < bones.arraySizes[0]; ++i)
	{
		if (bones.buf[i].name.isAllocated && bones.buf[i].name.buf)
		{
			mParameterizedTraits->strfree((char*)bones.buf[i].name.buf);
		}
	}
}

void ClothingAssetParameters_0p8::freeReferences(void)
{

	for (int i = 0; i < physicalMeshes.arraySizes[0]; ++i)
	{
		if (physicalMeshes.buf[i])
		{
			physicalMeshes.buf[i]->destroy();
		}
	}

	for (int i = 0; i < graphicalLods.arraySizes[0]; ++i)
	{
		if (graphicalLods.buf[i])
		{
			graphicalLods.buf[i]->destroy();
		}
	}

	for (int i = 0; i < cookedData.arraySizes[0]; i++)
	{
		if (cookedData.buf[i].cookedData)
		{
			cookedData.buf[i].cookedData->destroy();
		}
	}
	if (materialLibrary)
	{
		materialLibrary->destroy();
	}

}

} // namespace parameterized
} // namespace nvidia
