// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2017 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "DestructibleActorParam_0p18.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace DestructibleActorParam_0p18NS;

const char* const DestructibleActorParam_0p18Factory::vptr =
    NvParameterized::getVptr<DestructibleActorParam_0p18, DestructibleActorParam_0p18::ClassAlignment>();

const uint32_t NumParamDefs = 257;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20, 21, 53, 64, 98, 127,
	144, 168, 196, 208, 212, 234, 16, 18, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
	33, 34, 35, 36, 44, 45, 46, 47, 37, 38, 39, 40, 41, 42, 43, 48, 49, 50, 51, 52, 54,
	55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 86, 87, 93, 94, 95, 96, 97, 66, 67, 68, 69,
	70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91, 92,
	99, 107, 108, 109, 110, 123, 124, 125, 126, 100, 101, 102, 103, 104, 105, 106, 111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 128, 133, 134, 135, 136, 137,
	138, 139, 140, 141, 142, 143, 129, 130, 131, 132, 145, 153, 158, 163, 164, 165, 166,
	167, 146, 147, 148, 149, 150, 151, 152, 154, 155, 156, 157, 159, 160, 161, 162, 169,
	173, 174, 175, 176, 194, 195, 170, 171, 172, 177, 178, 179, 180, 181, 182, 183, 184,
	185, 186, 187, 188, 189, 190, 191, 192, 193, 197, 198, 200, 201, 202, 203, 204, 205,
	206, 207, 199, 209, 210, 211, 213, 214, 215, 216, 220, 224, 225, 226, 227, 228, 217,
	218, 219, 221, 222, 223, 229, 230, 231, 232, 233, 235, 236, 237, 238, 239, 243, 247,
	248, 249, 250, 251, 240, 241, 242, 244, 245, 246, 252, 253, 254, 255, 256,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 29 },
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->crumbleEmitterName), NULL, 0 }, // crumbleEmitterName
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->crumbleParticleSpacing), NULL, 0 }, // crumbleParticleSpacing
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->dustEmitterName), NULL, 0 }, // dustEmitterName
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dustParticleSpacing), NULL, 0 }, // dustParticleSpacing
	{ TYPE_MAT34, false, (size_t)(&((ParametersStruct*)0)->globalPose), NULL, 0 }, // globalPose
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->scale), NULL, 0 }, // scale
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->dynamic), NULL, 0 }, // dynamic
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->supportDepth), NULL, 0 }, // supportDepth
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->formExtendedStructures), NULL, 0 }, // formExtendedStructures
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->keepPreviousFrameBoneBuffer), NULL, 0 }, // keepPreviousFrameBoneBuffer
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useAssetDefinedSupport), NULL, 0 }, // useAssetDefinedSupport
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useWorldSupport), NULL, 0 }, // useWorldSupport
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->renderStaticChunksSeparately), NULL, 0 }, // renderStaticChunksSeparately
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->createChunkEvents), NULL, 0 }, // createChunkEvents
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->overrideSkinnedMaterialNames), CHILDREN(29), 1 }, // overrideSkinnedMaterialNames
	{ TYPE_STRING, false, 1 * sizeof(NvParameterized::DummyStringStruct), NULL, 0 }, // overrideSkinnedMaterialNames[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->overrideStaticMaterialNames), CHILDREN(30), 1 }, // overrideStaticMaterialNames
	{ TYPE_STRING, false, 1 * sizeof(NvParameterized::DummyStringStruct), NULL, 0 }, // overrideStaticMaterialNames[]
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->sleepVelocityFrameDecayConstant), NULL, 0 }, // sleepVelocityFrameDecayConstant
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useHardSleeping), NULL, 0 }, // useHardSleeping
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->destructibleParameters), CHILDREN(31), 19 }, // destructibleParameters
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->damageCap), NULL, 0 }, // destructibleParameters.damageCap
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->forceToDamage), NULL, 0 }, // destructibleParameters.forceToDamage
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->impactVelocityThreshold), NULL, 0 }, // destructibleParameters.impactVelocityThreshold
	{ TYPE_U32, false, (size_t)(&((DestructibleParameters_Type*)0)->minimumFractureDepth), NULL, 0 }, // destructibleParameters.minimumFractureDepth
	{ TYPE_I32, false, (size_t)(&((DestructibleParameters_Type*)0)->impactDamageDefaultDepth), NULL, 0 }, // destructibleParameters.impactDamageDefaultDepth
	{ TYPE_I32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisDepth), NULL, 0 }, // destructibleParameters.debrisDepth
	{ TYPE_U32, false, (size_t)(&((DestructibleParameters_Type*)0)->essentialDepth), NULL, 0 }, // destructibleParameters.essentialDepth
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisLifetimeMin), NULL, 0 }, // destructibleParameters.debrisLifetimeMin
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisLifetimeMax), NULL, 0 }, // destructibleParameters.debrisLifetimeMax
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisMaxSeparationMin), NULL, 0 }, // destructibleParameters.debrisMaxSeparationMin
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisMaxSeparationMax), NULL, 0 }, // destructibleParameters.debrisMaxSeparationMax
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisDestructionProbability), NULL, 0 }, // destructibleParameters.debrisDestructionProbability
	{ TYPE_BOUNDS3, false, (size_t)(&((DestructibleParameters_Type*)0)->validBounds), NULL, 0 }, // destructibleParameters.validBounds
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->maxChunkSpeed), NULL, 0 }, // destructibleParameters.maxChunkSpeed
	{ TYPE_STRUCT, false, (size_t)(&((DestructibleParameters_Type*)0)->flags), CHILDREN(50), 7 }, // destructibleParameters.flags
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->ACCUMULATE_DAMAGE), NULL, 0 }, // destructibleParameters.flags.ACCUMULATE_DAMAGE
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->DEBRIS_TIMEOUT), NULL, 0 }, // destructibleParameters.flags.DEBRIS_TIMEOUT
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->DEBRIS_MAX_SEPARATION), NULL, 0 }, // destructibleParameters.flags.DEBRIS_MAX_SEPARATION
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->CRUMBLE_SMALLEST_CHUNKS), NULL, 0 }, // destructibleParameters.flags.CRUMBLE_SMALLEST_CHUNKS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->ACCURATE_RAYCASTS), NULL, 0 }, // destructibleParameters.flags.ACCURATE_RAYCASTS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->USE_VALID_BOUNDS), NULL, 0 }, // destructibleParameters.flags.USE_VALID_BOUNDS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->CRUMBLE_VIA_RUNTIME_FRACTURE), NULL, 0 }, // destructibleParameters.flags.CRUMBLE_VIA_RUNTIME_FRACTURE
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->fractureImpulseScale), NULL, 0 }, // destructibleParameters.fractureImpulseScale
	{ TYPE_U16, false, (size_t)(&((DestructibleParameters_Type*)0)->damageDepthLimit), NULL, 0 }, // destructibleParameters.damageDepthLimit
	{ TYPE_U16, false, (size_t)(&((DestructibleParameters_Type*)0)->dynamicChunkDominanceGroup), NULL, 0 }, // destructibleParameters.dynamicChunkDominanceGroup
	{ TYPE_STRUCT, false, (size_t)(&((DestructibleParameters_Type*)0)->dynamicChunksGroupsMask), CHILDREN(57), 5 }, // destructibleParameters.dynamicChunksGroupsMask
	{ TYPE_BOOL, false, (size_t)(&((GroupsMask_Type*)0)->useGroupsMask), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.useGroupsMask
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits0), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits0
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits1), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits1
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits2), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits2
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits3), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits3
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->depthParameters), CHILDREN(62), 1 }, // depthParameters
	{ TYPE_STRUCT, false, 1 * sizeof(DestructibleDepthParameters_Type), CHILDREN(63), 9 }, // depthParameters[]
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->OVERRIDE_IMPACT_DAMAGE), NULL, 0 }, // depthParameters[].OVERRIDE_IMPACT_DAMAGE
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->OVERRIDE_IMPACT_DAMAGE_VALUE), NULL, 0 }, // depthParameters[].OVERRIDE_IMPACT_DAMAGE_VALUE
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->IGNORE_POSE_UPDATES), NULL, 0 }, // depthParameters[].IGNORE_POSE_UPDATES
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->IGNORE_RAYCAST_CALLBACKS), NULL, 0 }, // depthParameters[].IGNORE_RAYCAST_CALLBACKS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->IGNORE_CONTACT_CALLBACKS), NULL, 0 }, // depthParameters[].IGNORE_CONTACT_CALLBACKS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_0), NULL, 0 }, // depthParameters[].USER_FLAG_0
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_1), NULL, 0 }, // depthParameters[].USER_FLAG_1
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_2), NULL, 0 }, // depthParameters[].USER_FLAG_2
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_3), NULL, 0 }, // depthParameters[].USER_FLAG_3
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->shapeDescTemplate), CHILDREN(72), 8 }, // shapeDescTemplate
	{ TYPE_STRUCT, false, (size_t)(&((ShapeDescTemplate_Type*)0)->flags), CHILDREN(80), 20 }, // shapeDescTemplate.flags
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_TRIGGER_ON_ENTER), NULL, 0 }, // shapeDescTemplate.flags.NX_TRIGGER_ON_ENTER
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_TRIGGER_ON_LEAVE), NULL, 0 }, // shapeDescTemplate.flags.NX_TRIGGER_ON_LEAVE
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_TRIGGER_ON_STAY), NULL, 0 }, // shapeDescTemplate.flags.NX_TRIGGER_ON_STAY
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_VISUALIZATION), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_VISUALIZATION
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_DISABLE_COLLISION), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_DISABLE_COLLISION
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_FEATURE_INDICES), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_FEATURE_INDICES
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_DISABLE_RAYCASTING), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_DISABLE_RAYCASTING
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_POINT_CONTACT_FORCE), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_POINT_CONTACT_FORCE
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_FLUID_DRAIN), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_FLUID_DRAIN
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_FLUID_DISABLE_COLLISION), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_FLUID_DISABLE_COLLISION
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_FLUID_TWOWAY), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_FLUID_TWOWAY
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_DISABLE_RESPONSE), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_DISABLE_RESPONSE
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_DYNAMIC_DYNAMIC_CCD), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_DYNAMIC_DYNAMIC_CCD
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_DISABLE_SCENE_QUERIES), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_DISABLE_SCENE_QUERIES
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_CLOTH_DRAIN), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_CLOTH_DRAIN
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_CLOTH_DISABLE_COLLISION), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_CLOTH_DISABLE_COLLISION
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_CLOTH_TWOWAY), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_CLOTH_TWOWAY
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_SOFTBODY_DRAIN), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_SOFTBODY_DRAIN
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_SOFTBODY_DISABLE_COLLISION), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_SOFTBODY_DISABLE_COLLISION
	{ TYPE_BOOL, false, (size_t)(&((ShapeDescFlags_Type*)0)->NX_SF_SOFTBODY_TWOWAY), NULL, 0 }, // shapeDescTemplate.flags.NX_SF_SOFTBODY_TWOWAY
	{ TYPE_U16, false, (size_t)(&((ShapeDescTemplate_Type*)0)->collisionGroup), NULL, 0 }, // shapeDescTemplate.collisionGroup
	{ TYPE_STRUCT, false, (size_t)(&((ShapeDescTemplate_Type*)0)->groupsMask), CHILDREN(100), 5 }, // shapeDescTemplate.groupsMask
	{ TYPE_BOOL, false, (size_t)(&((GroupsMask_Type*)0)->useGroupsMask), NULL, 0 }, // shapeDescTemplate.groupsMask.useGroupsMask
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits0), NULL, 0 }, // shapeDescTemplate.groupsMask.bits0
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits1), NULL, 0 }, // shapeDescTemplate.groupsMask.bits1
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits2), NULL, 0 }, // shapeDescTemplate.groupsMask.bits2
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits3), NULL, 0 }, // shapeDescTemplate.groupsMask.bits3
	{ TYPE_U16, false, (size_t)(&((ShapeDescTemplate_Type*)0)->materialIndex), NULL, 0 }, // shapeDescTemplate.materialIndex
	{ TYPE_F32, false, (size_t)(&((ShapeDescTemplate_Type*)0)->density), NULL, 0 }, // shapeDescTemplate.density
	{ TYPE_F32, false, (size_t)(&((ShapeDescTemplate_Type*)0)->skinWidth), NULL, 0 }, // shapeDescTemplate.skinWidth
	{ TYPE_U64, false, (size_t)(&((ShapeDescTemplate_Type*)0)->userData), NULL, 0 }, // shapeDescTemplate.userData
	{ TYPE_U64, false, (size_t)(&((ShapeDescTemplate_Type*)0)->name), NULL, 0 }, // shapeDescTemplate.name
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->actorDescTemplate), CHILDREN(105), 9 }, // actorDescTemplate
	{ TYPE_STRUCT, false, (size_t)(&((ActorDescTemplate_Type*)0)->flags), CHILDREN(114), 7 }, // actorDescTemplate.flags
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_DISABLE_COLLISION), NULL, 0 }, // actorDescTemplate.flags.NX_AF_DISABLE_COLLISION
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_DISABLE_RESPONSE), NULL, 0 }, // actorDescTemplate.flags.NX_AF_DISABLE_RESPONSE
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_LOCK_COM), NULL, 0 }, // actorDescTemplate.flags.NX_AF_LOCK_COM
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_FLUID_DISABLE_COLLISION), NULL, 0 }, // actorDescTemplate.flags.NX_AF_FLUID_DISABLE_COLLISION
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_CONTACT_MODIFICATION), NULL, 0 }, // actorDescTemplate.flags.NX_AF_CONTACT_MODIFICATION
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_FORCE_CONE_FRICTION), NULL, 0 }, // actorDescTemplate.flags.NX_AF_FORCE_CONE_FRICTION
	{ TYPE_BOOL, false, (size_t)(&((ActorDescFlags_Type*)0)->NX_AF_USER_ACTOR_PAIR_FILTERING), NULL, 0 }, // actorDescTemplate.flags.NX_AF_USER_ACTOR_PAIR_FILTERING
	{ TYPE_F32, false, (size_t)(&((ActorDescTemplate_Type*)0)->density), NULL, 0 }, // actorDescTemplate.density
	{ TYPE_U16, false, (size_t)(&((ActorDescTemplate_Type*)0)->actorCollisionGroup), NULL, 0 }, // actorDescTemplate.actorCollisionGroup
	{ TYPE_U16, false, (size_t)(&((ActorDescTemplate_Type*)0)->dominanceGroup), NULL, 0 }, // actorDescTemplate.dominanceGroup
	{ TYPE_STRUCT, false, (size_t)(&((ActorDescTemplate_Type*)0)->contactReportFlags), CHILDREN(121), 12 }, // actorDescTemplate.contactReportFlags
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_IGNORE_PAIR), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_IGNORE_PAIR
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_START_TOUCH), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_START_TOUCH
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_END_TOUCH), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_END_TOUCH
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_TOUCH), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_TOUCH
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_IMPACT), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_IMPACT
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_ROLL), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_ROLL
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_SLIDE), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_SLIDE
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_FORCES), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_FORCES
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD
	{ TYPE_BOOL, false, (size_t)(&((ContactPairFlag_Type*)0)->NX_NOTIFY_CONTACT_MODIFICATION), NULL, 0 }, // actorDescTemplate.contactReportFlags.NX_NOTIFY_CONTACT_MODIFICATION
	{ TYPE_U16, false, (size_t)(&((ActorDescTemplate_Type*)0)->forceFieldMaterial), NULL, 0 }, // actorDescTemplate.forceFieldMaterial
	{ TYPE_U64, false, (size_t)(&((ActorDescTemplate_Type*)0)->userData), NULL, 0 }, // actorDescTemplate.userData
	{ TYPE_U64, false, (size_t)(&((ActorDescTemplate_Type*)0)->name), NULL, 0 }, // actorDescTemplate.name
	{ TYPE_U64, false, (size_t)(&((ActorDescTemplate_Type*)0)->compartment), NULL, 0 }, // actorDescTemplate.compartment
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->bodyDescTemplate), CHILDREN(133), 12 }, // bodyDescTemplate
	{ TYPE_STRUCT, false, (size_t)(&((BodyDescTemplate_Type*)0)->flags), CHILDREN(145), 4 }, // bodyDescTemplate.flags
	{ TYPE_BOOL, false, (size_t)(&((BodyDescFlags_Type*)0)->NX_BF_DISABLE_GRAVITY), NULL, 0 }, // bodyDescTemplate.flags.NX_BF_DISABLE_GRAVITY
	{ TYPE_BOOL, false, (size_t)(&((BodyDescFlags_Type*)0)->NX_BF_FILTER_SLEEP_VEL), NULL, 0 }, // bodyDescTemplate.flags.NX_BF_FILTER_SLEEP_VEL
	{ TYPE_BOOL, false, (size_t)(&((BodyDescFlags_Type*)0)->NX_BF_ENERGY_SLEEP_TEST), NULL, 0 }, // bodyDescTemplate.flags.NX_BF_ENERGY_SLEEP_TEST
	{ TYPE_BOOL, false, (size_t)(&((BodyDescFlags_Type*)0)->NX_BF_VISUALIZATION), NULL, 0 }, // bodyDescTemplate.flags.NX_BF_VISUALIZATION
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->wakeUpCounter), NULL, 0 }, // bodyDescTemplate.wakeUpCounter
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->linearDamping), NULL, 0 }, // bodyDescTemplate.linearDamping
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->angularDamping), NULL, 0 }, // bodyDescTemplate.angularDamping
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->maxAngularVelocity), NULL, 0 }, // bodyDescTemplate.maxAngularVelocity
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->CCDMotionThreshold), NULL, 0 }, // bodyDescTemplate.CCDMotionThreshold
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->sleepLinearVelocity), NULL, 0 }, // bodyDescTemplate.sleepLinearVelocity
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->sleepAngularVelocity), NULL, 0 }, // bodyDescTemplate.sleepAngularVelocity
	{ TYPE_U32, false, (size_t)(&((BodyDescTemplate_Type*)0)->solverIterationCount), NULL, 0 }, // bodyDescTemplate.solverIterationCount
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->sleepEnergyThreshold), NULL, 0 }, // bodyDescTemplate.sleepEnergyThreshold
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->sleepDamping), NULL, 0 }, // bodyDescTemplate.sleepDamping
	{ TYPE_F32, false, (size_t)(&((BodyDescTemplate_Type*)0)->contactReportThreshold), NULL, 0 }, // bodyDescTemplate.contactReportThreshold
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->p3ShapeDescTemplate), CHILDREN(149), 8 }, // p3ShapeDescTemplate
	{ TYPE_STRUCT, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->flags), CHILDREN(157), 7 }, // p3ShapeDescTemplate.flags
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->eSIMULATION_SHAPE), NULL, 0 }, // p3ShapeDescTemplate.flags.eSIMULATION_SHAPE
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->eSCENE_QUERY_SHAPE), NULL, 0 }, // p3ShapeDescTemplate.flags.eSCENE_QUERY_SHAPE
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->eTRIGGER_SHAPE), NULL, 0 }, // p3ShapeDescTemplate.flags.eTRIGGER_SHAPE
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->eVISUALIZATION), NULL, 0 }, // p3ShapeDescTemplate.flags.eVISUALIZATION
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->ePARTICLE_DRAIN), NULL, 0 }, // p3ShapeDescTemplate.flags.ePARTICLE_DRAIN
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->eDEFORMABLE_DRAIN), NULL, 0 }, // p3ShapeDescTemplate.flags.eDEFORMABLE_DRAIN
	{ TYPE_BOOL, false, (size_t)(&((P3ShapeFlags_Type*)0)->eUSE_SWEPT_BOUNDS), NULL, 0 }, // p3ShapeDescTemplate.flags.eUSE_SWEPT_BOUNDS
	{ TYPE_STRUCT, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->simulationFilterData), CHILDREN(164), 4 }, // p3ShapeDescTemplate.simulationFilterData
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word0), NULL, 0 }, // p3ShapeDescTemplate.simulationFilterData.word0
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word1), NULL, 0 }, // p3ShapeDescTemplate.simulationFilterData.word1
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word2), NULL, 0 }, // p3ShapeDescTemplate.simulationFilterData.word2
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word3), NULL, 0 }, // p3ShapeDescTemplate.simulationFilterData.word3
	{ TYPE_STRUCT, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->queryFilterData), CHILDREN(168), 4 }, // p3ShapeDescTemplate.queryFilterData
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word0), NULL, 0 }, // p3ShapeDescTemplate.queryFilterData.word0
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word1), NULL, 0 }, // p3ShapeDescTemplate.queryFilterData.word1
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word2), NULL, 0 }, // p3ShapeDescTemplate.queryFilterData.word2
	{ TYPE_U32, false, (size_t)(&((P3FilterData_Type*)0)->word3), NULL, 0 }, // p3ShapeDescTemplate.queryFilterData.word3
	{ TYPE_U64, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->material), NULL, 0 }, // p3ShapeDescTemplate.material
	{ TYPE_F32, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->contactOffset), NULL, 0 }, // p3ShapeDescTemplate.contactOffset
	{ TYPE_F32, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->restOffset), NULL, 0 }, // p3ShapeDescTemplate.restOffset
	{ TYPE_U64, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->userData), NULL, 0 }, // p3ShapeDescTemplate.userData
	{ TYPE_U64, false, (size_t)(&((P3ShapeDescTemplate_Type*)0)->name), NULL, 0 }, // p3ShapeDescTemplate.name
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->p3ActorDescTemplate), CHILDREN(172), 7 }, // p3ActorDescTemplate
	{ TYPE_STRUCT, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->flags), CHILDREN(179), 3 }, // p3ActorDescTemplate.flags
	{ TYPE_BOOL, false, (size_t)(&((P3ActorFlags_Type*)0)->eVISUALIZATION), NULL, 0 }, // p3ActorDescTemplate.flags.eVISUALIZATION
	{ TYPE_BOOL, false, (size_t)(&((P3ActorFlags_Type*)0)->eDISABLE_GRAVITY), NULL, 0 }, // p3ActorDescTemplate.flags.eDISABLE_GRAVITY
	{ TYPE_BOOL, false, (size_t)(&((P3ActorFlags_Type*)0)->eSEND_SLEEP_NOTIFIES), NULL, 0 }, // p3ActorDescTemplate.flags.eSEND_SLEEP_NOTIFIES
	{ TYPE_U8, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->dominanceGroup), NULL, 0 }, // p3ActorDescTemplate.dominanceGroup
	{ TYPE_U8, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->ownerClient), NULL, 0 }, // p3ActorDescTemplate.ownerClient
	{ TYPE_U32, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->clientBehaviorBits), NULL, 0 }, // p3ActorDescTemplate.clientBehaviorBits
	{ TYPE_STRUCT, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->contactReportFlags), CHILDREN(182), 17 }, // p3ActorDescTemplate.contactReportFlags
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eRESOLVE_CONTACTS), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eRESOLVE_CONTACTS
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eMODIFY_CONTACTS), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eMODIFY_CONTACTS
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_TOUCH_FOUND), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_FOUND
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_TOUCH_PERSISTS), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_PERSISTS
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_TOUCH_LOST), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_LOST
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_THRESHOLD_FORCE_FOUND), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_FOUND
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_THRESHOLD_FORCE_PERSISTS), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_PERSISTS
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_THRESHOLD_FORCE_LOST), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_LOST
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_CONTACT_POINTS), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_POINTS
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_CONTACT_FORCES), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FORCES
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_CONTACT_FORCE_PER_POINT), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FORCE_PER_POINT
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eNOTIFY_CONTACT_FEATURE_INDICES_PER_POINT), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FEATURE_INDICES_PER_POINT
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eSWEPT_CONTACT_GENERATION), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eSWEPT_CONTACT_GENERATION
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eSWEPT_INTEGRATION_LINEAR), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eSWEPT_INTEGRATION_LINEAR
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eSWEPT_INTEGRATION_FULL), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eSWEPT_INTEGRATION_FULL
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eCONTACT_DEFAULT), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eCONTACT_DEFAULT
	{ TYPE_BOOL, false, (size_t)(&((P3PairFlag_Type*)0)->eTRIGGER_DEFAULT), NULL, 0 }, // p3ActorDescTemplate.contactReportFlags.eTRIGGER_DEFAULT
	{ TYPE_U64, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->userData), NULL, 0 }, // p3ActorDescTemplate.userData
	{ TYPE_U64, false, (size_t)(&((P3ActorDescTemplate_Type*)0)->name), NULL, 0 }, // p3ActorDescTemplate.name
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->p3BodyDescTemplate), CHILDREN(199), 10 }, // p3BodyDescTemplate
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->density), NULL, 0 }, // p3BodyDescTemplate.density
	{ TYPE_STRUCT, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->flags), CHILDREN(209), 1 }, // p3BodyDescTemplate.flags
	{ TYPE_BOOL, false, (size_t)(&((P3BodyDescFlags_Type*)0)->eKINEMATIC), NULL, 0 }, // p3BodyDescTemplate.flags.eKINEMATIC
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->sleepThreshold), NULL, 0 }, // p3BodyDescTemplate.sleepThreshold
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->wakeUpCounter), NULL, 0 }, // p3BodyDescTemplate.wakeUpCounter
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->linearDamping), NULL, 0 }, // p3BodyDescTemplate.linearDamping
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->angularDamping), NULL, 0 }, // p3BodyDescTemplate.angularDamping
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->maxAngularVelocity), NULL, 0 }, // p3BodyDescTemplate.maxAngularVelocity
	{ TYPE_U32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->solverIterationCount), NULL, 0 }, // p3BodyDescTemplate.solverIterationCount
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->contactReportThreshold), NULL, 0 }, // p3BodyDescTemplate.contactReportThreshold
	{ TYPE_F32, false, (size_t)(&((P3BodyDescTemplate_Type*)0)->sleepLinearVelocity), NULL, 0 }, // p3BodyDescTemplate.sleepLinearVelocity
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->structureSettings), CHILDREN(210), 3 }, // structureSettings
	{ TYPE_BOOL, false, (size_t)(&((StructureSettings_Type*)0)->useStressSolver), NULL, 0 }, // structureSettings.useStressSolver
	{ TYPE_F32, false, (size_t)(&((StructureSettings_Type*)0)->stressSolverTimeDelay), NULL, 0 }, // structureSettings.stressSolverTimeDelay
	{ TYPE_F32, false, (size_t)(&((StructureSettings_Type*)0)->stressSolverMassThreshold), NULL, 0 }, // structureSettings.stressSolverMassThreshold
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->defaultBehaviorGroup), CHILDREN(213), 10 }, // defaultBehaviorGroup
	{ TYPE_STRING, false, (size_t)(&((BehaviorGroup_Type*)0)->name), NULL, 0 }, // defaultBehaviorGroup.name
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageThreshold), NULL, 0 }, // defaultBehaviorGroup.damageThreshold
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageToRadius), NULL, 0 }, // defaultBehaviorGroup.damageToRadius
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageSpread), CHILDREN(223), 3 }, // defaultBehaviorGroup.damageSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // defaultBehaviorGroup.damageSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // defaultBehaviorGroup.damageSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // defaultBehaviorGroup.damageSpread.falloffExponent
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorSpread), CHILDREN(226), 3 }, // defaultBehaviorGroup.damageColorSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // defaultBehaviorGroup.damageColorSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // defaultBehaviorGroup.damageColorSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // defaultBehaviorGroup.damageColorSpread.falloffExponent
	{ TYPE_VEC4, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorChange), NULL, 0 }, // defaultBehaviorGroup.damageColorChange
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->materialStrength), NULL, 0 }, // defaultBehaviorGroup.materialStrength
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->density), NULL, 0 }, // defaultBehaviorGroup.density
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->fadeOut), NULL, 0 }, // defaultBehaviorGroup.fadeOut
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->groupsMask), CHILDREN(229), 5 }, // defaultBehaviorGroup.groupsMask
	{ TYPE_BOOL, false, (size_t)(&((GroupsMask_Type*)0)->useGroupsMask), NULL, 0 }, // defaultBehaviorGroup.groupsMask.useGroupsMask
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits0), NULL, 0 }, // defaultBehaviorGroup.groupsMask.bits0
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits1), NULL, 0 }, // defaultBehaviorGroup.groupsMask.bits1
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits2), NULL, 0 }, // defaultBehaviorGroup.groupsMask.bits2
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits3), NULL, 0 }, // defaultBehaviorGroup.groupsMask.bits3
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->behaviorGroups), CHILDREN(234), 1 }, // behaviorGroups
	{ TYPE_STRUCT, false, 1 * sizeof(BehaviorGroup_Type), CHILDREN(235), 10 }, // behaviorGroups[]
	{ TYPE_STRING, false, (size_t)(&((BehaviorGroup_Type*)0)->name), NULL, 0 }, // behaviorGroups[].name
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageThreshold), NULL, 0 }, // behaviorGroups[].damageThreshold
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageToRadius), NULL, 0 }, // behaviorGroups[].damageToRadius
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageSpread), CHILDREN(245), 3 }, // behaviorGroups[].damageSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // behaviorGroups[].damageSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // behaviorGroups[].damageSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // behaviorGroups[].damageSpread.falloffExponent
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorSpread), CHILDREN(248), 3 }, // behaviorGroups[].damageColorSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // behaviorGroups[].damageColorSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // behaviorGroups[].damageColorSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // behaviorGroups[].damageColorSpread.falloffExponent
	{ TYPE_VEC4, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorChange), NULL, 0 }, // behaviorGroups[].damageColorChange
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->materialStrength), NULL, 0 }, // behaviorGroups[].materialStrength
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->density), NULL, 0 }, // behaviorGroups[].density
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->fadeOut), NULL, 0 }, // behaviorGroups[].fadeOut
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->groupsMask), CHILDREN(251), 5 }, // behaviorGroups[].groupsMask
	{ TYPE_BOOL, false, (size_t)(&((GroupsMask_Type*)0)->useGroupsMask), NULL, 0 }, // behaviorGroups[].groupsMask.useGroupsMask
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits0), NULL, 0 }, // behaviorGroups[].groupsMask.bits0
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits1), NULL, 0 }, // behaviorGroups[].groupsMask.bits1
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits2), NULL, 0 }, // behaviorGroups[].groupsMask.bits2
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits3), NULL, 0 }, // behaviorGroups[].groupsMask.bits3
};


bool DestructibleActorParam_0p18::mBuiltFlag = false;
NvParameterized::MutexType DestructibleActorParam_0p18::mBuiltFlagMutex;

DestructibleActorParam_0p18::DestructibleActorParam_0p18(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &DestructibleActorParam_0p18FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

DestructibleActorParam_0p18::~DestructibleActorParam_0p18()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void DestructibleActorParam_0p18::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~DestructibleActorParam_0p18();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* DestructibleActorParam_0p18::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* DestructibleActorParam_0p18::getParameterDefinitionTree(void) const
{
	DestructibleActorParam_0p18* tmpParam = const_cast<DestructibleActorParam_0p18*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType DestructibleActorParam_0p18::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType DestructibleActorParam_0p18::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void DestructibleActorParam_0p18::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<DestructibleActorParam_0p18::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */
/* [0] - overrideSkinnedMaterialNames (not an array of structs) */
/* [0] - overrideStaticMaterialNames (not an array of structs) */
/* [1,0] - behaviorGroups.name */

void DestructibleActorParam_0p18::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void DestructibleActorParam_0p18::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="crumbleEmitterName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("crumbleEmitterName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The name of the NxMeshParticleSystem to use for crumbling.  This overrides the crumble system defined\nin the NxDestructibleAsset if specified.\n", true);
		HintTable[1].init("shortDescription", "The name of the NxMeshParticleSystem to use for crumbling", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="crumbleParticleSpacing"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("crumbleParticleSpacing", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How far apart to space the particles when crumling.  If set to zero or a negative value, then the spacing is taken to be the crumble emitter's particle radius, if the\ncrumble emitter exists.  This spacing will be used when placing particle positions in the crumble emitter and the crumble buffer callback.  Note - if there is no crumble emitter\nbut there is a crumble buffer callback, then this value must be positive in order to have a proper spacing for the callback.  Otherwise, the callback will not be called.\nThe default value is 0.\n", true);
		HintTable[1].init("shortDescription", "How far apart to space the particles when crumbling", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="dustEmitterName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("dustEmitterName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The name of the NxMeshParticleSystem to use for fracture-line dust.  This overrides the dust system defined\nin the NxDestructibleAsset if specified.\n", true);
		HintTable[1].init("shortDescription", "The name of the NxMeshParticleSystem to use for fracture-line dust", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="dustParticleSpacing"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("dustParticleSpacing", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How far apart to space the particles when crumling.  If set to zero or a negative value, then the spacing is taken to be the dust emitter's particle radius, if the\ndust emitter exists.  This spacing will be used when placing particle positions in the dust emitter and the dust particle buffer callback.  Note - if there is no dust emitter\nbut there is a dust particle buffer callback, then this value must be positive in order to have a proper spacing for the callback.  Otherwise, the callback will not be called.\nThe default value is 0.\n", true);
		HintTable[1].init("shortDescription", "How far apart to space the particles when creating dust particles", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="globalPose"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("globalPose", TYPE_MAT34, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Initial global pose of undamaged destructible\n", true);
		HintTable[1].init("shortDescription", "The initial pose where the destructible actor will be put into the scene", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="scale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("scale", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "3D Scale\n", true);
		HintTable[1].init("shortDescription", "3D Scale", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="dynamic"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("dynamic", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not the destructible starts life as a dynamic actor\n", true);
		HintTable[1].init("shortDescription", "Whether or not the destructible starts life as a dynamic actor", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="supportDepth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("supportDepth", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The chunk hierarchy depth at which to create a support graph.  Higher depth levels give more detailed support,\nbut will give a higher computational load.  Chunks below the support depth will never be supported.\n", true);
		HintTable[1].init("shortDescription", "The chunk hierarchy depth at which to create a support graph.", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="formExtendedStructures"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("formExtendedStructures", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If initially static, the destructible will become part of an extended support structure if it is\nin contact with another static destructible that also has this flag set.\n", true);
		HintTable[1].init("shortDescription", "If initially static, the destructible will become part of an extended support structure if it is in contact with another static destructible that also has this flag set.", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="keepPreviousFrameBoneBuffer"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("keepPreviousFrameBoneBuffer", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If true, the skinned mesh will hold a bone buffer for the last frame.  The poses in the new buffer correspond the poses in the current frame buffer,\n				chunk was not visible in the last frame.", true);
		HintTable[1].init("shortDescription", "If true, the skinned mesh will hold a bone buffer for the last frame", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="useAssetDefinedSupport"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("useAssetDefinedSupport", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, then chunks which are tagged as 'support' chunks (via NxDestructibleChunkDesc::isSupportChunk)\nwill have environmental support in static destructibles.\nNote: if both ASSET_DEFINED_SUPPORT and WORLD_SUPPORT are set, then chunks must be tagged as\n'support' chunks AND overlap the NxScene's static geometry in order to be environmentally supported.\n", true);
		HintTable[1].init("shortDescription", "If set, then chunks which are tagged as 'support' chunks", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="useWorldSupport"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("useWorldSupport", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, then chunks which overlap the NxScene\'s static geometry will have environmental support in\nstatic destructibles.\nNote: if both ASSET_DEFINED_SUPPORT and WORLD_SUPPORT are set, then chunks must be tagged as\n'support' chunks AND overlap the NxScene's static geometry in order to be environmentally supported.\n", true);
		HintTable[1].init("shortDescription", "If set, then chunks which overlap the NxScene's static geometry will have environmental support", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="renderStaticChunksSeparately"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("renderStaticChunksSeparately", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If true, static chunks will be renderered separately from dynamic chunks, as a single mesh (not using skinning).\nThis parameter is ignored if the \'dynamic\' parameter is true.\nDefault value = false.\n", true);
		HintTable[1].init("shortDescription", "Whether or not to render static chunks in a separate mesh", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="createChunkEvents"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("createChunkEvents", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not to create an event buffer for chunk.\nIf true, the user has access to a chunk event buffer, which currently holds visibility state change events.\nThe user must empty this buffer themselves after reading, otherwise it will continue to grow as new events are added.\nDefault value = false.\n", true);
		HintTable[1].init("shortDescription", "Whether or not to create an event buffer for chunks", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="overrideSkinnedMaterialNames"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("overrideSkinnedMaterialNames", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Per-actor material names, to override those in the asset, for skinned rendering.", true);
		HintTable[1].init("shortDescription", "Per-actor material names, to override those in the asset, for skinned rendering", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="overrideSkinnedMaterialNames[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("overrideSkinnedMaterialNames", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Per-actor material names, to override those in the asset, for skinned rendering.", true);
		HintTable[1].init("shortDescription", "Per-actor material names, to override those in the asset, for skinned rendering", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="overrideStaticMaterialNames"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("overrideStaticMaterialNames", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Per-actor material names, to override those in the asset, for static rendering.", true);
		HintTable[1].init("shortDescription", "Per-actor material names, to override those in the asset, for static rendering", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="overrideStaticMaterialNames[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("overrideStaticMaterialNames", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Per-actor material names, to override those in the asset, for static rendering.", true);
		HintTable[1].init("shortDescription", "Per-actor material names, to override those in the asset, for static rendering", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="sleepVelocityFrameDecayConstant"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("sleepVelocityFrameDecayConstant", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Frame memory decay constant used for actor velocity smoothing.  Valid range: [1.0,infinity).  Roughly speaking,\n				the number of frames for which past velocities have significance.  A value of 1.0 (or less) gives no smoothing.", true);
		HintTable[1].init("shortDescription", "Frame memory decay constant used for actor velocity smoothing.  Valid range: [1.0,infinity).", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="useHardSleeping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("useHardSleeping", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If true, turn chunk islands kinematic when they sleep.  These islands may be turned dynamic again if enough damage is applied.", true);
		HintTable[1].init("shortDescription", "If true, turn chunk islands kinematic when they sleep.", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="destructibleParameters"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("destructibleParameters", TYPE_STRUCT, "DestructibleParameters", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Parameters controlling the destruction properties - damage thresholds, damage radius multipliers, etc.\n", true);
		HintTable[1].init("shortDescription", "Parameters controlling the destruction properties - damage thresholds, damage radius multipliers, etc.", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="destructibleParameters.damageCap"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("damageCap", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Limits the amount of damage applied to a chunk.  This is useful for preventing the entire destructible\nfrom getting pulverized by a very large application of damage.  This can easily happen when impact damage is\nused, and the damage amount is proportional to the impact force (see forceToDamage).\n", true);
		HintTable[1].init("shortDescription", "Limits the amount of damage applied to a chunk.", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="destructibleParameters.forceToDamage"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("forceToDamage", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If a chunk is at a depth which takes impact damage (see NxDestructibleDepthParameters),\nthen when a chunk has a collision in the NxScene, it will take damage equal to forceToDamage mulitplied by\nthe impact force.\nThe default value is zero, which effectively disables impact damage.\n", true);
		HintTable[1].init("shortDescription", "Multiplier to calculate applied damage from an impact.", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="destructibleParameters.impactVelocityThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("impactVelocityThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Large impact force may be reported if rigid bodies are spawned inside one another.  In this case the relative velocity of the two\nobjects will be low.  This variable allows the user to set a minimum velocity threshold for impacts to ensure that the objects are\nmoving at a min velocity in order for the impact force to be considered.\n", true);
		HintTable[1].init("shortDescription", "Large impact force may be reported if rigid bodies are spawned inside one another.", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="destructibleParameters.minimumFractureDepth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("minimumFractureDepth", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks will not be broken free below this depth.\n", true);
		HintTable[1].init("shortDescription", "The chunks will not be broken free below this depth.", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="destructibleParameters.impactDamageDefaultDepth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("impactDamageDefaultDepth", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default depth to which chunks will take impact damage.  This default may be overridden in the depth settings.\n", true);
		HintTable[1].init("shortDescription", "The default depth to which chunks will take impact damage.", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="destructibleParameters.debrisDepth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("debrisDepth", TYPE_I32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The chunk hierarchy depth at which chunks are considered to be 'debris.'  Chunks at this depth or\nbelow will be considered for various debris settings, such as debrisLifetime.\nNegative values indicate that no chunk depth is considered debris.\nDefault value is -1.\n", true);
		HintTable[1].init("shortDescription", "The chunk hierarchy depth at which chunks are considered to be 'debris.'", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="destructibleParameters.essentialDepth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("essentialDepth", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The chunk hierarchy depth up to which chunks will always be processed.  These chunks are considered\nto be essential either for gameplay or visually.\nThe minimum value is 0, meaning the level 0 chunk is always considered essential.\nDefault value is 0.\n", true);
		HintTable[1].init("shortDescription", "The chunk hierarchy depth up to which chunks will always be processed", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="destructibleParameters.debrisLifetimeMin"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("debrisLifetimeMin", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed after a time (in seconds)\nseparated from non-debris chunks.  The actual lifetime is interpolated between\ndebrisLifetimeMin and debrisLifetimeMax (see below), based upon the module\'s LOD setting.\nTo disable lifetime, clear the NxDestructibleDepthParametersFlag::DEBRIS_TIMEOUT\nflag in the flags field.  If debrisLifetimeMax < debrisLifetimeMin, the mean of the two\nis used for both.\nDefault debrisLifetimeMin = 1.0, debrisLifetimeMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Minimum time to destroy debris", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="destructibleParameters.debrisLifetimeMax"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("debrisLifetimeMax", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed after a time (in seconds)\nseparated from non-debris chunks.  The actual lifetime is interpolated between\ndebrisLifetimeMin (see above) and debrisLifetimeMax, based upon the module\'s LOD setting.\nTo disable lifetime, clear the NxDestructibleDepthParametersFlag::DEBRIS_TIMEOUT\nflag in the flags field.  If debrisLifetimeMax < debrisLifetimeMin, the mean of the two\nis used for both.\nDefault debrisLifetimeMin = 1.0, debrisLifetimeMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Maximum time to destroy debris", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="destructibleParameters.debrisMaxSeparationMin"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("debrisMaxSeparationMin", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed if they are separated from\ntheir origin by a distance greater than maxSeparation.  The actual maxSeparation is\ninterpolated between debrisMaxSeparationMin and debrisMaxSeparationMax (see below),\nbased upon the module\'s LOD setting.  To disable maxSeparation, clear the\nNX_DESTRUCTIBLE_DEBRIS_MAX_SEPARATION flag in the flags field.\nIf debrisMaxSeparationMax < debrisMaxSeparationMin, the mean of the two is used for both.\nDefault debrisMaxSeparationMin = 1.0, debrisMaxSeparationMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Minimum separation distance", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="destructibleParameters.debrisMaxSeparationMax"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("debrisMaxSeparationMax", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed if they are separated from\ntheir origin by a distance greater than maxSeparation.  The actual maxSeparation is\ninterpolated between debrisMaxSeparationMin (see above) and debrisMaxSeparationMax,\nbased upon the module\'s LOD setting.  To disable maxSeparation, clear the\nNX_DESTRUCTIBLE_DEBRIS_MAX_SEPARATION flag in the flags field.\nIf debrisMaxSeparationMax < debrisMaxSeparationMin, the mean of the two is used for both.\nDefault debrisMaxSeparationMin = 1.0, debrisMaxSeparationMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Minimum separation distance", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="destructibleParameters.debrisDestructionProbability"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("debrisDestructionProbability", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The probablity that a debris chunk, when fractured, will simply be destroyed instead of becoming dynamic or breaking down\n						further into child chunks.  Valid range = [0.0,1.0].  Default value = 0.0.", true);
		HintTable[1].init("shortDescription", "The probablity that a debris chunk, when fractured, will simply be destroyed", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="destructibleParameters.validBounds"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("validBounds", TYPE_BOUNDS3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A bounding box around each NxDestructibleActor created, defining a range of validity\nfor chunks that break free.  These bounds are scaled and translated with the\nNxDestructibleActor\'s scale and position, but they are not rotated with the\nNxDestructibleActor.\n", true);
		HintTable[1].init("shortDescription", "valid bounding region for debris", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="destructibleParameters.maxChunkSpeed"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("maxChunkSpeed", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If greater than 0, the chunks' speeds will not be allowed to exceed this value.  Use 0\nto disable this feature (this is the default).\n", true);
		HintTable[1].init("shortDescription", "Maximum speed of a chunk", true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="destructibleParameters.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("flags", TYPE_STRUCT, "DestructibleParametersFlag", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A collection of flags defined in NxDestructibleParametersFlag.\n", true);
		HintTable[1].init("shortDescription", "A collection of flags defined in DestructibleParametersFlag.", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="destructibleParameters.flags.ACCUMULATE_DAMAGE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("ACCUMULATE_DAMAGE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, chunks will 'remember' damage applied to them, so that many applications of a damage amount\nbelow damageThreshold will eventually fracture the chunk.  If not set, a single application of\ndamage must exceed damageThreshold in order to fracture the chunk.\n", true);
		HintTable[1].init("shortDescription", "Determines if chunks accumulate damage", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="destructibleParameters.flags.DEBRIS_TIMEOUT"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("DEBRIS_TIMEOUT", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not chunks at or deeper than the 'debris' depth (see NxDestructibleParameters::debrisDepth)\nwill time out.  The lifetime is a value between NxDestructibleParameters::debrisLifetimeMin and\nNxDestructibleParameters::debrisLifetimeMax, based upon the destructible module\'s LOD setting.\n", true);
		HintTable[1].init("shortDescription", "Whether or not chunks at or deeper than the 'debris' depth will timeout", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="destructibleParameters.flags.DEBRIS_MAX_SEPARATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("DEBRIS_MAX_SEPARATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not chunks at or deeper than the 'debris' depth (see NxDestructibleParameters::debrisDepth)\nwill be removed if they separate too far from their origins.  The maxSeparation is a value between\nNxDestructibleParameters::debrisMaxSeparationMin and NxDestructibleParameters::debrisMaxSeparationMax,\nbased upon the destructible module\'s LOD setting.\n", true);
		HintTable[1].init("shortDescription", "Whether or not chunks at or deeper than the 'debris' depth will be removed if separated too far", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="destructibleParameters.flags.CRUMBLE_SMALLEST_CHUNKS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("CRUMBLE_SMALLEST_CHUNKS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, the smallest chunks may be further broken down, either by fluid crumbles (if a crumble particle\nsystem is specified in the NxDestructibleActorDesc), or by simply removing the chunk if no crumble\nparticle system is specified.  Note: the 'smallest chunks' are normally defined to be the deepest level\nof the fracture hierarchy.  However, they may be taken from higher levels of the hierarchy if\nNxModuleDestructible::setMaxChunkDepthOffset is called with a non-zero value.\n", true);
		HintTable[1].init("shortDescription", "If set, the smallest chunks may be further broken down", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="destructibleParameters.flags.ACCURATE_RAYCASTS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("ACCURATE_RAYCASTS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, the NxDestructibleActor::rayCast function will search within the nearest visible chunk hit\nfor collisions with child chunks.  This is used to get a better raycast position and normal, in\ncase the parent collision volume does not tightly fit the graphics mesh.  The returned chunk index\nwill always be that of the visible parent that is intersected, however.\n", true);
		HintTable[1].init("shortDescription", "If set, the NxDestructibleActor::rayCast function will search within the nearest visible chunk hit", true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="destructibleParameters.flags.USE_VALID_BOUNDS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("USE_VALID_BOUNDS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, the validBounds field of NxDestructibleParameters will be used.  These bounds are translated\n(but not scaled or rotated) to the origin of the destructible actor.  If a chunk or chunk island moves\noutside of those bounds, it is destroyed.\n", true);
		HintTable[1].init("shortDescription", "If set, the validBounds field of NxDestructibleParameters will be used.", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="destructibleParameters.flags.CRUMBLE_VIA_RUNTIME_FRACTURE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("CRUMBLE_VIA_RUNTIME_FRACTURE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, crumbled chunks will use the runtime fracture pipeline. The chunk will be procedurally broken\ndestroyed using either the default or a specified fracture pattern.\n", true);
		HintTable[1].init("shortDescription", "If set, crumbled chunks will use the runtime fracture pipeline.", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="destructibleParameters.fractureImpulseScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("fractureImpulseScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Scale factor used to apply an impulse force along the normal of chunk when fractured.  This is used\nin order to 'push' the pieces out as they fracture.\n", true);
		HintTable[1].init("shortDescription", "Scale factor used to apply an impulse force along the normal of chunk when fractured.", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="destructibleParameters.damageDepthLimit"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("damageDepthLimit", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How deep in the hierarchy damage will be propagated, relative to the chunk hit.", true);
		HintTable[1].init("shortDescription", "How deep in the hierarchy damage will be propagated, relative to the chunk hit.", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="destructibleParameters.dynamicChunkDominanceGroup"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("dynamicChunkDominanceGroup", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Optional dominance group for dynamic chunks created when fractured. (ignored if > 31)\n", true);
		HintTable[1].init("shortDescription", "Optional dominance group for dynamic chunks created when fractured.", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="destructibleParameters.dynamicChunksGroupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("dynamicChunksGroupsMask", TYPE_STRUCT, "GroupsMask", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Optional groups mask for dynamic chunks created when fractured.\n", true);
		HintTable[1].init("shortDescription", "Optional groups mask for dynamic chunks created when fractured.", true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="destructibleParameters.dynamicChunksGroupsMask.useGroupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("useGroupsMask", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not the groupsMask should be used.  If so, then this will be applied to all NxShapes\n						created to represent this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Whether or not the groupsMask should be used", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="destructibleParameters.dynamicChunksGroupsMask.bits0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("bits0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits0 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits0 of the groups mask", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="destructibleParameters.dynamicChunksGroupsMask.bits1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("bits1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits1 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits1 of the groups mask", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="destructibleParameters.dynamicChunksGroupsMask.bits2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("bits2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits2 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits2 of the groups mask", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="destructibleParameters.dynamicChunksGroupsMask.bits3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("bits3", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits3 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits3 of the groups mask", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="depthParameters"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("depthParameters", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Parameters that apply to every chunk at a given level (see NxDestructibleDepthParameters)\nthe element [0] of the array applies to the level 0 (unfractured) chunk, element [1] applies\nto the level 1 chunks, etc.\n", true);
		HintTable[1].init("shortDescription", "Parameters that apply to every chunk at a given level (see NxDestructibleDepthParameters).", true);
		ParamDefTable[53].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="depthParameters[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("depthParameters", TYPE_STRUCT, "DestructibleDepthParameters", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Parameters that apply to every chunk at a given level (see NxDestructibleDepthParameters)\nthe element [0] of the array applies to the level 0 (unfractured) chunk, element [1] applies\nto the level 1 chunks, etc.\n", true);
		HintTable[1].init("shortDescription", "Parameters that apply to every chunk at a given level (see NxDestructibleDepthParameters).", true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="depthParameters[].OVERRIDE_IMPACT_DAMAGE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("OVERRIDE_IMPACT_DAMAGE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE, no matter the setting of impactDamageDefaultDepth.\n", true);
		HintTable[1].init("shortDescription", "If true, chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE, no matter the setting of impactDamageDefaultDepth.", true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="depthParameters[].OVERRIDE_IMPACT_DAMAGE_VALUE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("OVERRIDE_IMPACT_DAMAGE_VALUE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If OVERRIDE_IMPACT_DAMAGE = TRUE, chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE.\n", true);
		HintTable[1].init("shortDescription", "If OVERRIDE_IMPACT_DAMAGE = TRUE, chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE.", true);
		ParamDefTable[56].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="depthParameters[].IGNORE_POSE_UPDATES"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("IGNORE_POSE_UPDATES", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this depth should have pose updates ignored.\n", true);
		HintTable[1].init("shortDescription", "Chunks at this depth should have pose updates ignored.", true);
		ParamDefTable[57].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="depthParameters[].IGNORE_RAYCAST_CALLBACKS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("IGNORE_RAYCAST_CALLBACKS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this depth should be ignored in raycast callbacks.\n", true);
		HintTable[1].init("shortDescription", "Chunks at this depth should be ignored in raycast callbacks.", true);
		ParamDefTable[58].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="depthParameters[].IGNORE_CONTACT_CALLBACKS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("IGNORE_CONTACT_CALLBACKS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this depth should be ignored in contact callbacks.\n", true);
		HintTable[1].init("shortDescription", "Chunks at this depth should be ignored in contact callbacks.", true);
		ParamDefTable[59].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="depthParameters[].USER_FLAG_0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("USER_FLAG_0", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[60].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="depthParameters[].USER_FLAG_1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("USER_FLAG_1", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=62, longName="depthParameters[].USER_FLAG_2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[62];
		ParamDef->init("USER_FLAG_2", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[62].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=63, longName="depthParameters[].USER_FLAG_3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[63];
		ParamDef->init("USER_FLAG_3", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[63].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=64, longName="shapeDescTemplate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[64];
		ParamDef->init("shapeDescTemplate", TYPE_STRUCT, "ShapeDescTemplate", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[64].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains the parameters the application can override on any actor shapes created.", true);
		HintTable[2].init("shortDescription", "Contains the parameters the application can override on any actor shapes created", true);
		ParamDefTable[64].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=65, longName="shapeDescTemplate.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[65];
		ParamDef->init("flags", TYPE_STRUCT, "ShapeDescFlags", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=66, longName="shapeDescTemplate.flags.NX_TRIGGER_ON_ENTER"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[66];
		ParamDef->init("NX_TRIGGER_ON_ENTER", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Trigger callback will be called when a shape enters the trigger volume.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Trigger callback will be called when a shape enters the trigger volume.", true);
		ParamDefTable[66].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=67, longName="shapeDescTemplate.flags.NX_TRIGGER_ON_LEAVE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[67];
		ParamDef->init("NX_TRIGGER_ON_LEAVE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Trigger callback will be called after a shape leaves the trigger volume.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Trigger callback will be called after a shape leaves the trigger volume.", true);
		ParamDefTable[67].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=68, longName="shapeDescTemplate.flags.NX_TRIGGER_ON_STAY"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[68];
		ParamDef->init("NX_TRIGGER_ON_STAY", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Trigger callback will be called while a shape is intersecting the trigger volume.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Trigger callback will be called while a shape is intersecting the trigger volume.", true);
		ParamDefTable[68].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=69, longName="shapeDescTemplate.flags.NX_SF_VISUALIZATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[69];
		ParamDef->init("NX_SF_VISUALIZATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable debug renderer for shapes.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable debug renderer for shapes", true);
		ParamDefTable[69].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=70, longName="shapeDescTemplate.flags.NX_SF_DISABLE_COLLISION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[70];
		ParamDef->init("NX_SF_DISABLE_COLLISION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable collision detection for shapes (counterpart of NX_AF_DISABLE_COLLISION).  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable collision detection for shapes (counterpart of NX_AF_DISABLE_COLLISION)", true);
		ParamDefTable[70].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=71, longName="shapeDescTemplate.flags.NX_SF_FEATURE_INDICES"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[71];
		ParamDef->init("NX_SF_FEATURE_INDICES", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable feature indices in contact stream.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable feature indices in contact stream.", true);
		ParamDefTable[71].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=72, longName="shapeDescTemplate.flags.NX_SF_DISABLE_RAYCASTING"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[72];
		ParamDef->init("NX_SF_DISABLE_RAYCASTING", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable raycasting for shapes.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable raycasting for shapes", true);
		ParamDefTable[72].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=73, longName="shapeDescTemplate.flags.NX_SF_POINT_CONTACT_FORCE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[73];
		ParamDef->init("NX_SF_POINT_CONTACT_FORCE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable contact force reporting per contact point in contact stream (otherwise we only report force per actor pair).  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable contact force reporting per contact point in contact stream (otherwise we only report force per actor pair)", true);
		ParamDefTable[73].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=74, longName="shapeDescTemplate.flags.NX_SF_FLUID_DRAIN"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[74];
		ParamDef->init("NX_SF_FLUID_DRAIN", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets a shape to be a fluid drain.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets a shape to be a fluid drain.", true);
		ParamDefTable[74].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=75, longName="shapeDescTemplate.flags.NX_SF_FLUID_DISABLE_COLLISION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[75];
		ParamDef->init("NX_SF_FLUID_DISABLE_COLLISION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable collision with fluids.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable collision with fluids.", true);
		ParamDefTable[75].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=76, longName="shapeDescTemplate.flags.NX_SF_FLUID_TWOWAY"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[76];
		ParamDef->init("NX_SF_FLUID_TWOWAY", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables the reaction of a shapes actor on fluid collision.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables the reaction of a shapes actor on fluid collision.", true);
		ParamDefTable[76].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=77, longName="shapeDescTemplate.flags.NX_SF_DISABLE_RESPONSE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[77];
		ParamDef->init("NX_SF_DISABLE_RESPONSE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable collision response for shapes (counterpart of NX_AF_DISABLE_RESPONSE).  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable collision response for shapes (counterpart of NX_AF_DISABLE_RESPONSE)", true);
		ParamDefTable[77].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=78, longName="shapeDescTemplate.flags.NX_SF_DYNAMIC_DYNAMIC_CCD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[78];
		ParamDef->init("NX_SF_DYNAMIC_DYNAMIC_CCD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable dynamic-dynamic CCD for shapes. Used only when CCD is globally enabled and shape have a CCD skeleton.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable dynamic-dynamic CCD for shapes. Used only when CCD is globally enabled and shape have a CCD skeleton.", true);
		ParamDefTable[78].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=79, longName="shapeDescTemplate.flags.NX_SF_DISABLE_SCENE_QUERIES"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[79];
		ParamDef->init("NX_SF_DISABLE_SCENE_QUERIES", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable participation in ray casts, overlap tests and sweeps.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable participation in ray casts, overlap tests and sweeps.", true);
		ParamDefTable[79].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=80, longName="shapeDescTemplate.flags.NX_SF_CLOTH_DRAIN"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[80];
		ParamDef->init("NX_SF_CLOTH_DRAIN", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets a shape to be a cloth drain.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets a shape to be a cloth drain.", true);
		ParamDefTable[80].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=81, longName="shapeDescTemplate.flags.NX_SF_CLOTH_DISABLE_COLLISION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[81];
		ParamDef->init("NX_SF_CLOTH_DISABLE_COLLISION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable collision with cloths.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable collision with cloths.", true);
		ParamDefTable[81].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=82, longName="shapeDescTemplate.flags.NX_SF_CLOTH_TWOWAY"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[82];
		ParamDef->init("NX_SF_CLOTH_TWOWAY", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables the reaction of a shapes actor on cloth collision.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables the reaction of a shapes actor on cloth collision.", true);
		ParamDefTable[82].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=83, longName="shapeDescTemplate.flags.NX_SF_SOFTBODY_DRAIN"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[83];
		ParamDef->init("NX_SF_SOFTBODY_DRAIN", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets a shape to be a soft body drain.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets a shape to be a soft body drain.", true);
		ParamDefTable[83].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=84, longName="shapeDescTemplate.flags.NX_SF_SOFTBODY_DISABLE_COLLISION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[84];
		ParamDef->init("NX_SF_SOFTBODY_DISABLE_COLLISION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable collision with soft bodies.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disable collision with soft bodies.", true);
		ParamDefTable[84].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=85, longName="shapeDescTemplate.flags.NX_SF_SOFTBODY_TWOWAY"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[85];
		ParamDef->init("NX_SF_SOFTBODY_TWOWAY", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables the reaction of a shape's actor on soft body collision.  This flag is applied to all\n						NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables the reaction of a shape's actor on soft body collision.", true);
		ParamDefTable[85].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=86, longName="shapeDescTemplate.collisionGroup"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[86];
		ParamDef->init("collisionGroup", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets which collision group shapes are part of.\n						Default group is 0. Maximum possible group is 31. Collision groups are sets of shapes which may or may not be set to collision detect with each other; this can be set using NxScene::setGroupCollisionFlag() Sleeping: Does NOT wake the associated actor up automatically.  param[in] collisionGroup The collision group for shapes.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets which collision group shapes are part of.", true);
		ParamDefTable[86].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=87, longName="shapeDescTemplate.groupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[87];
		ParamDef->init("groupsMask", TYPE_STRUCT, "GroupsMask", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the 128-bit mask used for collision filtering.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the 128-bit mask used for collision filtering.", true);
		ParamDefTable[87].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=88, longName="shapeDescTemplate.groupsMask.useGroupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[88];
		ParamDef->init("useGroupsMask", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not the groupsMask should be used.  If so, then this will be applied to all NxShapes\n						created to represent this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Whether or not the groupsMask should be used", true);
		ParamDefTable[88].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=89, longName="shapeDescTemplate.groupsMask.bits0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[89];
		ParamDef->init("bits0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits0 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits0 of the groups mask", true);
		ParamDefTable[89].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=90, longName="shapeDescTemplate.groupsMask.bits1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[90];
		ParamDef->init("bits1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits1 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits1 of the groups mask", true);
		ParamDefTable[90].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=91, longName="shapeDescTemplate.groupsMask.bits2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[91];
		ParamDef->init("bits2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits2 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits2 of the groups mask", true);
		ParamDefTable[91].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=92, longName="shapeDescTemplate.groupsMask.bits3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[92];
		ParamDef->init("bits3", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits3 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits3 of the groups mask", true);
		ParamDefTable[92].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=93, longName="shapeDescTemplate.materialIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[93];
		ParamDef->init("materialIndex", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The material index of a shape.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The material index of a shape.", true);
		ParamDefTable[93].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=94, longName="shapeDescTemplate.density"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[94];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The density of this individual shape when computing mass inertial properties for a rigidbody (unless a valid mass >0.0 is provided).  Note that this will only be used if the body has a zero inertia tensor, or if you call NxActor::updateMassFromShapes explicitly.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The density of an individual shape.", true);
		ParamDefTable[94].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=95, longName="shapeDescTemplate.skinWidth"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[95];
		ParamDef->init("skinWidth", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Specifies by how much shapes can interpenetrate; if -1 it uses the global default.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Specifies by how much shapes can interpenetrate; if -1 it uses the global default", true);
		ParamDefTable[95].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=96, longName="shapeDescTemplate.userData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[96];
		ParamDef->init("userData", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[96].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional user data pointer.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional user data pointer", true);
		ParamDefTable[96].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=97, longName="shapeDescTemplate.name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[97];
		ParamDef->init("name", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[97].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional name string for a shape; must be set by the application and must be a persistent pointer.\n						This is applied to all NxShapes generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional name string for a shape.", true);
		ParamDefTable[97].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=98, longName="actorDescTemplate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[98];
		ParamDef->init("actorDescTemplate", TYPE_STRUCT, "ActorDescTemplate", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[98].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains the parameters the application can override on any actors created.", true);
		HintTable[2].init("shortDescription", "Contains the parameters the application can override on any actors created", true);
		ParamDefTable[98].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=99, longName="actorDescTemplate.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[99];
		ParamDef->init("flags", TYPE_STRUCT, "ActorDescFlags", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=100, longName="actorDescTemplate.flags.NX_AF_DISABLE_COLLISION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[100];
		ParamDef->init("NX_AF_DISABLE_COLLISION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable/disable collision detection.\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable/disable collision detection", true);
		ParamDefTable[100].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=101, longName="actorDescTemplate.flags.NX_AF_DISABLE_RESPONSE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[101];
		ParamDef->init("NX_AF_DISABLE_RESPONSE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable/disable collision response (reports contacts but dont use them).\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable/disable collision response (reports contacts but dont use them)", true);
		ParamDefTable[101].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=102, longName="actorDescTemplate.flags.NX_AF_LOCK_COM"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[102];
		ParamDef->init("NX_AF_LOCK_COM", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disables COM update when computing inertial properties at creation time.\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disables COM update when computing inertial properties at creation time.", true);
		ParamDefTable[102].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=103, longName="actorDescTemplate.flags.NX_AF_FLUID_DISABLE_COLLISION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[103];
		ParamDef->init("NX_AF_FLUID_DISABLE_COLLISION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disables COM update when computing inertial properties at creation time.\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disables COM update when computing inertial properties at creation time.", true);
		ParamDefTable[103].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=104, longName="actorDescTemplate.flags.NX_AF_CONTACT_MODIFICATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[104];
		ParamDef->init("NX_AF_CONTACT_MODIFICATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Turn on contact modification callback for the actor.\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Turn on contact modification callback for the actor.", true);
		ParamDefTable[104].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=105, longName="actorDescTemplate.flags.NX_AF_FORCE_CONE_FRICTION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[105];
		ParamDef->init("NX_AF_FORCE_CONE_FRICTION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Force cone friction to be used for this actor.\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Force cone friction to be used for this actor.", true);
		ParamDefTable[105].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=106, longName="actorDescTemplate.flags.NX_AF_USER_ACTOR_PAIR_FILTERING"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[106];
		ParamDef->init("NX_AF_USER_ACTOR_PAIR_FILTERING", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable/disable custom contact filtering.\n						This flag will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable/disable custom contact filtering.", true);
		ParamDefTable[106].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=107, longName="actorDescTemplate.density"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[107];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Density to be applied to the whole actor.  If the body descriptor contains a zero mass but the actor descriptor contains a non-zero density, we compute a new mass automatically from the density and a shapes.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Density to be applied to the whole actor.", true);
		ParamDefTable[107].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=108, longName="actorDescTemplate.actorCollisionGroup"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[108];
		ParamDef->init("actorCollisionGroup", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets which NxActorGroup an actor is part of.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets which NxActorGroup an actor is part of", true);
		ParamDefTable[108].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=109, longName="actorDescTemplate.dominanceGroup"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[109];
		ParamDef->init("dominanceGroup", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Dominance group for an actor.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Dominance group for an actor.", true);
		ParamDefTable[109].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=110, longName="actorDescTemplate.contactReportFlags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[110];
		ParamDef->init("contactReportFlags", TYPE_STRUCT, "ContactPairFlag", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Combination of ContactPairFlag flags.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Combination of ContactPairFlag flags", true);
		ParamDefTable[110].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=111, longName="actorDescTemplate.contactReportFlags.NX_IGNORE_PAIR"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[111];
		ParamDef->init("NX_IGNORE_PAIR", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disable contact generation for this pair.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Disable contact generation for this pair", true);
		ParamDefTable[111].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=112, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_START_TOUCH"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[112];
		ParamDef->init("NX_NOTIFY_ON_START_TOUCH", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Pair callback will be called when the pair starts to be in contact.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Pair callback will be called when the pair starts to be in contact", true);
		ParamDefTable[112].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=113, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_END_TOUCH"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[113];
		ParamDef->init("NX_NOTIFY_ON_END_TOUCH", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Pair callback will be called when the pair stops to be in contact.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Pair callback will be called when the pair stops to be in contact", true);
		ParamDefTable[113].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=114, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_TOUCH"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[114];
		ParamDef->init("NX_NOTIFY_ON_TOUCH", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Pair callback will keep getting called while the pair is in contact.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Pair callback will keep getting called while the pair is in contact", true);
		ParamDefTable[114].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=115, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_IMPACT"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[115];
		ParamDef->init("NX_NOTIFY_ON_IMPACT", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "[Not yet implemented] pair callback will be called when it may be appropriate for the pair to play an impact sound.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "[Not yet implemented] pair callback will be called when it may be appropriate for the pair to play an impact sound", true);
		ParamDefTable[115].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=116, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_ROLL"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[116];
		ParamDef->init("NX_NOTIFY_ON_ROLL", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "[Not yet implemented] pair callback will be called when the pair is in contact and rolling.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "[Not yet implemented] pair callback will be called when the pair is in contact and rolling.", true);
		ParamDefTable[116].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=117, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_SLIDE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[117];
		ParamDef->init("NX_NOTIFY_ON_SLIDE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "[Not yet implemented] pair callback will be called when the pair is in contact and sliding (and not rolling).  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "[Not yet implemented] pair callback will be called when the pair is in contact and sliding (and not rolling).", true);
		ParamDefTable[117].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=118, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_FORCES"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[118];
		ParamDef->init("NX_NOTIFY_FORCES", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The (summed total) friction force and normal force will be given in the NxContactPair variable in the contact report.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "The (summed total) friction force and normal force will be given in the NxContactPair variable in the contact report.", true);
		ParamDefTable[118].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=119, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[119];
		ParamDef->init("NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Pair callback will be called when the contact force between two actors falls below the actor-defined force thresholds.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Pair callback will be called when the contact force between two actors falls below the actor-defined force thresholds", true);
		ParamDefTable[119].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=120, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[120];
		ParamDef->init("NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Pair callback will be called when the contact force between two actors falls below the actor-defined force thresholds.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Pair callback will be called when the contact force between two actors falls below the actor-defined force thresholds", true);
		ParamDefTable[120].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=121, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[121];
		ParamDef->init("NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Pair callback will keep getting called while the contact force between two actors exceeds one of the actor-defined force thresholds.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Pair callback will keep getting called while the contact force between two actors exceeds one of the actor-defined force thresholds", true);
		ParamDefTable[121].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=122, longName="actorDescTemplate.contactReportFlags.NX_NOTIFY_CONTACT_MODIFICATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[122];
		ParamDef->init("NX_NOTIFY_CONTACT_MODIFICATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Generate a callback for all associated contact constraints, making it possible to edit the constraint. This flag is not included in NX_NOTIFY_ALL for performance reasons. see NxUserContactModify.  See the PhysX documentation for more about contact reporting.", true);
		HintTable[1].init("shortDescription", "Generate a callback for all associated contact constraints, making it possible to edit the constraint. This flag is not included in NX_NOTIFY_ALL for performance reasons. see NxUserContactModify.", true);
		ParamDefTable[122].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=123, longName="actorDescTemplate.forceFieldMaterial"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[123];
		ParamDef->init("forceFieldMaterial", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Force Field Material Index, index != 0 has to be created.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Force Field Material Index", true);
		ParamDefTable[123].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=124, longName="actorDescTemplate.userData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[124];
		ParamDef->init("userData", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[124].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional user data pointer.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional user data pointer", true);
		ParamDefTable[124].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=125, longName="actorDescTemplate.name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[125];
		ParamDef->init("name", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[125].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional name string for a shape; must be set by the application and must be a persistent pointer.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional name string for a shape; must be set by the application and must be a persistent pointer.", true);
		ParamDefTable[125].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=126, longName="actorDescTemplate.compartment"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[126];
		ParamDef->init("compartment", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[126].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional compartment pointer; must be set by the application.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional compartment pointer", true);
		ParamDefTable[126].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=127, longName="bodyDescTemplate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[127];
		ParamDef->init("bodyDescTemplate", TYPE_STRUCT, "BodyDescTemplate", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[127].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains the parameterse that the application can override for the body descriptor of rigid body actors created.", true);
		HintTable[2].init("shortDescription", "Contains the parameterse that the application can override for the body descriptor of rigid body actors created", true);
		ParamDefTable[127].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=128, longName="bodyDescTemplate.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[128];
		ParamDef->init("flags", TYPE_STRUCT, "BodyDescFlags", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Combination of body descriptor flags.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Combination of body descriptor flags", true);
		ParamDefTable[128].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=129, longName="bodyDescTemplate.flags.NX_BF_DISABLE_GRAVITY"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[129];
		ParamDef->init("NX_BF_DISABLE_GRAVITY", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Set if gravity should not be applied on this body.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Set if gravity should not be applied on this body", true);
		ParamDefTable[129].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=130, longName="bodyDescTemplate.flags.NX_BF_FILTER_SLEEP_VEL"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[130];
		ParamDef->init("NX_BF_FILTER_SLEEP_VEL", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Filter velocities used keep body awake. The filter reduces rapid oscillations and transient spikes.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Filter velocities used keep body awake. The filter reduces rapid oscillations and transient spikes", true);
		ParamDefTable[130].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=131, longName="bodyDescTemplate.flags.NX_BF_ENERGY_SLEEP_TEST"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[131];
		ParamDef->init("NX_BF_ENERGY_SLEEP_TEST", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables energy-based sleeping algorithm.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables energy-based sleeping algorithm", true);
		ParamDefTable[131].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=132, longName="bodyDescTemplate.flags.NX_BF_VISUALIZATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[132];
		ParamDef->init("NX_BF_VISUALIZATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables debug visualization for this body.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables debug visualization for this body", true);
		ParamDefTable[132].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=133, longName="bodyDescTemplate.wakeUpCounter"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[133];
		ParamDef->init("wakeUpCounter", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The bodys initial wake up counter.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The bodys initial wake up counter", true);
		ParamDefTable[133].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=134, longName="bodyDescTemplate.linearDamping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[134];
		ParamDef->init("linearDamping", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Linear damping applied to the body.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Linear damping applied to the body", true);
		ParamDefTable[134].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=135, longName="bodyDescTemplate.angularDamping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[135];
		ParamDef->init("angularDamping", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Angular damping applied to the body.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Angular damping applied to the body", true);
		ParamDefTable[135].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=136, longName="bodyDescTemplate.maxAngularVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[136];
		ParamDef->init("maxAngularVelocity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Maximum allowed angular velocity.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Maximum allowed angular velocity", true);
		ParamDefTable[136].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=137, longName="bodyDescTemplate.CCDMotionThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[137];
		ParamDef->init("CCDMotionThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When CCD is globally enabled, it is still not performed if the motion distance of all points on the body is below this threshold.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Distance threshold for CCD", true);
		ParamDefTable[137].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=138, longName="bodyDescTemplate.sleepLinearVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[138];
		ParamDef->init("sleepLinearVelocity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Maximum linear velocity at which body can go to sleep.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Maximum linear velocity at which body can go to sleep", true);
		ParamDefTable[138].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=139, longName="bodyDescTemplate.sleepAngularVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[139];
		ParamDef->init("sleepAngularVelocity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Maximum angular velocity at which body can go to sleep.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Maximum angular velocity at which body can go to sleep", true);
		ParamDefTable[139].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=140, longName="bodyDescTemplate.solverIterationCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[140];
		ParamDef->init("solverIterationCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Number of solver iterations performed when processing joint/contacts connected to this body.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Number of solver iterations performed when processing joint/contacts connected to this body", true);
		ParamDefTable[140].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=141, longName="bodyDescTemplate.sleepEnergyThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[141];
		ParamDef->init("sleepEnergyThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Threshold for the energy-based sleeping algorithm. Only used when the NX_BF_ENERGY_SLEEP_TEST flag is set.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Threshold for the energy-based sleeping algorithm. Only used when the NX_BF_ENERGY_SLEEP_TEST flag is set", true);
		ParamDefTable[141].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=142, longName="bodyDescTemplate.sleepDamping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[142];
		ParamDef->init("sleepDamping", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Damping factor for bodies that are about to sleep.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Damping factor for bodies that are about to sleep", true);
		ParamDefTable[142].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=143, longName="bodyDescTemplate.contactReportThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[143];
		ParamDef->init("contactReportThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The force threshold for contact reports.\n						This will be applied to all NxActors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The force threshold for contact reports", true);
		ParamDefTable[143].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=144, longName="p3ShapeDescTemplate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[144];
		ParamDef->init("p3ShapeDescTemplate", TYPE_STRUCT, "P3ShapeDescTemplate", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[144].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains the parameters the application can override on any actor shapes created.", true);
		HintTable[2].init("shortDescription", "Contains the parameters the application can override on any actor shapes created", true);
		ParamDefTable[144].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=145, longName="p3ShapeDescTemplate.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[145];
		ParamDef->init("flags", TYPE_STRUCT, "P3ShapeFlags", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=146, longName="p3ShapeDescTemplate.flags.eSIMULATION_SHAPE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[146];
		ParamDef->init("eSIMULATION_SHAPE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The shape will partake in collision in the physical simulation.", true);
		ParamDefTable[146].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=147, longName="p3ShapeDescTemplate.flags.eSCENE_QUERY_SHAPE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[147];
		ParamDef->init("eSCENE_QUERY_SHAPE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...). ", true);
		ParamDefTable[147].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=148, longName="p3ShapeDescTemplate.flags.eTRIGGER_SHAPE"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[148];
		ParamDef->init("eTRIGGER_SHAPE", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The shape is a trigger which can send reports whenever other shapes enter/leave its volume.\n\nNote:\nTriangle meshes and heightfields can not be triggers. Shape creation will fail in these cases.\nShapes marked as triggers do not collide with other objects. If an object should act both as a trigger shape and a collision shape then create a rigid body with two shapes, one being a trigger shape and the other a collision shape.\n", true);
		HintTable[1].init("shortDescription", "The shape is a trigger which can send reports whenever other shapes enter/leave its volume. ", true);
		ParamDefTable[148].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=149, longName="p3ShapeDescTemplate.flags.eVISUALIZATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[149];
		ParamDef->init("eVISUALIZATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable debug renderer for this shape", true);
		ParamDefTable[149].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=150, longName="p3ShapeDescTemplate.flags.ePARTICLE_DRAIN"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[150];
		ParamDef->init("ePARTICLE_DRAIN", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Sets the shape to be a particle drain", true);
		ParamDefTable[150].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=151, longName="p3ShapeDescTemplate.flags.eDEFORMABLE_DRAIN"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[151];
		ParamDef->init("eDEFORMABLE_DRAIN", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Sets the shape to be a deformable drain", true);
		ParamDefTable[151].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=152, longName="p3ShapeDescTemplate.flags.eUSE_SWEPT_BOUNDS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[152];
		ParamDef->init("eUSE_SWEPT_BOUNDS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enables the shape's use of temporal bounds during the post integration broad phase check", true);
		ParamDefTable[152].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=153, longName="p3ShapeDescTemplate.simulationFilterData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[153];
		ParamDef->init("simulationFilterData", TYPE_STRUCT, "P3FilterData", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the user definable collision filter data.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the user definable collision filter data", true);
		ParamDefTable[153].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=154, longName="p3ShapeDescTemplate.simulationFilterData.word0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[154];
		ParamDef->init("word0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word0 of the filter data", true);
		ParamDefTable[154].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=155, longName="p3ShapeDescTemplate.simulationFilterData.word1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[155];
		ParamDef->init("word1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word1 of the filter data", true);
		ParamDefTable[155].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=156, longName="p3ShapeDescTemplate.simulationFilterData.word2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[156];
		ParamDef->init("word2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word2 of the filter data", true);
		ParamDefTable[156].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=157, longName="p3ShapeDescTemplate.simulationFilterData.word3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[157];
		ParamDef->init("word3", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word3 of the filter data", true);
		ParamDefTable[157].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=158, longName="p3ShapeDescTemplate.queryFilterData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[158];
		ParamDef->init("queryFilterData", TYPE_STRUCT, "P3FilterData", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the user definable query filter data.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the user definable query filter data", true);
		ParamDefTable[158].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=159, longName="p3ShapeDescTemplate.queryFilterData.word0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[159];
		ParamDef->init("word0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word0 of the filter data", true);
		ParamDefTable[159].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=160, longName="p3ShapeDescTemplate.queryFilterData.word1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[160];
		ParamDef->init("word1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word1 of the filter data", true);
		ParamDefTable[160].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=161, longName="p3ShapeDescTemplate.queryFilterData.word2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[161];
		ParamDef->init("word2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word2 of the filter data", true);
		ParamDefTable[161].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=162, longName="p3ShapeDescTemplate.queryFilterData.word3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[162];
		ParamDef->init("word3", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "word3 of the filter data", true);
		ParamDefTable[162].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=163, longName="p3ShapeDescTemplate.material"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[163];
		ParamDef->init("material", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A PxMaterial pointer for the shape.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "A PxMaterial pointer for the shape", true);
		ParamDefTable[163].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=164, longName="p3ShapeDescTemplate.contactOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[164];
		ParamDef->init("contactOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the contact offset; if -1 it uses the global default.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the contact offset", true);
		ParamDefTable[164].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=165, longName="p3ShapeDescTemplate.restOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[165];
		ParamDef->init("restOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the rest offset; if -1 it uses the global default.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the rest offset", true);
		ParamDefTable[165].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=166, longName="p3ShapeDescTemplate.userData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[166];
		ParamDef->init("userData", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[166].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional user data pointer.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional user data pointer", true);
		ParamDefTable[166].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=167, longName="p3ShapeDescTemplate.name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[167];
		ParamDef->init("name", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[167].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional name string for a shape; must be set by the application and must be a persistent pointer.\n						This is applied to all shapes generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional name string for a shape.", true);
		ParamDefTable[167].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=168, longName="p3ActorDescTemplate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[168];
		ParamDef->init("p3ActorDescTemplate", TYPE_STRUCT, "P3ActorDescTemplate", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[168].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains the parameters the application can override on any actors created.", true);
		HintTable[2].init("shortDescription", "Contains the parameters the application can override on any actors created", true);
		ParamDefTable[168].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=169, longName="p3ActorDescTemplate.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[169];
		ParamDef->init("flags", TYPE_STRUCT, "P3ActorFlags", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=170, longName="p3ActorDescTemplate.flags.eVISUALIZATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[170];
		ParamDef->init("eVISUALIZATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enable debug renderer for this actor.\n						This flag will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enable debug renderer for this actor", true);
		ParamDefTable[170].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=171, longName="p3ActorDescTemplate.flags.eDISABLE_GRAVITY"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[171];
		ParamDef->init("eDISABLE_GRAVITY", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Disables scene gravity for this actor.\n						This flag will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Disables scene gravity for this actor", true);
		ParamDefTable[171].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=172, longName="p3ActorDescTemplate.flags.eSEND_SLEEP_NOTIFIES"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[172];
		ParamDef->init("eSEND_SLEEP_NOTIFIES", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables the sending of PxSimulationEventCallback::onWake() and PxSimulationEventCallback::onSleep() notify events.\n						This flag will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables the sending of PxSimulationEventCallback::onWake() and PxSimulationEventCallback::onSleep() notify events", true);
		ParamDefTable[172].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=173, longName="p3ActorDescTemplate.dominanceGroup"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[173];
		ParamDef->init("dominanceGroup", TYPE_U8, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Assigns dynamic actors a dominance group identifier.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Assigns dynamic actors a dominance group identifier.", true);
		ParamDefTable[173].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=174, longName="p3ActorDescTemplate.ownerClient"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[174];
		ParamDef->init("ownerClient", TYPE_U8, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the owner client of an actor.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the owner client of an actor.", true);
		ParamDefTable[174].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=175, longName="p3ActorDescTemplate.clientBehaviorBits"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[175];
		ParamDef->init("clientBehaviorBits", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Changes the behavior bits initially specified with PxActorDesc::clientBehaviorBits.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Changes the behavior bits initially specified with PxActorDesc::clientBehaviorBits.", true);
		ParamDefTable[175].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=176, longName="p3ActorDescTemplate.contactReportFlags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[176];
		ParamDef->init("contactReportFlags", TYPE_STRUCT, "P3PairFlag", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Combination of P3PairFlag flags.\n						This will be applied to all shapes generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Combination of P3PairFlag flags", true);
		ParamDefTable[176].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=177, longName="p3ActorDescTemplate.contactReportFlags.eRESOLVE_CONTACTS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[177];
		ParamDef->init("eRESOLVE_CONTACTS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Process the contacts of this collision pair in the dynamics solver.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Process the contacts of this collision pair in the dynamics solver.", true);
		ParamDefTable[177].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=178, longName="p3ActorDescTemplate.contactReportFlags.eMODIFY_CONTACTS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[178];
		ParamDef->init("eMODIFY_CONTACTS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Call contact modification callback for this collision pair.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Call contact modification callback for this collision pair. ", true);
		ParamDefTable[178].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=179, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_FOUND"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[179];
		ParamDef->init("eNOTIFY_TOUCH_FOUND", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Call contact report callback or trigger callback when this collision pair starts to be in contact.\nIf one of the two collision objects is a trigger shape (see PxShapeFlag::eTRIGGER_SHAPE) then the trigger callback will get called as soon as the other object enters the trigger volume. If none of the two collision objects is a trigger shape then the contact report callback will get called when the actors of this collision pair start to be in contact.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Call contact report callback or trigger callback when this collision pair starts to be in contact", true);
		ParamDefTable[179].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=180, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_PERSISTS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[180];
		ParamDef->init("eNOTIFY_TOUCH_PERSISTS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Process the contacts of this collision pair in the dynamics solver.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Call contact report callback or trigger callback while this collision pair is in contact", true);
		ParamDefTable[180].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=181, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_LOST"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[181];
		ParamDef->init("eNOTIFY_TOUCH_LOST", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Call contact report callback or trigger callback when this collision pair stops to be in contact.\nIf one of the two collision objects is a trigger shape (see PxShapeFlag::eTRIGGER_SHAPE) then the trigger callback will get called as soon as the other object leaves the trigger volume. If none of the two collision objects is a trigger shape then the contact report callback will get called when the actors of this collision pair stop to be in contact.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", " Call contact report callback or trigger callback when this collision pair stops to be in contact.", true);
		ParamDefTable[181].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=182, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_FOUND"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[182];
		ParamDef->init("eNOTIFY_THRESHOLD_FORCE_FOUND", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Call contact report callback when the contact force between the actors of this collision pair exceeds one of the actor-defined force thresholds.\n\nNote: Only takes effect if the colliding actors are rigid bodies\n", true);
		HintTable[1].init("shortDescription", "Call contact report callback when the contact force between the actors of this collision pair exceeds one of the actor-defined force thresholds.", true);
		ParamDefTable[182].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=183, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_PERSISTS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[183];
		ParamDef->init("eNOTIFY_THRESHOLD_FORCE_PERSISTS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Call contact report callback when the contact force between the actors of this collision pair continues to exceed one of the actor-defined force thresholds.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Call contact report callback when the contact force between the actors of this collision pair continues to exceed one of the actor-defined force thresholds", true);
		ParamDefTable[183].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=184, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_LOST"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[184];
		ParamDef->init("eNOTIFY_THRESHOLD_FORCE_LOST", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Call contact report callback when the contact force between the actors of this collision pair falls below one of the actor-defined force thresholds (includes the case where this collision pair stops being in contact).\n\nNote: Only takes effect if the colliding actors are rigid bodies\n", true);
		HintTable[1].init("shortDescription", "Call contact report callback when the contact force between the actors of this collision pair falls below one of the actor-defined force thresholds (includes the case where this collision pair stops being in contact).", true);
		ParamDefTable[184].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=185, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_POINTS"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[185];
		ParamDef->init("eNOTIFY_CONTACT_POINTS", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Provide contact points in contact reports for this collision pair.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Provide contact points in contact reports for this collision pair.", true);
		ParamDefTable[185].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=186, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FORCES"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[186];
		ParamDef->init("eNOTIFY_CONTACT_FORCES", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Provide the (summed total) friction force and normal force in contact reports for this collision pair (see PxContactPair).\n\nNote: Only takes effect if the colliding actors are rigid bodies\n", true);
		HintTable[1].init("shortDescription", "Provide the (summed total) friction force and normal force in contact reports for this collision pair (see PxContactPair).", true);
		ParamDefTable[186].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=187, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FORCE_PER_POINT"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[187];
		ParamDef->init("eNOTIFY_CONTACT_FORCE_PER_POINT", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Provide contact forces per contact point in contact reports for this collision pair.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Provide contact forces per contact point in contact reports for this collision pair.", true);
		ParamDefTable[187].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=188, longName="p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FEATURE_INDICES_PER_POINT"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[188];
		ParamDef->init("eNOTIFY_CONTACT_FEATURE_INDICES_PER_POINT", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Provide feature indices per contact point in contact reports for this collision pair.\n\nNote: Only takes effect if the colliding actors are rigid bodies.\n", true);
		HintTable[1].init("shortDescription", "Provide feature indices per contact point in contact reports for this collision pair.", true);
		ParamDefTable[188].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=189, longName="p3ActorDescTemplate.contactReportFlags.eSWEPT_CONTACT_GENERATION"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[189];
		ParamDef->init("eSWEPT_CONTACT_GENERATION", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables swept contact generation for this pair. While more costly, with swept contact generation objects pressed into each other will not tunnel through each other. It is best used for pairs involving important small or thin objects.\n\nNote: Non-static shapes of the pair should have PxShapeFlag::eUSE_SWEPT_BOUNDS specified for this feature to work correctly.\n", true);
		HintTable[1].init("shortDescription", "Enables swept contact generation for this pair. While more costly, with swept contact generation objects pressed into each other will not tunnel through each other. It is best used for pairs involving important small or thin objects.", true);
		ParamDefTable[189].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=190, longName="p3ActorDescTemplate.contactReportFlags.eSWEPT_INTEGRATION_LINEAR"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[190];
		ParamDef->init("eSWEPT_INTEGRATION_LINEAR", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A less expensive approximation of eSWEPT_INTEGRATION_FULL, where the rotational motion of the objects is neglected. Should be used when performance is of the essence, for objects where angular motion is unlikely to lead to tunneling.\n\nNote: The scene must have PxSceneFlag::eENABLE_SWEPT_INTEGRATION enabled to use this feature.\nNon-static shapes of the pair should have PxShapeFlag::eUSE_SWEPT_BOUNDS specified for this feature to work correctly.\n", true);
		HintTable[1].init("shortDescription", "A less expensive approximation of eSWEPT_INTEGRATION_FULL, where the rotational motion of the objects is neglected. Should be used when performance is of the essence, for objects where angular motion is unlikely to lead to tunneling.", true);
		ParamDefTable[190].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=191, longName="p3ActorDescTemplate.contactReportFlags.eSWEPT_INTEGRATION_FULL"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[191];
		ParamDef->init("eSWEPT_INTEGRATION_FULL", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Enables swept integration for this pair. Pairs which have this feature enabled check whether the motion of the involved shapes during integration intersect, thus preventing shapes from tunneling through each other. Kinematic motion is taken into account, but movement due to repositioning by the user is not.\nThe user should consider the less expensive version eSWEPT_INTEGRATION_LINEAR where applicable.\n\nNote: The scene must have PxSceneFlag::eENABLE_SWEPT_INTEGRATION enabled to use this feature.\nNon-static shapes of the pair should have PxShapeFlag::eUSE_SWEPT_BOUNDS specified for this feature to work correctly.\n", true);
		HintTable[1].init("shortDescription", "Enables swept integration for this pair. Pairs which have this feature enabled check whether the motion of the involved shapes during integration intersect, thus preventing shapes from tunneling through each other. Kinematic motion is taken into account, but movement due to repositioning by the user is not. ", true);
		ParamDefTable[191].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=192, longName="p3ActorDescTemplate.contactReportFlags.eCONTACT_DEFAULT"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[192];
		ParamDef->init("eCONTACT_DEFAULT", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Provided default flag to do simple contact processing for this collision pair.", true);
		ParamDefTable[192].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=193, longName="p3ActorDescTemplate.contactReportFlags.eTRIGGER_DEFAULT"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[193];
		ParamDef->init("eTRIGGER_DEFAULT", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Provided default flag to get commonly used trigger behavior for this collision pair.", true);
		ParamDefTable[193].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=194, longName="p3ActorDescTemplate.userData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[194];
		ParamDef->init("userData", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[194].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional user data pointer.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional user data pointer", true);
		ParamDefTable[194].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=195, longName="p3ActorDescTemplate.name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[195];
		ParamDef->init("name", TYPE_U64, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[195].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Optional name string for a shape; must be set by the application and must be a persistent pointer.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[2].init("shortDescription", "Optional name string for a shape; must be set by the application and must be a persistent pointer.", true);
		ParamDefTable[195].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=196, longName="p3BodyDescTemplate"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[196];
		ParamDef->init("p3BodyDescTemplate", TYPE_STRUCT, "P3BodyDescTemplate", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[196].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains the parameterse that the application can override for the body descriptor of rigid body actors created.", true);
		HintTable[2].init("shortDescription", "Contains the parameterse that the application can override for the body descriptor of rigid body actors created", true);
		ParamDefTable[196].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=197, longName="p3BodyDescTemplate.density"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[197];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The density of the body. Used to compute the mass of the body.  If the body descriptor contains a zero mass but the actor descriptor contains a non-zero density, we compute a new mass automatically from the density and a shapes.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The density of the body. Used to compute the mass of the body.", true);
		ParamDefTable[197].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=198, longName="p3BodyDescTemplate.flags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[198];
		ParamDef->init("flags", TYPE_STRUCT, "P3BodyDescFlags", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Combination of body descriptor flags.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Combination of body descriptor flags", true);
		ParamDefTable[198].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=199, longName="p3BodyDescTemplate.flags.eKINEMATIC"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[199];
		ParamDef->init("eKINEMATIC", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Kinematic actors are special dynamic actors that are not influenced by forces (such as gravity), and have no momentum. They are considered to have infinite mass and can be moved around the world using the moveKinematic() method. They will push regular dynamic actors out of the way. Kinematics will not collide with static or other kinematic objects.\nKinematic actors are great for moving platforms or characters, where direct motion control is desired.\nYou can not connect Reduced joints to kinematic actors. Lagrange joints work ok if the platform is moving with a relatively low, uniform velocity.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Enables kinematic mode for the actor", true);
		ParamDefTable[199].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=200, longName="p3BodyDescTemplate.sleepThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[200];
		ParamDef->init("sleepThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.", true);
		ParamDefTable[200].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=201, longName="p3BodyDescTemplate.wakeUpCounter"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[201];
		ParamDef->init("wakeUpCounter", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The bodys initial wake up counter.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The bodys initial wake up counter", true);
		ParamDefTable[201].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=202, longName="p3BodyDescTemplate.linearDamping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[202];
		ParamDef->init("linearDamping", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Linear damping applied to the body.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Linear damping applied to the body", true);
		ParamDefTable[202].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=203, longName="p3BodyDescTemplate.angularDamping"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[203];
		ParamDef->init("angularDamping", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the angular damping coefficient.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Sets the angular damping coefficient", true);
		ParamDefTable[203].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=204, longName="p3BodyDescTemplate.maxAngularVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[204];
		ParamDef->init("maxAngularVelocity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Maximum allowed angular velocity.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Maximum allowed angular velocity", true);
		ParamDefTable[204].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=205, longName="p3BodyDescTemplate.solverIterationCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[205];
		ParamDef->init("solverIterationCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Sets the solver iteration counts for the body.\nThe solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.\nIf intersecting bodies are being depenetrated too violently, increase the number of velocity iterations.", true);
		HintTable[1].init("shortDescription", "Sets the solver iteration counts for the body", true);
		ParamDefTable[205].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=206, longName="p3BodyDescTemplate.contactReportThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[206];
		ParamDef->init("contactReportThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The force threshold for contact reports.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "The force threshold for contact reports", true);
		ParamDefTable[206].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=207, longName="p3BodyDescTemplate.sleepLinearVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[207];
		ParamDef->init("sleepLinearVelocity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Maximum linear velocity at which body can go to sleep.\n						This will be applied to all actors generated for this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Maximum linear velocity at which body can go to sleep", true);
		ParamDefTable[207].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=208, longName="structureSettings"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[208];
		ParamDef->init("structureSettings", TYPE_STRUCT, "StructureSettings", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[208].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Contains parameters that affect structure-wide settings.", true);
		HintTable[2].init("shortDescription", "Contains parameters that affect structure-wide settings", true);
		ParamDefTable[208].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=209, longName="structureSettings.useStressSolver"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[209];
		ParamDef->init("useStressSolver", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Determines whether to invoke the use of the stress solver. The stress solver is a self-checking mechanism\nemployed within the structure, with the purpose of detecting and breaking off overly-strained links to masses\nof chunks. Its behavior can be tweaked by customizing the parameters stressSolverTimeDelay and stressSolverMassThreshold.\n", true);
		HintTable[1].init("shortDescription", "If true, the structure containing this actor will use the stress solver.", true);
		ParamDefTable[209].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=210, longName="structureSettings.stressSolverTimeDelay"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[210];
		ParamDef->init("stressSolverTimeDelay", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Determines the amount of time to run down until an identified overly-strained link breaks. From the time the stress\nsolver qualifies a link as being overly-strained, this value will be used to count down to the actual breaking-off\nevent being executed. This should always be some positive value.\n", true);
		HintTable[1].init("shortDescription", "The structure containing this actor will use the minimum stressSolverTimeDelay of all actors in the structure.", true);
		ParamDefTable[210].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=211, longName="structureSettings.stressSolverMassThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[211];
		ParamDef->init("stressSolverMassThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Determines the minimum threshold mass to meet before an indentified overly-strained link breaks. This mass threshold\nis part of the condition that the stress solver uses to qualify whether a link is overly-strained. The accumulated sum\nof the chunk masses that the link is supporting will be used against this value. This should always be some positive value.\n", true);
		HintTable[1].init("shortDescription", "The structure containing this actor will use the minimum stressSolverMassThreshold of all actors in the structure.", true);
		ParamDefTable[211].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=212, longName="defaultBehaviorGroup"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[212];
		ParamDef->init("defaultBehaviorGroup", TYPE_STRUCT, "BehaviorGroup", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default behavior group referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The default behavior group referenced by chunks", true);
		ParamDefTable[212].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=213, longName="defaultBehaviorGroup.name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[213];
		ParamDef->init("name", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Name of behavior group, eg Concrete or Glass.", true);
		HintTable[1].init("shortDescription", "Name of behavior group", true);
		ParamDefTable[213].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=214, longName="defaultBehaviorGroup.damageThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[214];
		ParamDef->init("damageThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.\n						This is obtained from the damage value passed into the NxDestructibleActor::applyDamage,\n						or NxDestructibleActor::applyRadiusDamage, or via impact (see 'forceToDamage', below).", true);
		HintTable[1].init("shortDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.", true);
		ParamDefTable[214].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=215, longName="defaultBehaviorGroup.damageToRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[215];
		ParamDef->init("damageToRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Controls the distance into the destructible to propagate damage.  The damage applied to the chunk\n						is multiplied by damageToRadius, to get the propagation distance.  All chunks within the radius\n						will have damage applied to them.  The damage applied to each chunk varies with distance to the damage\n						application position.  Full damage is taken at zero distance, and zero damage at the damage radius.\n						NOTE: This parameter is deprecated for point and radius damage.  It will be used for those types of damage if legacy damage\n						behavior is enabled with NxModuleDestructible::setUseLegacyDamageRadiusSpread.  Otherwise, the new parameters\n						damageSpread.minimumRadius, damageSpread.radiusMultiplier, and damageSpread.falloffExponent are used.  For impact damage, this parameter\n						will continue to be used, however the radius will no longer scale with object size.  The radius will continue\n						to scale with the damage as a fraction of damageThreshold, however.  If legacy damage behavior is used, this parameter\n						will behave as before with respect to impact damage as well (scaling with object size).", true);
		HintTable[1].init("shortDescription", "Controls the distance into the destructible to propagate damage.", true);
		ParamDefTable[215].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=216, longName="defaultBehaviorGroup.damageSpread"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[216];
		ParamDef->init("damageSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		ParamDefTable[216].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=217, longName="defaultBehaviorGroup.damageSpread.minimumRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[217];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[217].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=218, longName="defaultBehaviorGroup.damageSpread.radiusMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[218];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[218].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=219, longName="defaultBehaviorGroup.damageSpread.falloffExponent"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[219];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[219].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=220, longName="defaultBehaviorGroup.damageColorSpread"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[220];
		ParamDef->init("damageColorSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		ParamDefTable[220].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=221, longName="defaultBehaviorGroup.damageColorSpread.minimumRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[221];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[221].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=222, longName="defaultBehaviorGroup.damageColorSpread.radiusMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[222];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[222].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=223, longName="defaultBehaviorGroup.damageColorSpread.falloffExponent"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[223];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[223].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=224, longName="defaultBehaviorGroup.damageColorChange"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[224];
		ParamDef->init("damageColorChange", TYPE_VEC4, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes how damage changes the color of vertices in the render mesh.  If this vector is non-zero, then a dynamic\n						(per-actor) color channel will be created and initialized to the asset's color channel, if it exists.  Damage taken will go through\n						the spread and envelope function described by damageColorSpread, and each color will be modified by the resulting damage, scaled\n						by the values in damageColorChange.  The change to color channel C is given by\n						color[C] = clamp(color[C] + damageColorChange[C]*255*min(1.0, damage/damageThreshold), 0, 255).", true);
		HintTable[1].init("shortDescription", "Describes how damage changes the color of vertices in the render mesh.", true);
		ParamDefTable[224].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=225, longName="defaultBehaviorGroup.materialStrength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[225];
		ParamDef->init("materialStrength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When a chunk takes impact damage due to physical contact (see see NxDestructibleDepthParameters), this parameter\n						is the maximum impulse the contact can generate.  Weak materials such as glass may have this set to a low value, so that\n						heavier objects will pass through them during fracture.\n						N.B.: Setting this parameter to 0 disables the impulse cap; that is, zero is interpreted as infinite.\n						Default value = 0.0f.", true);
		HintTable[1].init("shortDescription", "When a chunk takes impact, this is the maximum impulse the contact can generate.", true);
		ParamDefTable[225].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=226, longName="defaultBehaviorGroup.density"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[226];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk density. (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk density", true);
		ParamDefTable[226].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=227, longName="defaultBehaviorGroup.fadeOut"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[227];
		ParamDef->init("fadeOut", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk fade out.  (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk fade out", true);
		ParamDefTable[227].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=228, longName="defaultBehaviorGroup.groupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[228];
		ParamDef->init("groupsMask", TYPE_STRUCT, "GroupsMask", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Optional groups mask for dynamic chunks created when fractured.", true);
		HintTable[1].init("shortDescription", "Optional groups mask for dynamic chunks created when fractured", true);
		ParamDefTable[228].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=229, longName="defaultBehaviorGroup.groupsMask.useGroupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[229];
		ParamDef->init("useGroupsMask", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not the groupsMask should be used.  If so, then this will be applied to all NxShapes\n						created to represent this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Whether or not the groupsMask should be used", true);
		ParamDefTable[229].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=230, longName="defaultBehaviorGroup.groupsMask.bits0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[230];
		ParamDef->init("bits0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits0 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits0 of the groups mask", true);
		ParamDefTable[230].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=231, longName="defaultBehaviorGroup.groupsMask.bits1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[231];
		ParamDef->init("bits1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits1 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits1 of the groups mask", true);
		ParamDefTable[231].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=232, longName="defaultBehaviorGroup.groupsMask.bits2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[232];
		ParamDef->init("bits2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits2 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits2 of the groups mask", true);
		ParamDefTable[232].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=233, longName="defaultBehaviorGroup.groupsMask.bits3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[233];
		ParamDef->init("bits3", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits3 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits3 of the groups mask", true);
		ParamDefTable[233].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=234, longName="behaviorGroups"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[234];
		ParamDef->init("behaviorGroups", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of behavior groups referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The array of behavior groups referenced by chunks", true);
		ParamDefTable[234].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const uint8_t dynHandleIndices[2] = { 1, 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 2);

	}

	// Initialize DefinitionImpl node: nodeIndex=235, longName="behaviorGroups[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[235];
		ParamDef->init("behaviorGroups", TYPE_STRUCT, "BehaviorGroup", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of behavior groups referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The array of behavior groups referenced by chunks", true);
		ParamDefTable[235].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=236, longName="behaviorGroups[].name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[236];
		ParamDef->init("name", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Name of behavior group, eg Concrete or Glass.", true);
		HintTable[1].init("shortDescription", "Name of behavior group", true);
		ParamDefTable[236].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=237, longName="behaviorGroups[].damageThreshold"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[237];
		ParamDef->init("damageThreshold", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.\n						This is obtained from the damage value passed into the NxDestructibleActor::applyDamage,\n						or NxDestructibleActor::applyRadiusDamage, or via impact (see 'forceToDamage', below).", true);
		HintTable[1].init("shortDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.", true);
		ParamDefTable[237].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=238, longName="behaviorGroups[].damageToRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[238];
		ParamDef->init("damageToRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Controls the distance into the destructible to propagate damage.  The damage applied to the chunk\n						is multiplied by damageToRadius, to get the propagation distance.  All chunks within the radius\n						will have damage applied to them.  The damage applied to each chunk varies with distance to the damage\n						application position.  Full damage is taken at zero distance, and zero damage at the damage radius.\n						NOTE: This parameter is deprecated for point and radius damage.  It will be used for those types of damage if legacy damage\n						behavior is enabled with NxModuleDestructible::setUseLegacyDamageRadiusSpread.  Otherwise, the new parameters\n						damageSpread.minimumRadius, damageSpread.radiusMultiplier, and damageSpread.falloffExponent are used.  For impact damage, this parameter\n						will continue to be used, however the radius will no longer scale with object size.  The radius will continue\n						to scale with the damage as a fraction of damageThreshold, however.  If legacy damage behavior is used, this parameter\n						will behave as before with respect to impact damage as well (scaling with object size).", true);
		HintTable[1].init("shortDescription", "Controls the distance into the destructible to propagate damage.", true);
		ParamDefTable[238].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=239, longName="behaviorGroups[].damageSpread"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[239];
		ParamDef->init("damageSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		ParamDefTable[239].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=240, longName="behaviorGroups[].damageSpread.minimumRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[240];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[240].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=241, longName="behaviorGroups[].damageSpread.radiusMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[241];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[241].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=242, longName="behaviorGroups[].damageSpread.falloffExponent"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[242];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[242].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=243, longName="behaviorGroups[].damageColorSpread"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[243];
		ParamDef->init("damageColorSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		ParamDefTable[243].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=244, longName="behaviorGroups[].damageColorSpread.minimumRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[244];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[244].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=245, longName="behaviorGroups[].damageColorSpread.radiusMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[245];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[245].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=246, longName="behaviorGroups[].damageColorSpread.falloffExponent"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[246];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[246].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=247, longName="behaviorGroups[].damageColorChange"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[247];
		ParamDef->init("damageColorChange", TYPE_VEC4, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes how damage changes the color of vertices in the render mesh.  If this vector is non-zero, then a dynamic\n						(per-actor) color channel will be created and initialized to the asset's color channel, if it exists.  Damage taken will go through\n						the spread and envelope function described by damageColorSpread, and each color will be modified by the resulting damage, scaled\n						by the values in damageColorChange.  The change to color channel C is given by\n						color[C] = clamp(color[C] + damageColorChange[C]*255*min(1.0, damage/damageThreshold), 0, 255).", true);
		HintTable[1].init("shortDescription", "Describes how damage changes the color of vertices in the render mesh.", true);
		ParamDefTable[247].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=248, longName="behaviorGroups[].materialStrength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[248];
		ParamDef->init("materialStrength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When a chunk takes impact damage due to physical contact (see see NxDestructibleDepthParameters), this parameter\n						is the maximum impulse the contact can generate.  Weak materials such as glass may have this set to a low value, so that\n						heavier objects will pass through them during fracture.\n						N.B.: Setting this parameter to 0 disables the impulse cap; that is, zero is interpreted as infinite.\n						Default value = 0.0f.", true);
		HintTable[1].init("shortDescription", "When a chunk takes impact, this is the maximum impulse the contact can generate.", true);
		ParamDefTable[248].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=249, longName="behaviorGroups[].density"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[249];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk density. (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk density", true);
		ParamDefTable[249].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=250, longName="behaviorGroups[].fadeOut"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[250];
		ParamDef->init("fadeOut", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk fade out.  (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk fade out", true);
		ParamDefTable[250].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=251, longName="behaviorGroups[].groupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[251];
		ParamDef->init("groupsMask", TYPE_STRUCT, "GroupsMask", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Optional groups mask for dynamic chunks created when fractured.", true);
		HintTable[1].init("shortDescription", "Optional groups mask for dynamic chunks created when fractured", true);
		ParamDefTable[251].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=252, longName="behaviorGroups[].groupsMask.useGroupsMask"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[252];
		ParamDef->init("useGroupsMask", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not the groupsMask should be used.  If so, then this will be applied to all NxShapes\n						created to represent this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Whether or not the groupsMask should be used", true);
		ParamDefTable[252].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=253, longName="behaviorGroups[].groupsMask.bits0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[253];
		ParamDef->init("bits0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits0 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits0 of the groups mask", true);
		ParamDefTable[253].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=254, longName="behaviorGroups[].groupsMask.bits1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[254];
		ParamDef->init("bits1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits1 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits1 of the groups mask", true);
		ParamDefTable[254].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=255, longName="behaviorGroups[].groupsMask.bits2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[255];
		ParamDef->init("bits2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits2 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits2 of the groups mask", true);
		ParamDefTable[255].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=256, longName="behaviorGroups[].groupsMask.bits3"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[256];
		ParamDef->init("bits3", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits3 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits3 of the groups mask", true);
		ParamDefTable[256].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[29];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(2);
		Children[2] = PDEF_PTR(3);
		Children[3] = PDEF_PTR(4);
		Children[4] = PDEF_PTR(5);
		Children[5] = PDEF_PTR(6);
		Children[6] = PDEF_PTR(7);
		Children[7] = PDEF_PTR(8);
		Children[8] = PDEF_PTR(9);
		Children[9] = PDEF_PTR(10);
		Children[10] = PDEF_PTR(11);
		Children[11] = PDEF_PTR(12);
		Children[12] = PDEF_PTR(13);
		Children[13] = PDEF_PTR(14);
		Children[14] = PDEF_PTR(15);
		Children[15] = PDEF_PTR(17);
		Children[16] = PDEF_PTR(19);
		Children[17] = PDEF_PTR(20);
		Children[18] = PDEF_PTR(21);
		Children[19] = PDEF_PTR(53);
		Children[20] = PDEF_PTR(64);
		Children[21] = PDEF_PTR(98);
		Children[22] = PDEF_PTR(127);
		Children[23] = PDEF_PTR(144);
		Children[24] = PDEF_PTR(168);
		Children[25] = PDEF_PTR(196);
		Children[26] = PDEF_PTR(208);
		Children[27] = PDEF_PTR(212);
		Children[28] = PDEF_PTR(234);

		ParamDefTable[0].setChildren(Children, 29);
	}

	// SetChildren for: nodeIndex=15, longName="overrideSkinnedMaterialNames"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(16);

		ParamDefTable[15].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=17, longName="overrideStaticMaterialNames"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(18);

		ParamDefTable[17].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=21, longName="destructibleParameters"
	{
		static Definition* Children[19];
		Children[0] = PDEF_PTR(22);
		Children[1] = PDEF_PTR(23);
		Children[2] = PDEF_PTR(24);
		Children[3] = PDEF_PTR(25);
		Children[4] = PDEF_PTR(26);
		Children[5] = PDEF_PTR(27);
		Children[6] = PDEF_PTR(28);
		Children[7] = PDEF_PTR(29);
		Children[8] = PDEF_PTR(30);
		Children[9] = PDEF_PTR(31);
		Children[10] = PDEF_PTR(32);
		Children[11] = PDEF_PTR(33);
		Children[12] = PDEF_PTR(34);
		Children[13] = PDEF_PTR(35);
		Children[14] = PDEF_PTR(36);
		Children[15] = PDEF_PTR(44);
		Children[16] = PDEF_PTR(45);
		Children[17] = PDEF_PTR(46);
		Children[18] = PDEF_PTR(47);

		ParamDefTable[21].setChildren(Children, 19);
	}

	// SetChildren for: nodeIndex=36, longName="destructibleParameters.flags"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(37);
		Children[1] = PDEF_PTR(38);
		Children[2] = PDEF_PTR(39);
		Children[3] = PDEF_PTR(40);
		Children[4] = PDEF_PTR(41);
		Children[5] = PDEF_PTR(42);
		Children[6] = PDEF_PTR(43);

		ParamDefTable[36].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=47, longName="destructibleParameters.dynamicChunksGroupsMask"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(48);
		Children[1] = PDEF_PTR(49);
		Children[2] = PDEF_PTR(50);
		Children[3] = PDEF_PTR(51);
		Children[4] = PDEF_PTR(52);

		ParamDefTable[47].setChildren(Children, 5);
	}

	// SetChildren for: nodeIndex=53, longName="depthParameters"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(54);

		ParamDefTable[53].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=54, longName="depthParameters[]"
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(55);
		Children[1] = PDEF_PTR(56);
		Children[2] = PDEF_PTR(57);
		Children[3] = PDEF_PTR(58);
		Children[4] = PDEF_PTR(59);
		Children[5] = PDEF_PTR(60);
		Children[6] = PDEF_PTR(61);
		Children[7] = PDEF_PTR(62);
		Children[8] = PDEF_PTR(63);

		ParamDefTable[54].setChildren(Children, 9);
	}

	// SetChildren for: nodeIndex=64, longName="shapeDescTemplate"
	{
		static Definition* Children[8];
		Children[0] = PDEF_PTR(65);
		Children[1] = PDEF_PTR(86);
		Children[2] = PDEF_PTR(87);
		Children[3] = PDEF_PTR(93);
		Children[4] = PDEF_PTR(94);
		Children[5] = PDEF_PTR(95);
		Children[6] = PDEF_PTR(96);
		Children[7] = PDEF_PTR(97);

		ParamDefTable[64].setChildren(Children, 8);
	}

	// SetChildren for: nodeIndex=65, longName="shapeDescTemplate.flags"
	{
		static Definition* Children[20];
		Children[0] = PDEF_PTR(66);
		Children[1] = PDEF_PTR(67);
		Children[2] = PDEF_PTR(68);
		Children[3] = PDEF_PTR(69);
		Children[4] = PDEF_PTR(70);
		Children[5] = PDEF_PTR(71);
		Children[6] = PDEF_PTR(72);
		Children[7] = PDEF_PTR(73);
		Children[8] = PDEF_PTR(74);
		Children[9] = PDEF_PTR(75);
		Children[10] = PDEF_PTR(76);
		Children[11] = PDEF_PTR(77);
		Children[12] = PDEF_PTR(78);
		Children[13] = PDEF_PTR(79);
		Children[14] = PDEF_PTR(80);
		Children[15] = PDEF_PTR(81);
		Children[16] = PDEF_PTR(82);
		Children[17] = PDEF_PTR(83);
		Children[18] = PDEF_PTR(84);
		Children[19] = PDEF_PTR(85);

		ParamDefTable[65].setChildren(Children, 20);
	}

	// SetChildren for: nodeIndex=87, longName="shapeDescTemplate.groupsMask"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(88);
		Children[1] = PDEF_PTR(89);
		Children[2] = PDEF_PTR(90);
		Children[3] = PDEF_PTR(91);
		Children[4] = PDEF_PTR(92);

		ParamDefTable[87].setChildren(Children, 5);
	}

	// SetChildren for: nodeIndex=98, longName="actorDescTemplate"
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(99);
		Children[1] = PDEF_PTR(107);
		Children[2] = PDEF_PTR(108);
		Children[3] = PDEF_PTR(109);
		Children[4] = PDEF_PTR(110);
		Children[5] = PDEF_PTR(123);
		Children[6] = PDEF_PTR(124);
		Children[7] = PDEF_PTR(125);
		Children[8] = PDEF_PTR(126);

		ParamDefTable[98].setChildren(Children, 9);
	}

	// SetChildren for: nodeIndex=99, longName="actorDescTemplate.flags"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(100);
		Children[1] = PDEF_PTR(101);
		Children[2] = PDEF_PTR(102);
		Children[3] = PDEF_PTR(103);
		Children[4] = PDEF_PTR(104);
		Children[5] = PDEF_PTR(105);
		Children[6] = PDEF_PTR(106);

		ParamDefTable[99].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=110, longName="actorDescTemplate.contactReportFlags"
	{
		static Definition* Children[12];
		Children[0] = PDEF_PTR(111);
		Children[1] = PDEF_PTR(112);
		Children[2] = PDEF_PTR(113);
		Children[3] = PDEF_PTR(114);
		Children[4] = PDEF_PTR(115);
		Children[5] = PDEF_PTR(116);
		Children[6] = PDEF_PTR(117);
		Children[7] = PDEF_PTR(118);
		Children[8] = PDEF_PTR(119);
		Children[9] = PDEF_PTR(120);
		Children[10] = PDEF_PTR(121);
		Children[11] = PDEF_PTR(122);

		ParamDefTable[110].setChildren(Children, 12);
	}

	// SetChildren for: nodeIndex=127, longName="bodyDescTemplate"
	{
		static Definition* Children[12];
		Children[0] = PDEF_PTR(128);
		Children[1] = PDEF_PTR(133);
		Children[2] = PDEF_PTR(134);
		Children[3] = PDEF_PTR(135);
		Children[4] = PDEF_PTR(136);
		Children[5] = PDEF_PTR(137);
		Children[6] = PDEF_PTR(138);
		Children[7] = PDEF_PTR(139);
		Children[8] = PDEF_PTR(140);
		Children[9] = PDEF_PTR(141);
		Children[10] = PDEF_PTR(142);
		Children[11] = PDEF_PTR(143);

		ParamDefTable[127].setChildren(Children, 12);
	}

	// SetChildren for: nodeIndex=128, longName="bodyDescTemplate.flags"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(129);
		Children[1] = PDEF_PTR(130);
		Children[2] = PDEF_PTR(131);
		Children[3] = PDEF_PTR(132);

		ParamDefTable[128].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=144, longName="p3ShapeDescTemplate"
	{
		static Definition* Children[8];
		Children[0] = PDEF_PTR(145);
		Children[1] = PDEF_PTR(153);
		Children[2] = PDEF_PTR(158);
		Children[3] = PDEF_PTR(163);
		Children[4] = PDEF_PTR(164);
		Children[5] = PDEF_PTR(165);
		Children[6] = PDEF_PTR(166);
		Children[7] = PDEF_PTR(167);

		ParamDefTable[144].setChildren(Children, 8);
	}

	// SetChildren for: nodeIndex=145, longName="p3ShapeDescTemplate.flags"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(146);
		Children[1] = PDEF_PTR(147);
		Children[2] = PDEF_PTR(148);
		Children[3] = PDEF_PTR(149);
		Children[4] = PDEF_PTR(150);
		Children[5] = PDEF_PTR(151);
		Children[6] = PDEF_PTR(152);

		ParamDefTable[145].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=153, longName="p3ShapeDescTemplate.simulationFilterData"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(154);
		Children[1] = PDEF_PTR(155);
		Children[2] = PDEF_PTR(156);
		Children[3] = PDEF_PTR(157);

		ParamDefTable[153].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=158, longName="p3ShapeDescTemplate.queryFilterData"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(159);
		Children[1] = PDEF_PTR(160);
		Children[2] = PDEF_PTR(161);
		Children[3] = PDEF_PTR(162);

		ParamDefTable[158].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=168, longName="p3ActorDescTemplate"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(169);
		Children[1] = PDEF_PTR(173);
		Children[2] = PDEF_PTR(174);
		Children[3] = PDEF_PTR(175);
		Children[4] = PDEF_PTR(176);
		Children[5] = PDEF_PTR(194);
		Children[6] = PDEF_PTR(195);

		ParamDefTable[168].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=169, longName="p3ActorDescTemplate.flags"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(170);
		Children[1] = PDEF_PTR(171);
		Children[2] = PDEF_PTR(172);

		ParamDefTable[169].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=176, longName="p3ActorDescTemplate.contactReportFlags"
	{
		static Definition* Children[17];
		Children[0] = PDEF_PTR(177);
		Children[1] = PDEF_PTR(178);
		Children[2] = PDEF_PTR(179);
		Children[3] = PDEF_PTR(180);
		Children[4] = PDEF_PTR(181);
		Children[5] = PDEF_PTR(182);
		Children[6] = PDEF_PTR(183);
		Children[7] = PDEF_PTR(184);
		Children[8] = PDEF_PTR(185);
		Children[9] = PDEF_PTR(186);
		Children[10] = PDEF_PTR(187);
		Children[11] = PDEF_PTR(188);
		Children[12] = PDEF_PTR(189);
		Children[13] = PDEF_PTR(190);
		Children[14] = PDEF_PTR(191);
		Children[15] = PDEF_PTR(192);
		Children[16] = PDEF_PTR(193);

		ParamDefTable[176].setChildren(Children, 17);
	}

	// SetChildren for: nodeIndex=196, longName="p3BodyDescTemplate"
	{
		static Definition* Children[10];
		Children[0] = PDEF_PTR(197);
		Children[1] = PDEF_PTR(198);
		Children[2] = PDEF_PTR(200);
		Children[3] = PDEF_PTR(201);
		Children[4] = PDEF_PTR(202);
		Children[5] = PDEF_PTR(203);
		Children[6] = PDEF_PTR(204);
		Children[7] = PDEF_PTR(205);
		Children[8] = PDEF_PTR(206);
		Children[9] = PDEF_PTR(207);

		ParamDefTable[196].setChildren(Children, 10);
	}

	// SetChildren for: nodeIndex=198, longName="p3BodyDescTemplate.flags"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(199);

		ParamDefTable[198].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=208, longName="structureSettings"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(209);
		Children[1] = PDEF_PTR(210);
		Children[2] = PDEF_PTR(211);

		ParamDefTable[208].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=212, longName="defaultBehaviorGroup"
	{
		static Definition* Children[10];
		Children[0] = PDEF_PTR(213);
		Children[1] = PDEF_PTR(214);
		Children[2] = PDEF_PTR(215);
		Children[3] = PDEF_PTR(216);
		Children[4] = PDEF_PTR(220);
		Children[5] = PDEF_PTR(224);
		Children[6] = PDEF_PTR(225);
		Children[7] = PDEF_PTR(226);
		Children[8] = PDEF_PTR(227);
		Children[9] = PDEF_PTR(228);

		ParamDefTable[212].setChildren(Children, 10);
	}

	// SetChildren for: nodeIndex=216, longName="defaultBehaviorGroup.damageSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(217);
		Children[1] = PDEF_PTR(218);
		Children[2] = PDEF_PTR(219);

		ParamDefTable[216].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=220, longName="defaultBehaviorGroup.damageColorSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(221);
		Children[1] = PDEF_PTR(222);
		Children[2] = PDEF_PTR(223);

		ParamDefTable[220].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=228, longName="defaultBehaviorGroup.groupsMask"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(229);
		Children[1] = PDEF_PTR(230);
		Children[2] = PDEF_PTR(231);
		Children[3] = PDEF_PTR(232);
		Children[4] = PDEF_PTR(233);

		ParamDefTable[228].setChildren(Children, 5);
	}

	// SetChildren for: nodeIndex=234, longName="behaviorGroups"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(235);

		ParamDefTable[234].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=235, longName="behaviorGroups[]"
	{
		static Definition* Children[10];
		Children[0] = PDEF_PTR(236);
		Children[1] = PDEF_PTR(237);
		Children[2] = PDEF_PTR(238);
		Children[3] = PDEF_PTR(239);
		Children[4] = PDEF_PTR(243);
		Children[5] = PDEF_PTR(247);
		Children[6] = PDEF_PTR(248);
		Children[7] = PDEF_PTR(249);
		Children[8] = PDEF_PTR(250);
		Children[9] = PDEF_PTR(251);

		ParamDefTable[235].setChildren(Children, 10);
	}

	// SetChildren for: nodeIndex=239, longName="behaviorGroups[].damageSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(240);
		Children[1] = PDEF_PTR(241);
		Children[2] = PDEF_PTR(242);

		ParamDefTable[239].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=243, longName="behaviorGroups[].damageColorSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(244);
		Children[1] = PDEF_PTR(245);
		Children[2] = PDEF_PTR(246);

		ParamDefTable[243].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=251, longName="behaviorGroups[].groupsMask"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(252);
		Children[1] = PDEF_PTR(253);
		Children[2] = PDEF_PTR(254);
		Children[3] = PDEF_PTR(255);
		Children[4] = PDEF_PTR(256);

		ParamDefTable[251].setChildren(Children, 5);
	}

	mBuiltFlag = true;

}
void DestructibleActorParam_0p18::initStrings(void)
{
	crumbleEmitterName.isAllocated = false;
	crumbleEmitterName.buf = (const char*)0;
	dustEmitterName.isAllocated = false;
	dustEmitterName.buf = (const char*)0;
	defaultBehaviorGroup.name.isAllocated = true;
	defaultBehaviorGroup.name.buf = NULL;
}

void DestructibleActorParam_0p18::initDynamicArrays(void)
{
	overrideSkinnedMaterialNames.buf = NULL;
	overrideSkinnedMaterialNames.isAllocated = true;
	overrideSkinnedMaterialNames.elementSize = sizeof(NvParameterized::DummyStringStruct);
	overrideSkinnedMaterialNames.arraySizes[0] = 0;
	overrideStaticMaterialNames.buf = NULL;
	overrideStaticMaterialNames.isAllocated = true;
	overrideStaticMaterialNames.elementSize = sizeof(NvParameterized::DummyStringStruct);
	overrideStaticMaterialNames.arraySizes[0] = 0;
	depthParameters.buf = NULL;
	depthParameters.isAllocated = true;
	depthParameters.elementSize = sizeof(DestructibleDepthParameters_Type);
	depthParameters.arraySizes[0] = 0;
	behaviorGroups.buf = NULL;
	behaviorGroups.isAllocated = true;
	behaviorGroups.elementSize = sizeof(BehaviorGroup_Type);
	behaviorGroups.arraySizes[0] = 0;
}

void DestructibleActorParam_0p18::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	crumbleParticleSpacing = float(0);
	dustParticleSpacing = float(0);
	{
		const float value[12] = {true};
		for (int i = 0; i < 12; ++i)
		{
			globalPose[i] = value[i];
		}
	}
	scale = physx::PxVec3(init(1, 1, 1));
	dynamic = bool(true);
	supportDepth = uint32_t(0);
	formExtendedStructures = bool(false);
	keepPreviousFrameBoneBuffer = bool(false);
	useAssetDefinedSupport = bool(false);
	useWorldSupport = bool(false);
	renderStaticChunksSeparately = bool(false);
	createChunkEvents = bool(false);
	sleepVelocityFrameDecayConstant = float(1);
	useHardSleeping = bool(false);
	destructibleParameters.damageCap = float(0);
	destructibleParameters.forceToDamage = float(0);
	destructibleParameters.impactVelocityThreshold = float(0);
	destructibleParameters.minimumFractureDepth = uint32_t(0);
	destructibleParameters.impactDamageDefaultDepth = int32_t(-1);
	destructibleParameters.debrisDepth = int32_t(-1);
	destructibleParameters.essentialDepth = uint32_t(0);
	destructibleParameters.debrisLifetimeMin = float(1);
	destructibleParameters.debrisLifetimeMax = float(10);
	destructibleParameters.debrisMaxSeparationMin = float(1);
	destructibleParameters.debrisMaxSeparationMax = float(10);
	destructibleParameters.debrisDestructionProbability = float(0);
	destructibleParameters.validBounds = physx::PxBounds3(init(-1000, -1000, -1000, 1000, 1000, 1000));
	destructibleParameters.maxChunkSpeed = float(0);
	destructibleParameters.flags.ACCUMULATE_DAMAGE = bool(true);
	destructibleParameters.flags.DEBRIS_TIMEOUT = bool(false);
	destructibleParameters.flags.DEBRIS_MAX_SEPARATION = bool(false);
	destructibleParameters.flags.CRUMBLE_SMALLEST_CHUNKS = bool(false);
	destructibleParameters.flags.ACCURATE_RAYCASTS = bool(false);
	destructibleParameters.flags.USE_VALID_BOUNDS = bool(false);
	destructibleParameters.flags.CRUMBLE_VIA_RUNTIME_FRACTURE = bool(false);
	destructibleParameters.fractureImpulseScale = float(0);
	destructibleParameters.damageDepthLimit = uint16_t(UINT16_MAX);
	destructibleParameters.dynamicChunkDominanceGroup = uint16_t(UINT16_MAX);
	destructibleParameters.dynamicChunksGroupsMask.useGroupsMask = bool(false);
	destructibleParameters.dynamicChunksGroupsMask.bits0 = uint32_t(0);
	destructibleParameters.dynamicChunksGroupsMask.bits1 = uint32_t(0);
	destructibleParameters.dynamicChunksGroupsMask.bits2 = uint32_t(0);
	destructibleParameters.dynamicChunksGroupsMask.bits3 = uint32_t(0);
	shapeDescTemplate.flags.NX_TRIGGER_ON_ENTER = bool(false);
	shapeDescTemplate.flags.NX_TRIGGER_ON_LEAVE = bool(false);
	shapeDescTemplate.flags.NX_TRIGGER_ON_STAY = bool(false);
	shapeDescTemplate.flags.NX_SF_VISUALIZATION = bool(true);
	shapeDescTemplate.flags.NX_SF_DISABLE_COLLISION = bool(false);
	shapeDescTemplate.flags.NX_SF_FEATURE_INDICES = bool(false);
	shapeDescTemplate.flags.NX_SF_DISABLE_RAYCASTING = bool(false);
	shapeDescTemplate.flags.NX_SF_POINT_CONTACT_FORCE = bool(false);
	shapeDescTemplate.flags.NX_SF_FLUID_DRAIN = bool(false);
	shapeDescTemplate.flags.NX_SF_FLUID_DISABLE_COLLISION = bool(false);
	shapeDescTemplate.flags.NX_SF_FLUID_TWOWAY = bool(false);
	shapeDescTemplate.flags.NX_SF_DISABLE_RESPONSE = bool(false);
	shapeDescTemplate.flags.NX_SF_DYNAMIC_DYNAMIC_CCD = bool(false);
	shapeDescTemplate.flags.NX_SF_DISABLE_SCENE_QUERIES = bool(false);
	shapeDescTemplate.flags.NX_SF_CLOTH_DRAIN = bool(false);
	shapeDescTemplate.flags.NX_SF_CLOTH_DISABLE_COLLISION = bool(false);
	shapeDescTemplate.flags.NX_SF_CLOTH_TWOWAY = bool(true);
	shapeDescTemplate.flags.NX_SF_SOFTBODY_DRAIN = bool(false);
	shapeDescTemplate.flags.NX_SF_SOFTBODY_DISABLE_COLLISION = bool(false);
	shapeDescTemplate.flags.NX_SF_SOFTBODY_TWOWAY = bool(true);
	shapeDescTemplate.collisionGroup = uint16_t(0);
	shapeDescTemplate.groupsMask.useGroupsMask = bool(false);
	shapeDescTemplate.groupsMask.bits0 = uint32_t(0);
	shapeDescTemplate.groupsMask.bits1 = uint32_t(0);
	shapeDescTemplate.groupsMask.bits2 = uint32_t(0);
	shapeDescTemplate.groupsMask.bits3 = uint32_t(0);
	shapeDescTemplate.materialIndex = uint16_t(0);
	shapeDescTemplate.density = float(1);
	shapeDescTemplate.skinWidth = float(-1);
	shapeDescTemplate.userData = uint64_t(0);
	shapeDescTemplate.name = uint64_t(0);
	actorDescTemplate.flags.NX_AF_DISABLE_COLLISION = bool(false);
	actorDescTemplate.flags.NX_AF_DISABLE_RESPONSE = bool(false);
	actorDescTemplate.flags.NX_AF_LOCK_COM = bool(false);
	actorDescTemplate.flags.NX_AF_FLUID_DISABLE_COLLISION = bool(false);
	actorDescTemplate.flags.NX_AF_CONTACT_MODIFICATION = bool(false);
	actorDescTemplate.flags.NX_AF_FORCE_CONE_FRICTION = bool(false);
	actorDescTemplate.flags.NX_AF_USER_ACTOR_PAIR_FILTERING = bool(false);
	actorDescTemplate.density = float(1);
	actorDescTemplate.actorCollisionGroup = uint16_t(0);
	actorDescTemplate.dominanceGroup = uint16_t(0);
	actorDescTemplate.contactReportFlags.NX_IGNORE_PAIR = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_START_TOUCH = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_END_TOUCH = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_TOUCH = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_IMPACT = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_ROLL = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_SLIDE = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_FORCES = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD = bool(false);
	actorDescTemplate.contactReportFlags.NX_NOTIFY_CONTACT_MODIFICATION = bool(false);
	actorDescTemplate.forceFieldMaterial = uint16_t(0);
	actorDescTemplate.userData = uint64_t(0);
	actorDescTemplate.name = uint64_t(0);
	actorDescTemplate.compartment = uint64_t(0);
	bodyDescTemplate.flags.NX_BF_DISABLE_GRAVITY = bool(false);
	bodyDescTemplate.flags.NX_BF_FILTER_SLEEP_VEL = bool(false);
	bodyDescTemplate.flags.NX_BF_ENERGY_SLEEP_TEST = bool(true);
	bodyDescTemplate.flags.NX_BF_VISUALIZATION = bool(true);
	bodyDescTemplate.wakeUpCounter = float(0.4);
	bodyDescTemplate.linearDamping = float(0);
	bodyDescTemplate.angularDamping = float(0.05);
	bodyDescTemplate.maxAngularVelocity = float(-1);
	bodyDescTemplate.CCDMotionThreshold = float(0);
	bodyDescTemplate.sleepLinearVelocity = float(-1);
	bodyDescTemplate.sleepAngularVelocity = float(-1);
	bodyDescTemplate.solverIterationCount = uint32_t(4);
	bodyDescTemplate.sleepEnergyThreshold = float(0.005);
	bodyDescTemplate.sleepDamping = float(0);
	bodyDescTemplate.contactReportThreshold = float(PX_MAX_F32);
	p3ShapeDescTemplate.flags.eSIMULATION_SHAPE = bool(true);
	p3ShapeDescTemplate.flags.eSCENE_QUERY_SHAPE = bool(true);
	p3ShapeDescTemplate.flags.eTRIGGER_SHAPE = bool(false);
	p3ShapeDescTemplate.flags.eVISUALIZATION = bool(true);
	p3ShapeDescTemplate.flags.ePARTICLE_DRAIN = bool(false);
	p3ShapeDescTemplate.flags.eDEFORMABLE_DRAIN = bool(false);
	p3ShapeDescTemplate.flags.eUSE_SWEPT_BOUNDS = bool(false);
	p3ShapeDescTemplate.simulationFilterData.word0 = uint32_t(0);
	p3ShapeDescTemplate.simulationFilterData.word1 = uint32_t(0);
	p3ShapeDescTemplate.simulationFilterData.word2 = uint32_t(0);
	p3ShapeDescTemplate.simulationFilterData.word3 = uint32_t(0);
	p3ShapeDescTemplate.queryFilterData.word0 = uint32_t(0);
	p3ShapeDescTemplate.queryFilterData.word1 = uint32_t(0);
	p3ShapeDescTemplate.queryFilterData.word2 = uint32_t(0);
	p3ShapeDescTemplate.queryFilterData.word3 = uint32_t(0);
	p3ShapeDescTemplate.material = uint64_t(0);
	p3ShapeDescTemplate.contactOffset = float(0.02);
	p3ShapeDescTemplate.restOffset = float(0);
	p3ShapeDescTemplate.userData = uint64_t(0);
	p3ShapeDescTemplate.name = uint64_t(0);
	p3ActorDescTemplate.flags.eVISUALIZATION = bool(true);
	p3ActorDescTemplate.flags.eDISABLE_GRAVITY = bool(false);
	p3ActorDescTemplate.flags.eSEND_SLEEP_NOTIFIES = bool(true);
	p3ActorDescTemplate.dominanceGroup = uint8_t(0);
	p3ActorDescTemplate.ownerClient = uint8_t(0);
	p3ActorDescTemplate.clientBehaviorBits = uint32_t(0);
	p3ActorDescTemplate.contactReportFlags.eRESOLVE_CONTACTS = bool(false);
	p3ActorDescTemplate.contactReportFlags.eMODIFY_CONTACTS = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_FOUND = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_PERSISTS = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_TOUCH_LOST = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_FOUND = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_PERSISTS = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_THRESHOLD_FORCE_LOST = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_POINTS = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FORCES = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FORCE_PER_POINT = bool(false);
	p3ActorDescTemplate.contactReportFlags.eNOTIFY_CONTACT_FEATURE_INDICES_PER_POINT = bool(false);
	p3ActorDescTemplate.contactReportFlags.eSWEPT_CONTACT_GENERATION = bool(false);
	p3ActorDescTemplate.contactReportFlags.eSWEPT_INTEGRATION_LINEAR = bool(false);
	p3ActorDescTemplate.contactReportFlags.eSWEPT_INTEGRATION_FULL = bool(false);
	p3ActorDescTemplate.contactReportFlags.eCONTACT_DEFAULT = bool(false);
	p3ActorDescTemplate.contactReportFlags.eTRIGGER_DEFAULT = bool(false);
	p3ActorDescTemplate.userData = uint64_t(0);
	p3ActorDescTemplate.name = uint64_t(0);
	p3BodyDescTemplate.density = float(1);
	p3BodyDescTemplate.flags.eKINEMATIC = bool(false);
	p3BodyDescTemplate.sleepThreshold = float(0.005);
	p3BodyDescTemplate.wakeUpCounter = float(0.4);
	p3BodyDescTemplate.linearDamping = float(0);
	p3BodyDescTemplate.angularDamping = float(0.05);
	p3BodyDescTemplate.maxAngularVelocity = float(7);
	p3BodyDescTemplate.solverIterationCount = uint32_t(4);
	p3BodyDescTemplate.contactReportThreshold = float(PX_MAX_F32);
	p3BodyDescTemplate.sleepLinearVelocity = float(-1);
	structureSettings.useStressSolver = bool(false);
	structureSettings.stressSolverTimeDelay = float(1.0);
	structureSettings.stressSolverMassThreshold = float(0.0);
	defaultBehaviorGroup.damageThreshold = float(1);
	defaultBehaviorGroup.damageToRadius = float(0.1);
	defaultBehaviorGroup.damageSpread.minimumRadius = float(0);
	defaultBehaviorGroup.damageSpread.radiusMultiplier = float(1);
	defaultBehaviorGroup.damageSpread.falloffExponent = float(1);
	defaultBehaviorGroup.damageColorSpread.minimumRadius = float(0);
	defaultBehaviorGroup.damageColorSpread.radiusMultiplier = float(1);
	defaultBehaviorGroup.damageColorSpread.falloffExponent = float(1);
	defaultBehaviorGroup.damageColorChange = physx::PxVec4(initVec4(0, 0, 0, 0));
	defaultBehaviorGroup.materialStrength = float(0);
	defaultBehaviorGroup.density = float(0);
	defaultBehaviorGroup.fadeOut = float(1);
	defaultBehaviorGroup.groupsMask.useGroupsMask = bool(false);
	defaultBehaviorGroup.groupsMask.bits0 = uint32_t(0);
	defaultBehaviorGroup.groupsMask.bits1 = uint32_t(0);
	defaultBehaviorGroup.groupsMask.bits2 = uint32_t(0);
	defaultBehaviorGroup.groupsMask.bits3 = uint32_t(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void DestructibleActorParam_0p18::initReferences(void)
{
}

void DestructibleActorParam_0p18::freeDynamicArrays(void)
{
	if (overrideSkinnedMaterialNames.isAllocated && overrideSkinnedMaterialNames.buf)
	{
		mParameterizedTraits->free(overrideSkinnedMaterialNames.buf);
	}
	if (overrideStaticMaterialNames.isAllocated && overrideStaticMaterialNames.buf)
	{
		mParameterizedTraits->free(overrideStaticMaterialNames.buf);
	}
	if (depthParameters.isAllocated && depthParameters.buf)
	{
		mParameterizedTraits->free(depthParameters.buf);
	}
	if (behaviorGroups.isAllocated && behaviorGroups.buf)
	{
		mParameterizedTraits->free(behaviorGroups.buf);
	}
}

void DestructibleActorParam_0p18::freeStrings(void)
{

	if (crumbleEmitterName.isAllocated && crumbleEmitterName.buf)
	{
		mParameterizedTraits->strfree((char*)crumbleEmitterName.buf);
	}

	if (dustEmitterName.isAllocated && dustEmitterName.buf)
	{
		mParameterizedTraits->strfree((char*)dustEmitterName.buf);
	}

	for (int i = 0; i < overrideSkinnedMaterialNames.arraySizes[0]; ++i)
	{
		if (overrideSkinnedMaterialNames.buf[i].isAllocated && overrideSkinnedMaterialNames.buf[i].buf)
		{
			mParameterizedTraits->strfree((char*)overrideSkinnedMaterialNames.buf[i].buf);
		}
	}

	for (int i = 0; i < overrideStaticMaterialNames.arraySizes[0]; ++i)
	{
		if (overrideStaticMaterialNames.buf[i].isAllocated && overrideStaticMaterialNames.buf[i].buf)
		{
			mParameterizedTraits->strfree((char*)overrideStaticMaterialNames.buf[i].buf);
		}
	}

	if (defaultBehaviorGroup.name.isAllocated && defaultBehaviorGroup.name.buf)
	{
		mParameterizedTraits->strfree((char*)defaultBehaviorGroup.name.buf);
	}

	for (int i = 0; i < behaviorGroups.arraySizes[0]; ++i)
	{
		if (behaviorGroups.buf[i].name.isAllocated && behaviorGroups.buf[i].name.buf)
		{
			mParameterizedTraits->strfree((char*)behaviorGroups.buf[i].name.buf);
		}
	}
}

void DestructibleActorParam_0p18::freeReferences(void)
{
}

} // namespace parameterized
} // namespace nvidia
